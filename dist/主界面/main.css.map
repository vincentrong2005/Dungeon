{"version":3,"file":"main.css","mappings":";AAsMA,iCACE,iBACF,CAEA,wCACE,UAAW,CACX,iBAAkB,CAClB,UAAW,CACX,qBAAsB,CACtB,sCAA0C,CAC1C,sEAEmC,CACnC,mBACF;;ACogJA,sCACE,uCAA+B,CAC/B,kCAAmC,CACnC,4BAA6B,CAC7B,aACF,CAEA,4CACE,wBAAyB,CACzB,uEAEiC,CACjC,4CACF,CAEA,qCACE,WAAY,CACZ,UAAW,CACX,sCACF,CAEA,yCACE,0GACF,CAEA,2CACE,QAEE,uBACF,CACA,IACE,0BACF,CACF,CAEA,uCACE,iBAAkB,CAClB,WAAY,CACZ,8BAAgC,CAChC,UAAW,CACX,mBACF,CAEA,+CACE,QAAS,CACT,OACF,CAEA,8CACE,QAAS,CACT,OACF,CAEA,6CACE,YAAa,CACb,kBAAmB,CACnB,oCAAuC,CACvC,6CACF,CAEA,wFACE,wHACF,CAEA,uFACE,uHACF,CAEA,sFACE,kGACF,CAEA,qFACE,iGACF,CAEA,2KAEE,gGACF,CAEA,uCACE,GACE,YAAa,CACb,qCACF,CACA,IACE,SAAU,CACV,+CACF,CACA,IACE,SAAU,CACV,8CACF,CACA,KACE,SAAU,CACV,8CACF,CACF,CAEA,sCACE,GACE,YAAa,CACb,qCACF,CACA,IACE,SAAU,CACV,+CACF,CACA,IACE,SAAU,CACV,+CACF,CACA,KACE,SAAU,CACV,+CACF,CACF,CAEA,qCACE,GACE,YAAa,CACb,qCACF,CACA,IACE,SAAU,CACV,+CACF,CACA,IACE,SAAU,CACV,iDACF,CACA,KACE,SAAU,CACV,iDACF,CACF,CAEA,oCACE,GACE,YAAa,CACb,qCACF,CACA,IACE,SAAU,CACV,+CACF,CACA,IACE,SAAU,CACV,gDACF,CACA,KACE,SAAU,CACV,gDACF,CACF,CAEA,mCACE,GACE,YAAa,CACb,kBACF,CACA,KACE,SAAU,CACV,qBACF,CACF,CAEA,oCACE,GACE,SAAU,CACV,uCACF,CACA,IACE,SACF,CACA,KACE,SAAU,CACV,2CACF,CACF,CAEA,6CACE,4DACF,CAEA,oJAGE,8DACF,CAEA,6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AAgC,CAChC,iBAAkB,CAClB,mBACF,CAGA,6BACE,YAAa,CACb,kBAAmB,CACnB,WACF,CAEA,8BACE,YAAa,CACb,mBAAoB,CACpB,sBAAuB,CACvB,cACF,CAGA,6BACE,YAAa,CACb,kBAAmB,CACnB,WAAY,CACZ,oBACF,CAEA,2BACE,YAAa,CACb,aAAc,CACd,qBAAsB,CACtB,qCAAyC,CACzC,eAAgB,CAChB,2BAA+B,CAC/B,aAAc,CACd,uCAA2C,CAC3C,wBACF,CAEA,6CACE,iCAAqC,CACrC,yCACF,CAEA,+BACE,UAAW,CACX,WAAY,CACZ,gBAAiB,CACjB,mBACF,CAEA,oCACE,UAAW,CACX,WAAY,CACZ,mBAAoB,CACpB,kBAAmB,CACnB,sBAAuB,CACvB,0BAA8B,CAC9B,gBAAiB,CACjB,gBACF,CAEA,kCACE,WACF,CAGA,4BACE,iBAAkB,CAClB,YAAa,CACb,aAAc,CACd,aAAc,CACd,YAAa,CACb,oBAAqB,CACrB,6BACF,CAEA,2BACE,qBAAsB,CACtB,yCAA0C,CAC1C,iBAAkB,CAClB,qBACF,CAEA,oCACE,WAAY,CACZ,kBACF,CAEA,gCACE,yEAAkF,CAClF,+BACF,CAEA,qDACE,0EAAmF,CACnF,wCACF,CAEA,iCACE,2BAA+B,CAC/B,iBAAkB,CAClB,qBACF,CAGA,oKAIE,kDACF,CAEA,uCACE,SAAU,CACV,8DACF,CAEA,qCACE,SAAU,CACV,6DACF,CAEA,uCACE,SAAU,CACV,8DACF,CAEA,qCACE,SAAU,CACV,6DACF,CAGA,yBACE,8BACE,yBACF,CAEA,2BACE,kBAAmB,CACnB,cAAe,CACf,kBAAmB,CACnB,eACF,CAEA,6BACE,UACF,CAEA,+BACE,UAAW,CACX,eACF,CAEA,4BACE,6CACF,CACF;;AC31BA,0CACE,gDACF,CACA,0CACE,gDACF,CACA,wCACE,SAAU,CACV,qBACF,CACA,sCACE,SAAU,CACV,qBACF;;ACvEA,kFC86BqB,CA96BrB,sCAAyC,CAEzC,aACE,YACE,wHAEyD,CAEzD,uGAE0B,CAG1B,yCAA0C,CAC1C,yCAA0C,CAC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B,iBACE,QAEE,uBACD,CACD,IACE,2BACD,CACF,CAED,mBACE,GACE,6BACD,CACD,KACE,4BACD,CACF,CAED,gBACE,GACE,sCAAwC,CACxC,SACD,CACD,KACE,gCAAkC,CAClC,SACD,CACF,CAED,qBACE,GACE,uCAAyC,CACzC,SACD,CACD,IACE,uCAAyC,CACzC,SACD,CACD,KACE,gCAAkC,CAClC,SACD,CACF,CAED,sBACE,GACE,sCAAwC,CACxC,SACD,CACD,IACE,sCAAwC,CACxC,SACD,CACD,KACE,gCAAkC,CAClC,SACD,CACF,CAED,mBACE,GACE,kBAAoB,CACpB,oBACD,CACD,IACE,kCAAoC,CACpC,gDAAkD,CAClD,WACD,CACD,KACE,kCAAoC,CACpC,SAAW,CACX,oBACD,CACF,CAED,iBACE,QAEE,+BACD,CACD,QAEE,8BACD,CACD,YAGE,+BACD,CACD,QAEE,8BACD,CACF,CAGD,oBACE,SACD,CAED,0BACE,kBACD,CAED,0BACE,kBAAoB,CACpB,iBAAmB,CACnB,wBACD,CAED,gCACE,kBACD,CAED,qCACE,SACD,CAED,2CACE,kBACD,CAGD,aACE,6BAAkC,CAClC,0BAA4B,CAC5B,kCAAoC,CACpC,uCAA4C,CAC5C,qCACD,CAGD,WACE,iBAAmB,CACnB,KAAO,CACP,MAAQ,CACR,UAAY,CACZ,WAAa,CACb,qHAME,CACF,wBAA0B,CAC1B,mBAAqB,CACrB,YAAc,CACd,YACD,CAED,KACE,wBAA0B,CAC1B,aAAe,CACf,QAAU,CACV,SAAW,CACX,eACD,CDovBC,qCAAmB,CAAnB,cAAmB,CAAnB,eAAmB,CAAnB,qCAAmB,CAAnB,cAAmB,CAAnB,eAAmB,CAAnB,qCAAmB,CAAnB,cAAmB,CAAnB,eAAmB,CAAnB,iCAAmB,CAAnB,cAAmB,CAAnB,eAAmB,CAAnB,iCAAmB,CAAnB,cAAmB,CAAnB,eAAmB,CAAnB,iCAAmB,CAAnB,cAAmB,CAAnB,eAAmB,CAAnB,kCAAmB,CAAnB,cAAmB,CAAnB,kCAAmB,CAAnB,cAAmB,CAAnB,kCAAmB,CAAnB,cAAmB,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","sources":["src://tavern_helper_template/src/主界面/components/DungeonCard.vue","src://tavern_helper_template/src/主界面/components/CombatView.vue","src://tavern_helper_template/src/主界面/components/GameView.vue","src://tavern_helper_template/src/主界面/components/WitchCollectionModal.vue","src://tavern_helper_template/src/主界面/App.vue","src://tavern_helper_template/<no source>","src://tavern_helper_template/node_modules/.pnpm/tailwindcss@4.2.1/node_modules/tailwindcss/index.css","src://tavern_helper_template/src/主界面/styles.css"],"sourcesContent":["<template>\n  <!-- Face Down Card -->\n  <div\n    v-if=\"faceDown\"\n    class=\"w-40 h-60 rounded-xl bg-[#252030] border-2 border-[#3a3040] shadow-xl relative overflow-hidden group transition-transform duration-300 hover:-translate-y-2\"\n    :class=\"className\"\n  >\n    <div class=\"absolute inset-2 flex items-center justify-center border border-[#4a2e1a] opacity-50\">\n      <div class=\"size-16 rounded-full border-2 border-[#5c3a21] opacity-30\"></div>\n    </div>\n  </div>\n\n  <!-- Face Up Card -->\n  <div\n    v-else\n    class=\"relative w-40 h-60 rounded-xl shadow-2xl transition-all duration-300 transform bg-[#16121e] border-2 cursor-pointer\"\n    :class=\"[\n      typeColorClass,\n      isRareCard ? 'rare-card-glow' : '',\n      selected ? 'ring-4 ring-dungeon-gold -translate-y-6 scale-105 z-20' : 'hover:-translate-y-2 hover:z-10',\n      disabled ? 'opacity-80 !cursor-default' : '',\n      className,\n    ]\"\n    @click=\"!disabled && $emit('click')\"\n  >\n    <!-- Header -->\n    <div class=\"absolute top-0 left-0 w-full p-2 flex justify-between items-start z-10\">\n      <div\n        class=\"w-6 h-6 rounded-full bg-purple-700/80 text-white font-bold text-[10px] flex items-center justify-center border border-purple-400/40 shadow-md\"\n        :class=\"!showManaBadge ? 'opacity-0' : ''\"\n      >\n        {{ card.manaCost }}\n      </div>\n      <div class=\"bg-black/60 p-1 rounded-full border border-white/10\">\n        <component :is=\"typeIcon\" class=\"size-5\" :class=\"typeIconColor\" />\n      </div>\n    </div>\n\n    <!-- Image Placeholder -->\n    <div\n      class=\"absolute top-8 left-2 right-2 h-24 bg-black/50 rounded-lg border border-white/5 flex items-center justify-center overflow-hidden\"\n    >\n      <div class=\"size-full opacity-60\" :class=\"typeGradient\"></div>\n      <span class=\"absolute font-heading text-white/20 text-4xl select-none\">\n        {{ displayInitial }}\n      </span>\n    </div>\n\n    <!-- Content -->\n    <div class=\"absolute bottom-0 left-0 w-full p-3 z-10 flex flex-col justify-end\">\n      <h3\n        class=\"text-dungeon-paper font-heading font-bold text-sm tracking-wide mb-1 text-center drop-shadow-md\"\n      >\n        {{ displayName }}\n      </h3>\n      <div\n        class=\"bg-[#0d0d10]/85 border border-white/10 p-2 rounded-lg text-[10px] text-gray-300 font-ui leading-tight min-h-[50px] flex items-center justify-center text-center\"\n      >\n        {{ displayDescription }}\n      </div>\n      <div class=\"mt-1 text-center text-white/50 font-bold text-[10px] font-ui tracking-wider\">\n        {{ displayTypeText }}\n      </div>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { CircleHelp, Footprints, RefreshCcw, Skull, Sparkles, Sword } from 'lucide-vue-next';\nimport { type CardData, CardType } from '../types';\n\nconst props = withDefaults(\n  defineProps<{\n    card: CardData;\n    disabled?: boolean;\n    selected?: boolean;\n    faceDown?: boolean;\n    isEnemy?: boolean;\n    className?: string;\n    maskLevel?: 'none' | 'partial' | 'full';\n  }>(),\n  {\n    disabled: false,\n    selected: false,\n    faceDown: false,\n    isEnemy: false,\n    className: '',\n    maskLevel: 'none',\n  },\n);\n\ndefineEmits<{\n  click: [];\n}>();\n\nconst typeColorClass = computed(() => {\n  if (props.maskLevel === 'full') {\n    return 'border-gray-600 bg-gray-900/40';\n  }\n  switch (props.card.type) {\n    case CardType.PHYSICAL:\n      return 'border-red-900 bg-red-950/30';\n    case CardType.MAGIC:\n      return 'border-purple-900 bg-purple-950/30';\n    case CardType.FUNCTION:\n      return 'border-yellow-800 bg-yellow-950/30';\n    case CardType.DODGE:\n      return 'border-emerald-900 bg-emerald-950/30';\n    case CardType.CURSE:\n      return 'border-black bg-black/70';\n    default:\n      return 'border-gray-700 bg-gray-800';\n  }\n});\n\nconst typeIcon = computed(() => {\n  if (props.maskLevel === 'full') {\n    return CircleHelp;\n  }\n  switch (props.card.type) {\n    case CardType.PHYSICAL:\n      return Sword;\n    case CardType.MAGIC:\n      return Sparkles;\n    case CardType.FUNCTION:\n      return RefreshCcw;\n    case CardType.DODGE:\n      return Footprints;\n    case CardType.CURSE:\n      return Skull;\n    default:\n      return Sword;\n  }\n});\n\nconst typeIconColor = computed(() => {\n  if (props.maskLevel === 'full') {\n    return 'text-gray-400';\n  }\n  switch (props.card.type) {\n    case CardType.PHYSICAL:\n      return 'text-red-400';\n    case CardType.MAGIC:\n      return 'text-purple-400';\n    case CardType.FUNCTION:\n      return 'text-yellow-400';\n    case CardType.DODGE:\n      return 'text-emerald-400';\n    case CardType.CURSE:\n      return 'text-zinc-300';\n    default:\n      return 'text-gray-400';\n  }\n});\n\nconst cardStrengthLabel = computed(() => {\n  const dl = props.card.damageLogic;\n  switch (dl.mode) {\n    case 'relative': return `倍率 ${dl.scale ?? 1}x`;\n    case 'fixed':    return dl.value ? `固伤 ${dl.value}` : '特殊';\n    case 'mixed':    return `${dl.baseValue ?? 0}+${dl.scale ?? 1}x`;\n    default:         return '特殊';\n  }\n});\n\nconst typeGradient = computed(() => {\n  if (props.maskLevel === 'full') {\n    return 'bg-gradient-to-tr from-gray-700 to-black';\n  }\n  switch (props.card.type) {\n    case CardType.PHYSICAL:\n      return 'bg-gradient-to-tr from-red-900 to-black';\n    case CardType.MAGIC:\n      return 'bg-gradient-to-tr from-purple-900 to-black';\n    case CardType.FUNCTION:\n      return 'bg-gradient-to-tr from-yellow-900 to-black';\n    case CardType.DODGE:\n      return 'bg-gradient-to-tr from-emerald-900 to-black';\n    case CardType.CURSE:\n      return 'bg-gradient-to-tr from-zinc-900 to-black';\n    default:\n      return 'bg-gradient-to-tr from-gray-800 to-black';\n  }\n});\n\nconst displayName = computed(() => (props.maskLevel === 'none' ? props.card.name : '???'));\nconst displayDescription = computed(() => (props.maskLevel === 'none' ? props.card.description : '???'));\nconst displayTypeText = computed(() => (props.maskLevel === 'full' ? '?' : props.card.type));\nconst displayInitial = computed(() => (displayName.value[0] ?? '?'));\nconst showManaBadge = computed(() => (\n  props.maskLevel !== 'full'\n  && props.card.type === CardType.MAGIC\n  && props.card.manaCost > 0\n));\nconst isRareCard = computed(() => props.card.rarity === '稀有');\n</script>\n\n<style scoped>\n.rare-card-glow {\n  position: relative;\n}\n\n.rare-card-glow::after {\n  content: '';\n  position: absolute;\n  inset: -1px;\n  border-radius: inherit;\n  border: 1px solid rgba(250, 204, 21, 0.48);\n  box-shadow:\n    0 0 8px rgba(250, 204, 21, 0.4),\n    0 0 16px rgba(245, 158, 11, 0.24);\n  pointer-events: none;\n}\n</style>\n","<template>\n  <div\n    ref=\"combatRootEl\"\n    class=\"combat-root w-full h-full bg-[#1a1a22] text-dungeon-paper font-ui relative overflow-hidden select-none\"\n    :class=\"[screenShake ? 'animate-shake' : '', impactShake ? 'animate-impact-shake' : '']\"\n    :style=\"combatRootStyle\"\n  >\n    <!-- Background -->\n    <div class=\"absolute inset-0 z-0\">\n      <!-- Dynamic background image -->\n      <img\n        v-if=\"bgImageUrl\"\n        :src=\"bgImageUrl\"\n        class=\"absolute inset-0 w-full h-full object-cover\"\n        alt=\"\"\n        @error=\"onBgError\"\n      />\n      <!-- Fallback gradient -->\n      <div class=\"absolute inset-0 bg-[radial-gradient(circle_at_50%_30%,_rgba(40,35,50,0.5),_#0e0e14_90%)]\"></div>\n      <!-- Darken overlay for readability -->\n      <div class=\"absolute inset-0 bg-black/40\"></div>\n    </div>\n    <div\n      class=\"absolute inset-0 opacity-20 z-0 mix-blend-overlay bg-[length:200px] bg-repeat\"\n      style=\"background-image: url('https://www.transparenttextures.com/patterns/dark-matter.png')\"\n    ></div>\n\n    <!-- Top Left: Settings -->\n    <div class=\"absolute top-4 left-4 z-50 pointer-events-auto flex flex-col gap-2 scale-[1.1] origin-top-left\">\n      <button\n        class=\"w-10 h-10 bg-[#252030]/90 border border-white/10 rounded-xl text-dungeon-gold flex items-center justify-center hover:bg-[#352a40] hover:border-white/20 active:scale-95 transition-all shadow-lg\"\n        @click=\"settingsOpen = !settingsOpen\"\n      >\n        <Settings2 class=\"size-5\" />\n        <span class=\"sr-only\">设置</span>\n      </button>\n      <button\n        class=\"w-10 h-10 bg-[#252030]/90 border border-white/10 rounded-xl text-dungeon-gold flex items-center justify-center hover:bg-[#352a40] hover:border-white/20 active:scale-95 transition-all shadow-lg\"\n        @click=\"emit('openDeck')\"\n      >\n        <Scroll class=\"size-5\" />\n        <span class=\"sr-only\">卡组</span>\n      </button>\n      <button\n        class=\"w-10 h-10 bg-[#252030]/90 border border-white/10 rounded-xl text-dungeon-gold flex items-center justify-center hover:bg-[#352a40] hover:border-white/20 active:scale-95 transition-all shadow-lg\"\n        @click=\"emit('openRelics')\"\n      >\n        <Box class=\"size-5\" />\n        <span class=\"sr-only\">物品</span>\n      </button>\n      <div\n        v-if=\"settingsOpen\"\n        class=\"mt-1 w-52 bg-[#1a1520]/95 border border-white/10 rounded-xl p-3 text-xs text-dungeon-paper shadow-xl backdrop-blur-md\"\n      >\n        <div class=\"flex flex-col gap-3\">\n          <label class=\"flex items-center gap-2 cursor-pointer select-none\">\n            <input v-model=\"battleSpeedUp\" type=\"checkbox\" class=\"accent-dungeon-gold\" />\n            <span>战斗加速（2x）</span>\n          </label>\n          <button\n            class=\"h-8 rounded-lg border border-white/20 bg-[#252030]/80 px-2 text-xs text-dungeon-gold hover:border-dungeon-gold/60 hover:bg-[#352a40] transition-colors\"\n            @click=\"toggleFullScreen\"\n          >\n            切换全屏\n          </button>\n        </div>\n      </div>\n    </div>\n\n    <!-- Top Center: Turn Counter -->\n    <div class=\"absolute top-4 left-1/2 -translate-x-1/2 z-40 pointer-events-none scale-[1.1] origin-top\">\n      <div class=\"flex flex-col items-center\">\n        <span class=\"text-xs text-white/60 tracking-widest\">回合</span>\n        <span class=\"text-lg font-heading font-bold text-white/90\">{{ combatState.turn }}</span>\n        <div\n          class=\"mt-1.5 w-44 relative pointer-events-auto\"\n          :style=\"fatigueBarStyle\"\n          @mouseenter=\"showFatigueHelp\"\n          @mouseleave=\"hideFatigueHelp\"\n        >\n          <div class=\"h-1.5 rounded-full border border-amber-400/35 bg-black/45 overflow-hidden\">\n            <div\n              class=\"h-full bg-gradient-to-r from-amber-400 via-orange-400 to-red-500 transition-all duration-500\"\n              :style=\"withTransition({ width: `${fatigueDegreePercent}%` }, 500)\"\n            ></div>\n          </div>\n          <div\n            v-if=\"fatigueHelpVisible && fatigueDegree > 50\"\n            class=\"absolute left-1/2 top-full mt-1.5 -translate-x-1/2 w-64 rounded-md border border-amber-300/35 bg-black/80 px-2 py-1 text-[10px] leading-relaxed text-amber-100 text-left shadow-lg\"\n          >\n            当前疲劳度：{{ fatigueDegree }}/300。进入战斗 +10，出牌 +1。达到200后每回合附加疲劳并额外附加中毒，300时直接战败。\n          </div>\n        </div>\n        <div\n          v-if=\"dicePreviewPanels.length > 0\"\n          class=\"mt-2 w-80 space-y-1\"\n        >\n          <div\n            v-for=\"panel in dicePreviewPanels\"\n            :key=\"panel.key\"\n            class=\"px-1 text-left\"\n          >\n            <div class=\"text-sm text-white/80 [text-shadow:0_1px_2px_rgba(0,0,0,0.9)]\">\n              {{ panel.title }}\n            </div>\n            <div class=\"mt-0.5 space-y-0.5\">\n              <div\n                v-for=\"(line, idx) in panel.lines\"\n                :key=\"`${panel.key}-line-${idx}`\"\n                class=\"text-sm leading-relaxed text-white/90 [text-shadow:0_1px_2px_rgba(0,0,0,0.9)]\"\n              >\n                {{ line }}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Battlefield Layer -->\n    <div class=\"absolute inset-0 z-10 pointer-events-none\">\n      <!-- Enemy Position: Top Right -->\n      <div class=\"absolute top-[3%] right-[2%] md:top-[5%] md:right-[3%] w-96 h-[32rem] flex flex-col items-center justify-end group transition-transform duration-1000 scale-[1.1] origin-top-right\">\n        <!-- Enemy Intent Card -->\n        <div\n          v-if=\"showEnemyIntentCard && combatState.enemyIntentCard\"\n          class=\"absolute -left-48 top-8\"\n        >\n          <div class=\"relative\">\n            <div class=\"absolute -top-5 left-0 text-amber-200/80 text-[10px] px-2 py-0.5 rounded\">\n              敌方意图\n            </div>\n            <div class=\"rotate-[-3deg] shadow-[0_0_20px_rgba(200,120,0,0.15)]\">\n              <DungeonCard\n                :card=\"combatState.enemyIntentCard!\"\n                :mask-level=\"enemyIntentMaskLevel\"\n                is-enemy\n                disabled\n              />\n            </div>\n          </div>\n        </div>\n\n        <!-- Enemy Dice -->\n        <div\n          v-if=\"!showClashAnimation\"\n          class=\"absolute -left-24 bottom-20 z-20 animate-float pointer-events-auto\"\n          @mouseenter=\"handleEnemyDiceHoverStart\"\n          @mouseleave=\"handleEnemyDiceHoverEnd\"\n          @touchstart.passive=\"handleEnemyDiceTouchStart\"\n          @touchend=\"handleEnemyDiceTouchEnd\"\n          @touchcancel=\"handleEnemyDiceTouchEnd\"\n        >\n          <DungeonDice\n            :value=\"displayEnemyDice\"\n            :rolling=\"isRolling\"\n            :rolling-min=\"enemyStats.minDice\"\n            :rolling-max=\"enemyStats.maxDice\"\n            :number-class=\"enemyDiceNumberClass\"\n            color=\"red\"\n            size=\"md\"\n          />\n        </div>\n\n        <!-- Enemy Portrait -->\n        <div class=\"relative w-full h-full\">\n          <div\n            class=\"absolute bottom-0 left-1/2 -translate-x-1/2 scale-[1.2] origin-bottom w-64 h-80 flex items-end justify-center overflow-hidden\"\n          >\n            <!-- Placeholder icon (shown when portrait fails to load) -->\n            <Skull v-if=\"enemyPortraitError\" class=\"w-48 h-48 text-red-900/20 absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2\" />\n            <!-- Enemy portrait image -->\n            <img\n              v-else\n              :src=\"enemyPortraitUrl\"\n              class=\"w-full h-full object-contain object-bottom\"\n              alt=\"enemy portrait\"\n              @error=\"enemyPortraitError = true\"\n            />\n          </div>\n        </div>\n\n        <!-- Enemy Status Bar -->\n        <div class=\"relative overflow-visible mt-0 w-72 scale-[1.2] origin-top bg-[#18141e]/90 border border-white/8 p-3 rounded-xl shadow-lg backdrop-blur-sm z-10 pointer-events-auto\">\n          <div class=\"flex justify-between text-sm text-white/90 font-bold mb-1.5\">\n            <span>{{ enemyDisplayName }}</span>\n          </div>\n          <div class=\"pointer-events-none absolute inset-0 z-30 overflow-visible\">\n            <div\n              v-for=\"popup in floatingNumbersFor('enemy')\"\n              :key=\"popup.id\"\n              class=\"combat-float-number absolute text-xl font-extrabold tracking-wide\"\n              :class=\"[popup.colorClass, popup.kind === 'heal' ? 'combat-float-number--heal' : '']\"\n              :style=\"{\n                left: `calc(50% + ${popup.leftOffset}px)`,\n                top: `${popup.topOffset}px`,\n                animationDuration: `${popup.duration}ms`,\n              }\"\n            >\n              {{ popup.text }}\n            </div>\n          </div>\n          <!-- Armor Shield -->\n          <div v-if=\"enemyArmor > 0 || enemyPoisonAmount > 0 || enemyTempMaxHp > 0\" class=\"flex items-center gap-3 mb-1\">\n            <button\n              v-if=\"enemyArmor > 0\"\n              type=\"button\"\n              class=\"status-effect-value-btn flex items-center gap-1\"\n              :aria-label=\"`护甲: ${enemyArmor}. ${getEffectDescription(ET.ARMOR)}`\"\n              @mouseenter=\"showEffectTooltip($event, createStatusEffectPreview(ET.ARMOR, enemyArmor))\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, createStatusEffectPreview(ET.ARMOR, enemyArmor))\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, createStatusEffectPreview(ET.ARMOR, enemyArmor))\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <span class=\"text-[10px] text-yellow-400\">🛡️</span>\n              <span class=\"text-[10px] text-yellow-300 font-bold\">{{ enemyArmor }}</span>\n            </button>\n            <button\n              v-if=\"enemyPoisonAmount > 0\"\n              type=\"button\"\n              class=\"status-effect-value-btn flex items-center gap-1\"\n              :aria-label=\"`中毒量: ${enemyPoisonAmount}. ${getEffectDescription(ET.POISON_AMOUNT)}`\"\n              @mouseenter=\"showEffectTooltip($event, createStatusEffectPreview(ET.POISON_AMOUNT, enemyPoisonAmount))\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, createStatusEffectPreview(ET.POISON_AMOUNT, enemyPoisonAmount))\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, createStatusEffectPreview(ET.POISON_AMOUNT, enemyPoisonAmount))\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <span class=\"text-[10px] text-green-400\">☠</span>\n              <span class=\"text-[10px] text-green-300 font-bold\">{{ enemyPoisonAmount }}</span>\n            </button>\n            <button\n              v-if=\"enemyTempMaxHp > 0\"\n              type=\"button\"\n              class=\"status-effect-value-btn flex items-center gap-1\"\n              :aria-label=\"`临时生命上限: ${enemyTempMaxHp}. ${getEffectDescription(ET.TEMP_MAX_HP)}`\"\n              @mouseenter=\"showEffectTooltip($event, createStatusEffectPreview(ET.TEMP_MAX_HP, enemyTempMaxHp))\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, createStatusEffectPreview(ET.TEMP_MAX_HP, enemyTempMaxHp))\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, createStatusEffectPreview(ET.TEMP_MAX_HP, enemyTempMaxHp))\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <span class=\"text-[10px] text-rose-400\">♥</span>\n              <span class=\"text-[10px] text-rose-300 font-bold\">{{ enemyTempMaxHp }}</span>\n            </button>\n          </div>\n          <!-- HP Bar -->\n          <div class=\"flex items-center gap-2 mb-1.5\">\n            <span class=\"text-[10px] text-[#ff6666] font-bold w-6\">HP</span>\n            <div class=\"relative flex-1 h-2.5 bg-[#1a0a0a] rounded-full overflow-hidden border border-red-900/20\">\n              <div\n                class=\"absolute inset-y-0 left-0 z-10 bg-gradient-to-r from-[#cc2200] to-[#ee3311] rounded-full transition-all duration-500\"\n                :style=\"withTransition({ width: `${enemyStats.maxHp > 0 ? (enemyStats.hp / enemyStats.maxHp) * 100 : 0}%` }, 500)\"\n              ></div>\n              <div\n                class=\"absolute inset-y-0 left-0 z-20 bg-green-600/75 rounded-full transition-all duration-500 poison-wave-bar\"\n                :style=\"withTransition({ width: `${enemyPoisonAmountPercent}%` }, 500)\"\n              ></div>\n            </div>\n            <span class=\"text-[10px] text-white/70 w-14 text-right\">{{ enemyStats.hp }}/{{ enemyStats.maxHp }}</span>\n          </div>\n          <!-- MP Bar -->\n          <div class=\"flex items-center gap-2 mb-1.5\">\n            <span class=\"text-[10px] text-[#55aaff] font-bold w-6\">MP</span>\n            <div class=\"flex-1 h-2 bg-[#0a0a1a] rounded-full overflow-hidden border border-blue-900/20\">\n              <div\n                class=\"h-full bg-gradient-to-r from-[#0066cc] to-[#0088ee] rounded-full transition-all duration-500\"\n                :style=\"withTransition({ width: `${Math.min((enemyStats.mp / 20) * 100, 100)}%` }, 500)\"\n              ></div>\n            </div>\n            <span class=\"text-[10px] text-white/60 w-14 text-right\">{{ enemyStats.mp }}</span>\n          </div>\n          <!-- Dice Range -->\n          <div class=\"flex items-center gap-2 mb-1\">\n            <span class=\"text-[10px] text-gray-400 font-bold w-6\">🎲</span>\n            <span class=\"text-[10px] text-red-300\">{{ enemyStats.minDice }} ~ {{ enemyStats.maxDice }}</span>\n          </div>\n          <!-- Buffs/Debuffs -->\n          <div v-if=\"enemyVisibleEffects.length > 0\" class=\"flex flex-wrap gap-1.5 mt-1.5 pointer-events-auto\">\n            <button\n              v-for=\"(eff, i) in enemyVisibleEffects\"\n              :key=\"`enemy-${eff.type}-${i}`\"\n              type=\"button\"\n              class=\"effect-icon-btn\"\n              :class=\"effectIconBoxClass(eff.polarity)\"\n              :aria-label=\"`${getEffectName(eff.type)}: ${getEffectDescription(eff.type)}`\"\n              @mouseenter=\"showEffectTooltip($event, eff)\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, eff)\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, eff)\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <i\n                v-if=\"getEffectFontAwesomeClass(eff.type)\"\n                :class=\"[getEffectFontAwesomeClass(eff.type), 'text-[14px] leading-none']\"\n                :style=\"getEffectFontAwesomeStyle(eff.type)\"\n                aria-hidden=\"true\"\n              ></i>\n              <component\n                :is=\"getEffectIconComponent(eff.type)\"\n                v-else\n                class=\"size-3.5\"\n              />\n              <span v-if=\"eff.stacks > 1\" class=\"effect-stack-badge\">{{ eff.stacks }}</span>\n            </button>\n          </div>\n        </div>\n      </div>\n\n      <!-- Player Position: Bottom Left -->\n      <div class=\"absolute bottom-[18%] left-[3%] md:bottom-[22%] md:left-[6%] w-64 h-80 flex flex-col items-center justify-end z-20 translate-y-28 md:translate-y-32 scale-[1.1] origin-bottom-left\">\n        <!-- Player Dice -->\n        <div\n          v-if=\"!showClashAnimation\"\n          class=\"absolute -top-[1rem] left-[140%] -translate-x-1/2 z-20 animate-float pointer-events-auto\"\n          :class=\"canPlayerRerollDice ? 'cursor-pointer' : 'cursor-default'\"\n          :title=\"playerDiceRerollHint\"\n          style=\"animation-delay: 1s\"\n          @click=\"handlePlayerDiceClick\"\n        >\n          <DungeonDice\n            :value=\"displayPlayerDice\"\n            :rolling=\"isRolling\"\n            :rolling-min=\"playerStats.minDice\"\n            :rolling-max=\"playerStats.maxDice\"\n            :number-class=\"playerDiceNumberClass\"\n            color=\"gold\"\n            size=\"md\"\n          />\n          <div\n            v-if=\"playerDiceRerollCharges > 0\"\n            class=\"absolute left-1/2 top-[5.9rem] -translate-x-1/2 rounded-md border border-amber-300/35 bg-black/60 px-2 py-1 text-[10px] whitespace-nowrap\"\n            :class=\"canPlayerRerollDice ? 'text-amber-200' : 'text-amber-200/70'\"\n          >\n            重掷次数：{{ playerDiceRerollCharges }}\n          </div>\n        </div>\n\n        <!-- Player Portrait -->\n        <div class=\"relative w-full h-full\">\n          <div\n            class=\"absolute bottom-4 left-1/2 -translate-x-1/2 scale-[1.2] origin-bottom w-64 h-80 flex items-end justify-center overflow-hidden\"\n          >\n            <!-- Placeholder glow (shown when portrait fails to load) -->\n            <div v-if=\"playerPortraitError\" class=\"size-20 bg-dungeon-gold/15 blur-2xl rounded-full absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2\"></div>\n            <!-- Player portrait image -->\n            <img\n              v-else\n              :src=\"playerPortraitUrl\"\n              class=\"w-full h-full object-contain object-bottom\"\n              alt=\"player portrait\"\n              @error=\"playerPortraitError = true\"\n            />\n          </div>\n        </div>\n\n        <!-- Player Status Bar -->\n        <div class=\"relative overflow-visible mt-2 w-60 scale-[1.2] origin-bottom bg-[#18141e]/90 border border-white/8 p-2.5 rounded-xl shadow-xl backdrop-blur-sm z-10 pointer-events-auto\">\n          <div class=\"flex justify-between text-xs text-white/80 font-bold mb-1.5\">\n              <span>冒险者</span>\n          </div>\n          <div class=\"pointer-events-none absolute inset-0 z-30 overflow-visible\">\n            <div\n              v-for=\"popup in floatingNumbersFor('player')\"\n              :key=\"popup.id\"\n              class=\"combat-float-number absolute text-xl font-extrabold tracking-wide\"\n              :class=\"[popup.colorClass, popup.kind === 'heal' ? 'combat-float-number--heal' : '']\"\n              :style=\"{\n                left: `calc(50% + ${popup.leftOffset}px)`,\n                top: `${popup.topOffset}px`,\n                animationDuration: `${popup.duration}ms`,\n              }\"\n            >\n              {{ popup.text }}\n            </div>\n          </div>\n          <!-- Armor Shield -->\n          <div v-if=\"playerArmor > 0 || playerPoisonAmount > 0 || playerTempMaxHp > 0\" class=\"flex items-center gap-3 mb-1\">\n            <button\n              v-if=\"playerArmor > 0\"\n              type=\"button\"\n              class=\"status-effect-value-btn flex items-center gap-1\"\n              :aria-label=\"`护甲: ${playerArmor}. ${getEffectDescription(ET.ARMOR)}`\"\n              @mouseenter=\"showEffectTooltip($event, createStatusEffectPreview(ET.ARMOR, playerArmor), 'right')\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, createStatusEffectPreview(ET.ARMOR, playerArmor), 'right')\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, createStatusEffectPreview(ET.ARMOR, playerArmor), 'right')\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <span class=\"text-[10px] text-yellow-400\">🛡️</span>\n              <span class=\"text-[10px] text-yellow-300 font-bold\">{{ playerArmor }}</span>\n            </button>\n            <button\n              v-if=\"playerPoisonAmount > 0\"\n              type=\"button\"\n              class=\"status-effect-value-btn flex items-center gap-1\"\n              :aria-label=\"`中毒量: ${playerPoisonAmount}. ${getEffectDescription(ET.POISON_AMOUNT)}`\"\n              @mouseenter=\"showEffectTooltip($event, createStatusEffectPreview(ET.POISON_AMOUNT, playerPoisonAmount), 'right')\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, createStatusEffectPreview(ET.POISON_AMOUNT, playerPoisonAmount), 'right')\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, createStatusEffectPreview(ET.POISON_AMOUNT, playerPoisonAmount), 'right')\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <span class=\"text-[10px] text-green-400\">☠</span>\n              <span class=\"text-[10px] text-green-300 font-bold\">{{ playerPoisonAmount }}</span>\n            </button>\n            <button\n              v-if=\"playerTempMaxHp > 0\"\n              type=\"button\"\n              class=\"status-effect-value-btn flex items-center gap-1\"\n              :aria-label=\"`临时生命上限: ${playerTempMaxHp}. ${getEffectDescription(ET.TEMP_MAX_HP)}`\"\n              @mouseenter=\"showEffectTooltip($event, createStatusEffectPreview(ET.TEMP_MAX_HP, playerTempMaxHp), 'right')\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, createStatusEffectPreview(ET.TEMP_MAX_HP, playerTempMaxHp), 'right')\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, createStatusEffectPreview(ET.TEMP_MAX_HP, playerTempMaxHp), 'right')\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <span class=\"text-[10px] text-rose-400\">♥</span>\n              <span class=\"text-[10px] text-rose-300 font-bold\">{{ playerTempMaxHp }}</span>\n            </button>\n          </div>\n          <!-- HP Bar -->\n          <div class=\"flex items-center gap-2 mb-1.5\">\n            <span class=\"text-[10px] text-[#ff6666] font-bold w-6\">HP</span>\n            <div class=\"relative flex-1 h-2.5 bg-[#1a0a0a] rounded-full overflow-hidden border border-red-900/20\">\n              <div\n                class=\"absolute inset-y-0 left-0 z-10 bg-gradient-to-r from-[#cc2200] to-[#ee3311] rounded-full transition-all duration-500\"\n                :style=\"withTransition({ width: `${playerStats.maxHp > 0 ? (playerStats.hp / playerStats.maxHp) * 100 : 0}%` }, 500)\"\n              ></div>\n              <div\n                class=\"absolute inset-y-0 left-0 z-20 bg-green-600/75 rounded-full transition-all duration-500 poison-wave-bar\"\n                :style=\"withTransition({ width: `${playerPoisonAmountPercent}%` }, 500)\"\n              ></div>\n            </div>\n            <span class=\"text-[10px] text-white/70 w-14 text-right\">{{ playerStats.hp }}/{{ playerStats.maxHp }}</span>\n          </div>\n          <!-- MP Bar -->\n          <div class=\"flex items-center gap-2 mb-1.5\">\n            <span class=\"text-[10px] text-[#55aaff] font-bold w-6\">MP</span>\n            <div class=\"flex-1 h-2 bg-[#0a0a1a] rounded-full overflow-hidden border border-blue-900/20\">\n              <div\n                class=\"h-full bg-gradient-to-r from-[#0066cc] to-[#0088ee] rounded-full transition-all duration-500\"\n                :style=\"withTransition({ width: `${Math.min((playerStats.mp / 20) * 100, 100)}%` }, 500)\"\n              ></div>\n            </div>\n            <span class=\"text-[10px] text-white/60 w-14 text-right\">{{ playerStats.mp }}</span>\n          </div>\n          <!-- Dice Range -->\n          <div class=\"flex items-center gap-2 mb-1\">\n            <span class=\"text-[10px] text-gray-400 font-bold w-6\">🎲</span>\n            <span class=\"text-[10px] text-dungeon-gold\">{{ playerStats.minDice }} ~ {{ playerStats.maxDice }}</span>\n          </div>\n          <!-- Buffs/Debuffs -->\n          <div v-if=\"playerVisibleEffects.length > 0\" class=\"flex flex-wrap gap-1.5 mt-1.5 pointer-events-auto\">\n            <button\n              v-for=\"(eff, i) in playerVisibleEffects\"\n              :key=\"`player-${eff.type}-${i}`\"\n              type=\"button\"\n              class=\"effect-icon-btn\"\n              :class=\"effectIconBoxClass(eff.polarity)\"\n              :aria-label=\"`${getEffectName(eff.type)}: ${getEffectDescription(eff.type)}`\"\n              @mouseenter=\"showEffectTooltip($event, eff, 'right')\"\n              @mouseleave=\"hideEffectTooltip\"\n              @focus=\"showEffectTooltip($event, eff, 'right')\"\n              @blur=\"hideEffectTooltip\"\n              @touchstart.passive=\"handleEffectTouchStart($event, eff, 'right')\"\n              @touchend=\"handleEffectTouchEnd\"\n              @touchcancel=\"handleEffectTouchEnd\"\n            >\n              <i\n                v-if=\"getEffectFontAwesomeClass(eff.type)\"\n                :class=\"[getEffectFontAwesomeClass(eff.type), 'text-[14px] leading-none']\"\n                :style=\"getEffectFontAwesomeStyle(eff.type)\"\n                aria-hidden=\"true\"\n              ></i>\n              <component\n                :is=\"getEffectIconComponent(eff.type)\"\n                v-else\n                class=\"size-3.5\"\n              />\n              <span v-if=\"eff.stacks > 1\" class=\"effect-stack-badge\">{{ eff.stacks }}</span>\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Card Animation Layer -->\n    <div class=\"absolute inset-0 z-[45] pointer-events-none overflow-hidden\">\n      <div\n        v-if=\"playerPlayedCardVisual\"\n        class=\"absolute player-played-card\"\n        :style=\"playerPlayedCardStyle\"\n      >\n        <div :class=\"playerPlayedCardVisual.entered ? 'player-played-card-bob' : ''\">\n          <DungeonCard :card=\"playerPlayedCardVisual.card\" disabled />\n        </div>\n      </div>\n\n      <div\n        v-for=\"visual in resolvedCardVisualEntries\"\n        :key=\"visual.id\"\n        class=\"resolved-card-visual\"\n        :class=\"visual.source === 'player' ? 'resolved-card-visual--player' : 'resolved-card-visual--enemy'\"\n      >\n        <div class=\"resolved-card-visual-inner\" :class=\"resolvedCardVisualInnerClass(visual)\">\n          <DungeonCard :card=\"visual.card\" disabled />\n        </div>\n      </div>\n    </div>\n\n    <!-- UI Layer (HUD) -->\n    <div class=\"absolute inset-0 z-30 flex flex-col pointer-events-none\">\n      <!-- Center: Clash Zone -->\n      <div class=\"flex-1 flex items-center justify-center relative\">\n        <!-- Clash Animation Stage -->\n        <div v-if=\"showClashAnimation\" class=\"relative w-full h-64 flex items-center justify-center z-50\">\n          <!-- Player Dice Flying In -->\n          <div\n            class=\"absolute right-1/2 mr-[-0.5rem] transition-all duration-300\"\n            :class=\"shatteringTarget === 'player' || shatteringTarget === 'both' ? 'animate-shatter' : 'animate-clash-left'\"\n            :style=\"transitionStyle(300)\"\n          >\n            <DungeonDice\n              :value=\"displayPlayerDice\"\n              :rolling=\"false\"\n              :rolling-min=\"playerStats.minDice\"\n              :rolling-max=\"playerStats.maxDice\"\n              color=\"gold\"\n              size=\"lg\"\n            />\n          </div>\n\n          <!-- Enemy Dice Flying In -->\n          <div\n            class=\"absolute left-1/2 ml-[-0.5rem] transition-all duration-300\"\n            :class=\"shatteringTarget === 'enemy' || shatteringTarget === 'both' ? 'animate-shatter' : 'animate-clash-right'\"\n            :style=\"transitionStyle(300)\"\n          >\n            <DungeonDice\n              :value=\"displayEnemyDice\"\n              :rolling=\"false\"\n              :rolling-min=\"enemyStats.minDice\"\n              :rolling-max=\"enemyStats.maxDice\"\n              color=\"red\"\n              size=\"lg\"\n            />\n          </div>\n        </div>\n\n      </div>\n\n      <!-- Bottom Bar: Hand & Piles -->\n      <div\n        class=\"pointer-events-none min-h-[200px] w-full flex items-end justify-center pb-6 px-4 space-x-4 relative\"\n      >\n        <!-- Center: Hand Cards -->\n        <div class=\"flex space-x-4 items-end mb-2 z-40 scale-[1.1] origin-bottom pointer-events-auto\">\n          <div\n            v-for=\"(card, idx) in combatState.playerHand\"\n            :key=\"handCardKey(card)\"\n            class=\"transition-all duration-500 origin-bottom\"\n            :class=\"[handCardClass(card), isCardShaking(card) ? 'invalid-card-shake' : '']\"\n            :style=\"transitionStyle(500)\"\n            @mouseenter=\"handlePlayerCardHoverStart(card)\"\n            @mouseleave=\"handlePlayerCardHoverEnd\"\n            @touchstart.passive=\"handlePlayerCardTouchStart(card)\"\n            @touchend=\"handlePlayerCardTouchEnd\"\n            @touchcancel=\"handlePlayerCardTouchEnd\"\n          >\n            <DungeonCard\n              :card=\"getDisplayHandCard(card)\"\n              :mask-level=\"playerHandMaskLevel\"\n              :disabled=\"combatState.phase !== CombatPhase.PLAYER_INPUT && combatState.playerSelectedCard !== card\"\n              @click=\"handleCardSelect(card, idx)\"\n            />\n          </div>\n        </div>\n\n        <!-- Right Corner: Skip + Deck/Discard -->\n        <div class=\"absolute right-6 bottom-6 flex flex-col items-end gap-2.5 z-50 scale-[1.1] origin-bottom-right pointer-events-auto\">\n          <button\n            class=\"h-8 px-5 bg-[#252030]/90 border border-white/15 rounded-lg text-xs text-white/80 hover:border-amber-400 hover:text-amber-200 active:scale-95 transition-all disabled:opacity-40 disabled:cursor-not-allowed\"\n            :disabled=\"combatState.phase !== CombatPhase.PLAYER_INPUT\"\n            @click=\"handleSkipTurn\"\n          >\n            跳过回合\n          </button>\n\n          <div class=\"flex space-x-3\">\n            <div class=\"relative group\">\n              <button\n                class=\"w-14 h-14 bg-[#252030]/90 border border-white/10 rounded-xl flex flex-col items-center justify-center hover:border-dungeon-gold active:scale-95 transition-all shadow-lg\"\n                @click=\"overlayOpen = 'deck'\"\n              >\n                <Layers class=\"size-5 text-dungeon-gold\" />\n                <span class=\"text-[9px] text-white/40 mt-0.5\">{{ combatState.playerDeck.length }}</span>\n              </button>\n              <div\n                class=\"absolute -top-8 left-1/2 -translate-x-1/2 bg-black px-2 py-1 rounded text-[10px] whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none\"\n              >\n                牌库\n              </div>\n            </div>\n\n            <div class=\"relative group\">\n              <button\n                class=\"w-14 h-14 bg-[#252030]/90 border border-white/10 rounded-xl flex flex-col items-center justify-center hover:border-gray-400 active:scale-95 transition-all shadow-lg\"\n                @click=\"overlayOpen = 'discard'\"\n              >\n                <Trash2 class=\"size-5 text-gray-400\" />\n                <span class=\"text-[9px] text-white/40 mt-0.5\">{{ combatState.discardPile.length }}</span>\n              </button>\n              <div\n                class=\"absolute -top-8 left-1/2 -translate-x-1/2 bg-black px-2 py-1 rounded text-[10px] whitespace-nowrap opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none\"\n              >\n                弃牌堆\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n\n      <!-- Log Feed Overlay: top-right, below parent \"退出战斗\" button -->\n      <div class=\"absolute right-0 top-14 z-40 pointer-events-auto select-none scale-[1.1] origin-top-right\">\n        <div class=\"flex items-start\">\n          <button\n            class=\"h-7 px-2 rounded-l-lg border border-r-0 border-white/10 bg-[#18141e]/90 text-[10px] text-white/50 hover:text-white/80 transition-colors\"\n            :title=\"logsCollapsed ? '展开日志' : '折叠日志'\"\n            @click=\"logsCollapsed = !logsCollapsed\"\n          >\n            {{ logsCollapsed ? '日志 ▼' : '日志 ▲' }}\n          </button>\n          <div\n            v-if=\"!logsCollapsed\"\n            class=\"w-80 max-h-44 overflow-y-auto space-y-1 border border-r-0 border-white/10 bg-[#18141e]/90 backdrop-blur-sm p-1 text-[10px] font-mono text-gray-300\"\n          >\n            <!-- eslint-disable-next-line vue/no-v-html -->\n            <div\n              v-for=\"(l, i) in combatState.logs\"\n              :key=\"i\"\n              class=\"bg-black/60 p-1 rounded border-l-2 border-gray-700\"\n              v-html=\"l\"\n            ></div>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div\n      v-if=\"battleResultBanner\"\n      class=\"absolute inset-0 z-[70] flex items-center justify-center pointer-events-none\"\n    >\n      <div\n        class=\"px-12 py-5 rounded-2xl border-2 text-5xl md:text-6xl font-heading tracking-[0.2em] drop-shadow-[0_0_30px_rgba(0,0,0,0.9)] animate-pulse backdrop-blur-md\"\n        :class=\"battleResultBanner === 'win'\n          ? 'bg-emerald-950/70 border-emerald-400/60 text-emerald-300'\n          : 'bg-red-950/70 border-red-500/60 text-red-300'\"\n      >\n        {{ battleResultBanner === 'win' ? '胜利' : '败北' }}\n      </div>\n    </div>\n    <div\n      v-if=\"effectTooltip\"\n      class=\"effect-tooltip absolute z-[72] pointer-events-none\"\n      :class=\"effectTooltip.align === 'right' ? 'effect-tooltip--right text-right' : 'effect-tooltip--center'\"\n      :style=\"{ left: `${effectTooltip.x}px`, top: `${effectTooltip.y}px` }\"\n    >\n      <div class=\"effect-tooltip-name\">{{ effectTooltip.name }}</div>\n      <div class=\"effect-tooltip-desc\">{{ effectTooltip.description }}</div>\n      <div v-if=\"effectTooltip.stacks > 1\" class=\"effect-tooltip-stacks\">层数: {{ effectTooltip.stacks }}</div>\n    </div>\n\n    <!-- Deck/Discard Overlay -->\n    <div\n      v-if=\"overlayOpen\"\n      class=\"absolute inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center p-8\"\n      @click=\"overlayOpen = null\"\n    >\n      <div\n        class=\"bg-[#18141e] border border-white/10 p-6 rounded-2xl max-w-2xl w-full max-h-[80%] flex flex-col relative shadow-2xl\"\n        @click.stop\n      >\n        <div class=\"flex justify-between items-center mb-4 border-b border-dungeon-brown pb-2\">\n          <h3 class=\"font-heading text-xl text-dungeon-gold\">\n            {{ overlayOpen === 'deck' ? '当前牌库' : '弃牌堆' }}\n          </h3>\n          <button @click=\"overlayOpen = null\">\n            <XIcon class=\"size-6 hover:text-red-500\" />\n          </button>\n        </div>\n        <div class=\"overflow-y-auto grid grid-cols-4 gap-4 p-2\">\n          <div\n            v-for=\"(card, i) in overlayOpen === 'deck' ? combatState.playerDeck : combatState.discardPile\"\n            :key=\"i\"\n            class=\"scale-75 origin-top-left\"\n          >\n            <DungeonCard :card=\"card\" disabled />\n          </div>\n        </div>\n      </div>\n    </div>\n\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  Ban,\n  Battery,\n  Bone,\n  Box,\n  Brain,\n  Bug,\n  Droplet,\n  Eye,\n  EyeOff,\n  Flame,\n  Heart,\n  Layers,\n  Leaf,\n  Link2,\n  Scroll,\n  Settings2,\n  Shield,\n  ShieldCheck,\n  Skull,\n  Snowflake,\n  Sparkles,\n  Sword,\n  Trash2,\n  TriangleAlert,\n  Waves,\n  X as XIcon,\n  Zap,\n} from 'lucide-vue-next';\nimport { applyDamageToEntity, calculateFinalDamage, calculateFinalPoint, consumeColdAfterDealingDamage, triggerSwarmReviveIfNeeded } from '../battle/algorithms';\nimport { getCardByName } from '../battle/cardRegistry';\nimport { EFFECT_REGISTRY, ELEMENTAL_DEBUFF_TYPES, applyEffect, canPlayCard, getEffectStacks, processOnTurnEnd, processOnTurnStart, reduceEffectStacks, removeEffect } from '../battle/effects';\nimport { getEnemyByName } from '../battle/enemyRegistry';\nimport {\n  resolveRelicMap,\n  type RelicAfterBurnDamageTakenHookContext,\n  type RelicApplyEffectOptions,\n  type RelicBeforeApplyEffectHookContext,\n  type RelicBurnDamageHookContext,\n  type RelicData,\n  type RelicDiceClickHookContext,\n  type RelicHitHookContext,\n  type RelicLifecycleHookContext,\n  type RelicPointHookContext,\n  type RelicSide,\n  type ResolvedRelicEntry,\n} from '../battle/relicRegistry';\nimport { getFloorNumberForArea } from '../floor';\nimport { toggleFullScreen } from '../fullscreen';\nimport { useGameStore } from '../gameStore';\nimport { CardType, CombatPhase, EffectType as ET, type CardData, type CardEffectTrigger, type CardSelfDamageConfig, type CombatState, type EffectInstance, type EffectPolarity, type EffectType, type EnemyAIContext, type EntityStats } from '../types';\nimport { recordEncounteredCards, recordEncounteredEffects, recordEncounteredEnemy } from '../codexStore';\nimport DungeonCard from './DungeonCard.vue';\nimport DungeonDice from './DungeonDice.vue';\n\nconst props = withDefaults(defineProps<{\n  initialPlayerStats: EntityStats;\n  enemyName: string;\n  playerDeck: CardData[];\n  playerRelics?: Record<string, number>;\n  testStartAt999?: boolean;\n  uiFontFamily?: string;\n  trackDiscovery?: boolean;\n}>(), {\n  playerRelics: () => ({}),\n  testStartAt999: false,\n  uiFontFamily: '',\n  trackDiscovery: true,\n});\n\nconst emit = defineEmits<{\n  endCombat: [win: boolean, finalStats: EntityStats, logs: string[], negativeEffects: string[]];\n  openDeck: [];\n  openRelics: [];\n}>();\n\nconst gameStore = useGameStore();\nconst resolveCurrentFloorNumber = () => {\n  const area = (gameStore.statData._当前区域 as string) || '';\n  const floorFromArea = getFloorNumberForArea(area);\n  const fallback = Math.max(1, Math.floor(Number(gameStore.statData._楼层数 ?? 1)));\n  const floor = area ? floorFromArea : fallback;\n  gameStore.statData._楼层数 = floor;\n  return floor;\n};\nconst currentFloorNumber = resolveCurrentFloorNumber();\n\n// --- Enemy Loading ---\nconst enemyDef = getEnemyByName(props.enemyName, currentFloorNumber);\nconst enemyDisplayName = enemyDef?.name ?? props.enemyName;\n\n// --- Portrait URLs ---\nconst HF_DATASET_REPO = 'Vin05/AI-Gallery';\nconst HF_RESOLVE_ROOT = `https://huggingface.co/datasets/${HF_DATASET_REPO}/resolve/main`;\nconst HF_TREE_API_ROOT = `https://huggingface.co/api/datasets/${HF_DATASET_REPO}/tree/main`;\nconst HF_USER_DIR = '地牢/user';\nconst HF_MONSTER_DIR = '地牢/魔物';\nconst IMAGE_EXT_RE = /\\.(png|jpe?g|webp|gif|avif|bmp|svg)$/i;\nconst BOSS_FOLDER_NAMES = new Set([\n  '普莉姆', '宁芙', '温蒂尼', '玛塔', '罗丝', '厄休拉',\n  '希尔薇', '因克', '阿卡夏', '多萝西', '维罗妮卡',\n  '伊丽莎白', '尤斯蒂娅', '克拉肯', '布偶',\n  '赛琳娜', '米拉', '梦魔双子', '贝希摩斯',\n  '佩恩', '西格尔', '摩尔', '利维坦', '奥赛罗', '盖亚',\n]);\n\ntype HfTreeEntry = {\n  type?: string;\n  path?: string;\n};\n\nconst folderImageCache = new Map<string, string[]>();\nconst folderImagePromiseCache = new Map<string, Promise<string[]>>();\n\nconst normalizeRepoPath = (path: string) => path.replace(/\\\\/g, '/').replace(/^\\/+|\\/+$/g, '');\nconst encodeRepoPath = (path: string) => normalizeRepoPath(path).split('/').map((seg) => encodeURIComponent(seg)).join('/');\nconst toResolveUrl = (repoPath: string) => `${HF_RESOLVE_ROOT}/${encodeRepoPath(repoPath)}`;\nconst pickRandom = <T,>(items: T[]): T | null => (items.length > 0 ? items[Math.floor(Math.random() * items.length)]! : null);\nconst parseNextLink = (linkHeader: string | null): string | null => {\n  if (!linkHeader) return null;\n  const match = linkHeader.match(/<([^>]+)>\\s*;\\s*rel=\"next\"/i);\n  return match?.[1] ?? null;\n};\n\nconst fetchFolderImages = async (repoFolderPath: string): Promise<string[]> => {\n  const folder = normalizeRepoPath(repoFolderPath);\n  const cached = folderImageCache.get(folder);\n  if (cached) return cached;\n  const pending = folderImagePromiseCache.get(folder);\n  if (pending) return pending;\n\n  const task = (async () => {\n    const images: string[] = [];\n    let nextUrl: string | null = `${HF_TREE_API_ROOT}/${encodeRepoPath(folder)}?recursive=true&limit=1000`;\n\n    while (nextUrl) {\n      let response: Response;\n      try {\n        response = await fetch(nextUrl);\n      } catch {\n        break;\n      }\n      if (!response.ok) break;\n\n      let entries: HfTreeEntry[] = [];\n      try {\n        entries = await response.json() as HfTreeEntry[];\n      } catch {\n        break;\n      }\n\n      for (const entry of entries) {\n        if (entry.type !== 'file' || !entry.path) continue;\n        if (!IMAGE_EXT_RE.test(entry.path)) continue;\n        images.push(entry.path);\n      }\n\n      nextUrl = parseNextLink(response.headers.get('link'));\n    }\n\n    folderImageCache.set(folder, images);\n    return images;\n  })();\n\n  folderImagePromiseCache.set(folder, task);\n  try {\n    return await task;\n  } finally {\n    folderImagePromiseCache.delete(folder);\n  }\n};\n\nconst playerPortraitUrl = ref(toResolveUrl(`${HF_USER_DIR}/立绘.png`));\nconst enemyPortraitUrl = ref(toResolveUrl(`${HF_MONSTER_DIR}/${enemyDisplayName}.png`));\nconst playerPortraitError = ref(false);\nconst enemyPortraitError = ref(false);\n\nlet portraitLoaderDisposed = false;\n\nconst resolveRandomPortrait = async (\n  folderPath: string,\n  fallbackFilePath: string,\n): Promise<string> => {\n  const images = await fetchFolderImages(folderPath);\n  const randomPath = pickRandom(images);\n  return randomPath ? toResolveUrl(randomPath) : toResolveUrl(fallbackFilePath);\n};\n\nconst initPortraitUrls = async () => {\n  const playerUrl = await resolveRandomPortrait(HF_USER_DIR, `${HF_USER_DIR}/立绘.png`);\n  if (!portraitLoaderDisposed) {\n    playerPortraitError.value = false;\n    playerPortraitUrl.value = playerUrl;\n  }\n\n  const enemyFolderPath = `${HF_MONSTER_DIR}/${enemyDisplayName}`;\n  const enemyFallback = `${HF_MONSTER_DIR}/${enemyDisplayName}.png`;\n  const shouldPreferFolder = BOSS_FOLDER_NAMES.has(enemyDisplayName);\n  let enemyUrl = toResolveUrl(enemyFallback);\n  if (shouldPreferFolder) {\n    enemyUrl = await resolveRandomPortrait(enemyFolderPath, enemyFallback);\n  } else {\n    const folderImages = await fetchFolderImages(enemyFolderPath);\n    const randomEnemy = pickRandom(folderImages);\n    if (randomEnemy) {\n      enemyUrl = toResolveUrl(randomEnemy);\n    }\n  }\n  if (!portraitLoaderDisposed) {\n    enemyPortraitError.value = false;\n    enemyPortraitUrl.value = enemyUrl;\n  }\n};\n\n// --- Dynamic Background ---\nconst bgIsLordFallback = ref(false);\nconst bgImageError = ref(false);\n\nconst HF_BASE = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E8%83%8C%E6%99%AF';\nconst currentArea = computed(() => (gameStore.statData._当前区域 as string) || '');\nconst currentRoomType = computed(() => (gameStore.statData._当前房间类型 as string) || '');\nconst bgImageUrl = computed(() => {\n  if (!currentArea.value || bgImageError.value) return '';\n  const isLord = currentRoomType.value === '领主' && !bgIsLordFallback.value;\n  const suffix = isLord ? `${currentArea.value}_领主` : currentArea.value;\n  return `${HF_BASE}/${encodeURIComponent(suffix)}.png`;\n});\nfunction onBgError() {\n  if (currentRoomType.value === '领主' && !bgIsLordFallback.value) {\n    bgIsLordFallback.value = true; // fallback to normal area bg\n  } else {\n    bgImageError.value = true; // give up, show gradient\n  }\n}\n\n// AI flags - mutable state for enemy AI decisions (e.g. hasUsedHeal)\nconst aiFlags = reactive<Record<string, any>>({});\n\n// --- State ---\nconst cloneEntityStats = (stats: EntityStats): EntityStats => ({\n  ...stats,\n  effects: stats.effects.map((eff) => ({\n    ...eff,\n    restrictedTypes: eff.restrictedTypes ? [...eff.restrictedTypes] : undefined,\n  })),\n});\n\nconst normalizeTestStartStats = (stats: EntityStats): EntityStats => {\n  const cloned = cloneEntityStats(stats);\n  if (!props.testStartAt999) return cloned;\n  return { ...cloned, hp: 999, maxHp: 999, mp: 999 };\n};\n\nconst playerStats = ref<EntityStats>(\n  normalizeTestStartStats(props.initialPlayerStats),\n);\nconst enemyStats = ref<EntityStats>(\n  normalizeTestStartStats(\n    enemyDef\n      ? enemyDef.stats\n      : { hp: 1, maxHp: 1, mp: 0, minDice: 1, maxDice: 1, effects: [] },\n  ),\n);\n\n// --- Effect display helpers ---\nconst getEffectName = (type: EffectType): string => {\n  return EFFECT_REGISTRY[type]?.name ?? String(type);\n};\nconst getEffectDescription = (type: EffectType): string => {\n  return EFFECT_REGISTRY[type]?.description ?? '';\n};\nconst createStatusEffectPreview = (type: EffectType, stacks: number): EffectInstance => ({\n  type,\n  stacks: Math.max(1, Math.floor(stacks)),\n  polarity: EFFECT_REGISTRY[type]?.polarity ?? 'special',\n});\nconst EFFECT_FA_ICON_CLASS: Partial<Record<EffectType, string>> = {\n  [ET.BARRIER]: 'fa-brands fa-fediverse',\n  [ET.ARMOR]: 'fa-solid fa-shield-halved',\n  [ET.BIND]: 'fa-solid fa-link',\n  [ET.DEVOUR]: 'fa-brands fa-optin-monster',\n  [ET.POISON]: 'fa-solid fa-virus',\n  [ET.POISON_AMOUNT]: 'fa-solid fa-bacterium',\n  [ET.CORROSION]: 'fa-brands fa-cloudscale',\n  [ET.BURN]: 'fa-solid fa-fire',\n  [ET.BLEED]: 'fa-solid fa-droplet',\n  [ET.VULNERABLE]: 'fa-brands fa-linode',\n  [ET.DAMAGE_BOOST]: 'fa-brands fa-superpowers',\n  [ET.REGEN]: 'fa-brands fa-medrt',\n  [ET.WHITE_TURBID]: 'fa-solid fa-droplet',\n  [ET.IGNITE_AURA]: 'fa-solid fa-fire-flame-simple',\n  [ET.STUN]: 'fa-solid fa-ban',\n  [ET.CHARGE]: 'fa-solid fa-exclamation',\n  [ET.FATIGUE]: 'fa-solid fa-bed',\n  [ET.COLD]: 'fa-regular fa-snowflake',\n  [ET.TEMPERATURE_DIFF]: 'fa-brands fa-empire',\n  [ET.NON_LIVING]: 'fa-solid fa-skull',\n  [ET.NON_ENTITY]: 'fa-solid fa-ghost',\n  [ET.ILLUSORY_BODY]: 'fa-solid fa-ghost',\n  [ET.TEMP_MAX_HP]: 'fa-solid fa-heart',\n  [ET.MAX_HP_REDUCTION]: 'fa-solid fa-heart-pulse',\n  [ET.POINT_GROWTH_BIG]: 'fa-solid fa-dice fa-lg',\n  [ET.POINT_GROWTH_SMALL]: 'fa-solid fa-dice fa-sm',\n  [ET.MANA_DRAIN]: 'fa-solid fa-battery-empty',\n  [ET.MANA_SPRING]: 'fa-brands fa-drupal',\n  [ET.SWARM]: 'fa-solid fa-bugs',\n  [ET.BLOOD_COCOON]: 'fa-brands fa-battle-net',\n  [ET.INDOMITABLE]: 'fa-solid fa-shield',\n  [ET.PEEP_FORBIDDEN]: 'fa-solid fa-eye',\n  [ET.BLIND_ASH]: 'fa-regular fa-eye-slash',\n  [ET.COGNITIVE_INTERFERENCE]: 'fa-solid fa-hamsa',\n  [ET.MEMORY_FOG]: 'fa-brands fa-phabricator',\n  [ET.SILENCE]: 'fa-solid fa-circle-xmark',\n  [ET.STURDY]: 'fa-solid fa-user-shield',\n  [ET.SHOCK]: 'fa-solid fa-bolt',\n  [ET.FLAME_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.POISON_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.TOXIN_SPREAD]: 'fa-brands fa-hornbill',\n  [ET.AMBUSH]: 'fa-solid fa-user-secret',\n  [ET.FROST_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.BLOODBLADE_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.LIGHTNING_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.THORNS]: 'fa-solid fa-leaf',\n};\nconst EFFECT_FA_ICON_STYLE: Partial<Record<EffectType, Record<string, string>>> = {\n  [ET.FLAME_ATTACH]: { color: 'rgb(255, 64, 64)' },\n  [ET.POISON_ATTACH]: { color: 'rgb(81, 255, 116)' },\n  [ET.FROST_ATTACH]: { color: 'rgb(108, 230, 255)' },\n  [ET.BLOODBLADE_ATTACH]: { color: 'rgb(176, 0, 0)' },\n  [ET.LIGHTNING_ATTACH]: { color: 'rgb(201, 69, 255)' },\n  [ET.TEMP_MAX_HP]: { color: 'rgb(255, 120, 150)' },\n  [ET.ILLUSORY_BODY]: {\n    '--fa-primary-color': 'rgb(255, 255, 255)',\n    '--fa-secondary-color': 'rgb(255, 255, 255)',\n  },\n};\nconst getEffectFontAwesomeClass = (type: EffectType): string | null => EFFECT_FA_ICON_CLASS[type] ?? null;\nconst getEffectFontAwesomeStyle = (type: EffectType): Record<string, string> | undefined => EFFECT_FA_ICON_STYLE[type];\nconst EFFECT_ICON_COMPONENTS: Partial<Record<EffectType, any>> = {\n  [ET.BARRIER]: ShieldCheck,\n  [ET.ARMOR]: Shield,\n  [ET.BIND]: Link2,\n  [ET.DEVOUR]: Skull,\n  [ET.POISON]: Bug,\n  [ET.POISON_AMOUNT]: Droplet,\n  [ET.CORROSION]: Droplet,\n  [ET.BURN]: Flame,\n  [ET.BLEED]: Droplet,\n  [ET.VULNERABLE]: TriangleAlert,\n  [ET.DAMAGE_BOOST]: Sword,\n  [ET.REGEN]: Heart,\n  [ET.WHITE_TURBID]: Droplet,\n  [ET.IGNITE_AURA]: Sparkles,\n  [ET.STUN]: Ban,\n  [ET.CHARGE]: Zap,\n  [ET.FATIGUE]: TriangleAlert,\n  [ET.COLD]: Snowflake,\n  [ET.TEMPERATURE_DIFF]: Waves,\n  [ET.NON_LIVING]: Bone,\n  [ET.NON_ENTITY]: Sparkles,\n  [ET.ILLUSORY_BODY]: Sparkles,\n  [ET.TEMP_MAX_HP]: Heart,\n  [ET.MAX_HP_REDUCTION]: Heart,\n  [ET.POINT_GROWTH_BIG]: Layers,\n  [ET.POINT_GROWTH_SMALL]: Layers,\n  [ET.MANA_DRAIN]: Battery,\n  [ET.MANA_SPRING]: Waves,\n  [ET.SWARM]: Bug,\n  [ET.BLOOD_COCOON]: Heart,\n  [ET.INDOMITABLE]: Heart,\n  [ET.PEEP_FORBIDDEN]: Eye,\n  [ET.BLIND_ASH]: EyeOff,\n  [ET.COGNITIVE_INTERFERENCE]: Brain,\n  [ET.MEMORY_FOG]: EyeOff,\n  [ET.SILENCE]: Ban,\n  [ET.STURDY]: Shield,\n  [ET.SHOCK]: Zap,\n  [ET.FLAME_ATTACH]: Flame,\n  [ET.POISON_ATTACH]: Bug,\n  [ET.TOXIN_SPREAD]: Bug,\n  [ET.AMBUSH]: Link2,\n  [ET.FROST_ATTACH]: Snowflake,\n  [ET.BLOODBLADE_ATTACH]: Droplet,\n  [ET.LIGHTNING_ATTACH]: Zap,\n  [ET.THORNS]: Leaf,\n};\nconst getEffectIconComponent = (type: EffectType) => {\n  return EFFECT_ICON_COMPONENTS[type] ?? Sparkles;\n};\nconst effectIconBoxClass = (polarity: EffectPolarity): string => {\n  switch (polarity) {\n    case 'buff':    return 'bg-emerald-900/65 border-emerald-400/50 text-emerald-200';\n    case 'debuff':  return 'bg-red-900/65 border-red-400/55 text-red-200';\n    case 'trait':   return 'bg-slate-800/70 border-slate-400/45 text-slate-200';\n    case 'mixed':   return 'bg-indigo-900/70 border-indigo-400/55 text-indigo-200';\n    case 'special': return 'bg-amber-900/70 border-amber-400/55 text-amber-200';\n    default:        return 'bg-slate-800/70 border-slate-400/45 text-slate-200';\n  }\n};\n\n// --- Armor computed ---\nconst playerArmor = computed(() => {\n  const eff = playerStats.value.effects.find(e => e.type === ET.ARMOR);\n  return eff?.stacks ?? 0;\n});\nconst enemyArmor = computed(() => {\n  const eff = enemyStats.value.effects.find(e => e.type === ET.ARMOR);\n  return eff?.stacks ?? 0;\n});\nconst playerPoisonAmount = computed(() => {\n  const eff = playerStats.value.effects.find(e => e.type === ET.POISON_AMOUNT);\n  return eff?.stacks ?? 0;\n});\nconst enemyPoisonAmount = computed(() => {\n  const eff = enemyStats.value.effects.find(e => e.type === ET.POISON_AMOUNT);\n  return eff?.stacks ?? 0;\n});\nconst playerTempMaxHp = computed(() => {\n  const eff = playerStats.value.effects.find(e => e.type === ET.TEMP_MAX_HP);\n  return eff?.stacks ?? 0;\n});\nconst enemyTempMaxHp = computed(() => {\n  const eff = enemyStats.value.effects.find(e => e.type === ET.TEMP_MAX_HP);\n  return eff?.stacks ?? 0;\n});\nconst playerPoisonAmountPercent = computed(() => {\n  if (playerStats.value.maxHp <= 0) return 0;\n  return Math.max(0, Math.min((playerPoisonAmount.value / playerStats.value.maxHp) * 100, 100));\n});\nconst enemyPoisonAmountPercent = computed(() => {\n  if (enemyStats.value.maxHp <= 0) return 0;\n  return Math.max(0, Math.min((enemyPoisonAmount.value / enemyStats.value.maxHp) * 100, 100));\n});\nconst playerVisibleEffects = computed(() => playerStats.value.effects.filter(\n  e => e.type !== ET.ARMOR && e.type !== ET.POISON_AMOUNT && e.type !== ET.TEMP_MAX_HP,\n));\nconst enemyVisibleEffects = computed(() => enemyStats.value.effects.filter(\n  e => e.type !== ET.ARMOR && e.type !== ET.POISON_AMOUNT && e.type !== ET.TEMP_MAX_HP,\n));\n\nconst cloneCardForBattle = (card: CardData): CardData => ({\n  ...card,\n  calculation: { ...card.calculation },\n  damageLogic: { ...card.damageLogic },\n  traits: { ...card.traits },\n  selfDamage: typeof card.selfDamage === 'object' && card.selfDamage !== null\n    ? { ...(card.selfDamage as CardSelfDamageConfig) }\n    : card.selfDamage,\n  cardEffects: card.cardEffects.map((ce) => ({\n    ...ce,\n    triggers: ce.triggers ? [...ce.triggers] : undefined,\n    restrictedTypes: ce.restrictedTypes ? [...ce.restrictedTypes] : undefined,\n    cleanseTypes: ce.cleanseTypes ? [...ce.cleanseTypes] : undefined,\n  })),\n});\nconst toBattleDeck = (cards: CardData[]) => cards.map(cloneCardForBattle);\n\nconst enemyDeck = enemyDef ? toBattleDeck(enemyDef.deck) : [];\n\n// dummy card to prevent crash if enemy has no cards\nconst PASS_CARD: CardData = {\n  id: 'pass', name: '跳过', type: CardType.FUNCTION, category: '基础', rarity: '普通', manaCost: 0,\n  calculation: { multiplier: 0, addition: 0 }, damageLogic: { mode: 'fixed', value: 0 },\n  traits: { combo: false, reroll: 'none', draw: false }, cardEffects: [], description: '无行动',\n};\n\nconst combatState = ref<CombatState>({\n  turn: 1,\n  phase: CombatPhase.TURN_START,\n  actionsRemaining: 1,\n  playerBaseDice: 1,\n  enemyBaseDice: 1,\n  playerHand: [],\n  playerDeck: toBattleDeck(props.playerDeck).sort(() => Math.random() - 0.5),\n  discardPile: [],\n  enemyDeck: [...enemyDeck],\n  enemyDiscard: [],\n  enemyIntentCard: null,\n  enemyPredictedPoint: 0,\n  playerSelectedCard: null,\n  lastPlayedCard: null,\n  logs: [`战斗开始！遭遇了 <span class=\"text-red-500 font-bold\">${enemyDisplayName}</span>`],\n});\n\nconst recordCombatDiscoveryAtStart = () => {\n  if (!props.trackDiscovery) return;\n  recordEncounteredEnemy({\n    name: enemyDisplayName || props.enemyName,\n    floor: currentFloorNumber,\n    area: currentArea.value || '',\n  });\n  recordEncounteredCards([\n    ...combatState.value.playerDeck.map((card) => card.id),\n    ...combatState.value.enemyDeck.map((card) => card.id),\n  ]);\n};\n\nconst recordCombatEffectDiscovery = () => {\n  if (!props.trackDiscovery) return;\n  recordEncounteredEffects([\n    ...playerStats.value.effects.map((effect) => effect.type),\n    ...enemyStats.value.effects.map((effect) => effect.type),\n  ]);\n};\n\nonMounted(() => {\n  recordCombatDiscoveryAtStart();\n  recordCombatEffectDiscovery();\n});\n\nwatch(\n  () => [playerStats.value.effects, enemyStats.value.effects],\n  () => {\n    recordCombatEffectDiscovery();\n  },\n  { deep: true },\n);\n\n// 用于“吞食”判定：仅记录每回合最初投出的裸骰点数（不含卡牌/圣遗物/后续点数改动）\nconst playerTurnRawDice = ref(1);\nconst enemyTurnRawDice = ref(1);\n\nconst isRolling = ref(false);\nconst showClashAnimation = ref(false);\nconst shatteringTarget = ref<'player' | 'enemy' | 'both' | null>(null);\nconst screenShake = ref(false);\nconst impactShake = ref(false);\nconst overlayOpen = ref<'deck' | 'discard' | null>(null);\nconst settingsOpen = ref(false);\nconst battleSpeedUp = ref(false);\nconst logsCollapsed = ref(true);\nconst battleResultBanner = ref<'win' | 'lose' | null>(null);\nconst endCombatPending = ref(false);\nconst enemyIntentConsumedThisTurn = ref(false);\nconst enemyIntentManaSpentThisTurn = ref(false);\nconst combatRootEl = ref<HTMLElement | null>(null);\nconst effectTooltip = ref<{\n  x: number;\n  y: number;\n  name: string;\n  description: string;\n  stacks: number;\n  align: 'center' | 'right';\n} | null>(null);\n\ntype BattleSide = 'player' | 'enemy';\ntype FloatingNumberKind = 'physical' | 'magic' | 'shield' | 'heal' | 'mana' | 'true';\ntype ResolvedCardAnimVariant = 'attack' | 'self' | 'fade';\ntype TooltipAlign = 'center' | 'right';\n\ninterface FloatingNumberEntry {\n  id: number;\n  side: BattleSide;\n  kind?: FloatingNumberKind;\n  text: string;\n  colorClass: string;\n  leftOffset: number;\n  topOffset: number;\n  duration: number;\n}\n\ninterface PlayerPlayedCardVisual {\n  id: number;\n  card: CardData;\n  entered: boolean;\n}\n\ninterface ResolvedCardVisual {\n  id: number;\n  source: BattleSide;\n  card: CardData;\n  variant: ResolvedCardAnimVariant;\n}\n\ninterface DicePreviewPanel {\n  key: string;\n  title: string;\n  finalPoint: number;\n  lines: string[];\n}\n\nconst SPEED_SETTING_KEY = 'dungeon.combat.speed_up';\nconst FATIGUE_DEGREE_KEY = 'dungeon.combat.fatigue_degree';\nconst FATIGUE_DEGREE_MAX = 300;\nconst speedMultiplier = computed(() => (battleSpeedUp.value ? 2 : 1));\nconst DEFAULT_COMBAT_FONT_FAMILY = \"'Inter', sans-serif\";\nconst combatFontFamily = computed(() => {\n  const value = props.uiFontFamily?.trim();\n  return value && value.length > 0 ? value : DEFAULT_COMBAT_FONT_FAMILY;\n});\nconst combatRootStyle = computed(() => ({\n  '--combat-speed-multiplier': String(speedMultiplier.value),\n  '--font-ui': combatFontFamily.value,\n  '--font-heading': combatFontFamily.value,\n  fontFamily: combatFontFamily.value,\n}));\nconst floatingNumbers = ref<FloatingNumberEntry[]>([]);\nconst pendingCardNegativeEffects = ref<string[]>([]);\nconst PLAYER_POISON_LETHAL_NEGATIVE_STATUS = '[催淫]';\nconst PLAYER_SHOCK_LETHAL_NEGATIVE_STATUS = '[神经肌肉失调]';\nconst PLAYER_CORROSION_LETHAL_NEGATIVE_STATUS = '[被侵蚀]';\nconst fatigueDegree = ref(0);\nconst fatigueHelpVisible = ref(false);\nconst fatigueDegreeRatio = computed(() => (\n  Math.max(0, Math.min(fatigueDegree.value / FATIGUE_DEGREE_MAX, 1))\n));\nconst fatigueDegreePercent = computed(() => fatigueDegreeRatio.value * 100);\nconst fatigueBarOpacityRatio = computed(() => {\n  if (fatigueDegree.value <= 50) return 0;\n  return Math.max(0, Math.min((fatigueDegree.value - 50) / (FATIGUE_DEGREE_MAX - 50), 1));\n});\nconst fatigueBarStyle = computed(() => ({ opacity: String(fatigueBarOpacityRatio.value) }));\nconst showFatigueHelp = () => {\n  fatigueHelpVisible.value = fatigueDegree.value > 50;\n};\nconst hideFatigueHelp = () => {\n  fatigueHelpVisible.value = false;\n};\nconst queuePlayerLethalNegativeStatus = (negativeStatus: string, reason: string) => {\n  const normalized = negativeStatus.trim();\n  if (!normalized) return;\n  if (pendingCardNegativeEffects.value.includes(normalized)) return;\n  pendingCardNegativeEffects.value.push(normalized);\n  log(`<span class=\"text-fuchsia-300\">我方因${reason}获得负面状态：${normalized}</span>`);\n};\nconst lightningAmbushFirstUseConsumed = ref<Record<BattleSide, boolean>>({\n  player: false,\n  enemy: false,\n});\nconst previewPlayerDice = ref<number | null>(null);\nconst previewEnemyDice = ref<number | null>(null);\nconst playerDicePreviewLines = ref<string[]>([]);\nconst enemyDicePreviewLines = ref<string[]>([]);\nconst playerDicePreviewCardName = ref('');\nconst enemyDicePreviewCardName = ref('');\nconst playerDiceUiNoise = ref(0);\nconst enemyDiceUiNoise = ref(0);\nconst comboUiMaskBridge = ref(false);\nconst isUiMaskingActive = computed(() => (\n  combatState.value.phase === CombatPhase.PLAYER_INPUT || comboUiMaskBridge.value\n));\nconst isPlayerDiceObscured = computed(() => (\n  isUiMaskingActive.value\n  && getEffectStacks(playerStats.value, ET.BLIND_ASH) > 0\n));\nconst isEnemyDiceObscured = computed(() => (\n  isUiMaskingActive.value\n  && getEffectStacks(playerStats.value, ET.PEEP_FORBIDDEN) > 0\n));\nconst rerollUiNoise = () => Math.floor(Math.random() * 3) - 1;\nconst displayPlayerDice = computed(() => {\n  const base = previewPlayerDice.value ?? combatState.value.playerBaseDice;\n  if (!isPlayerDiceObscured.value) return base;\n  return Math.max(0, base + playerDiceUiNoise.value);\n});\nconst displayEnemyDice = computed(() => {\n  const base = previewEnemyDice.value ?? combatState.value.enemyBaseDice;\n  if (!isEnemyDiceObscured.value) return base;\n  return Math.max(0, base + enemyDiceUiNoise.value);\n});\nconst canPlayerRerollDice = computed(() => (\n  playerDiceRerollCharges.value > 0\n  && combatState.value.phase === CombatPhase.PLAYER_INPUT\n  && !isRolling.value\n  && !showClashAnimation.value\n  && !endCombatPending.value\n));\nconst playerDiceRerollHint = computed(() => {\n  if (playerDiceRerollCharges.value <= 0) return '无可用重掷次数';\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return '当前阶段不可重掷';\n  if (isRolling.value || showClashAnimation.value) return '结算中暂不可重掷';\n  if (endCombatPending.value) return '战斗结束中不可重掷';\n  return `可点击重掷（剩余${playerDiceRerollCharges.value}次）`;\n});\nconst playerDicePreviewChanged = computed(() => (\n  previewPlayerDice.value !== null && previewPlayerDice.value !== combatState.value.playerBaseDice\n));\nconst enemyDicePreviewChanged = computed(() => (\n  previewEnemyDice.value !== null && previewEnemyDice.value !== combatState.value.enemyBaseDice\n));\nconst playerDiceNumberClass = computed(() => {\n  if (isPlayerDiceObscured.value) return 'text-violet-400';\n  return playerDicePreviewChanged.value ? 'text-red-800' : '';\n});\nconst enemyDiceNumberClass = computed(() => {\n  if (isEnemyDiceObscured.value) return 'text-violet-400';\n  return enemyDicePreviewChanged.value ? 'text-[#b08a2e]' : '';\n});\nconst dicePreviewPanels = computed<DicePreviewPanel[]>(() => {\n  const panels: DicePreviewPanel[] = [];\n  if (previewPlayerDice.value !== null && !isPlayerDiceObscured.value && playerDicePreviewLines.value.length > 0) {\n    panels.push({\n      key: 'player',\n      title: `我方 · ${playerDicePreviewCardName.value || '点数预览'}`,\n      finalPoint: previewPlayerDice.value,\n      lines: playerDicePreviewLines.value,\n    });\n  }\n  if (previewEnemyDice.value !== null && !isEnemyDiceObscured.value && enemyDicePreviewLines.value.length > 0) {\n    panels.push({\n      key: 'enemy',\n      title: `敌方 · ${enemyDicePreviewCardName.value || '点数预览'}`,\n      finalPoint: previewEnemyDice.value,\n      lines: enemyDicePreviewLines.value,\n    });\n  }\n  return panels;\n});\nconst enemyIntentMaskLevel = computed<'none' | 'partial' | 'full'>(() => (\n  isUiMaskingActive.value\n    && getEffectStacks(playerStats.value, ET.COGNITIVE_INTERFERENCE) > 0\n    ? 'full'\n    : 'none'\n));\nconst playerHandMaskLevel = computed<'none' | 'partial' | 'full'>(() => (\n  isUiMaskingActive.value\n    && getEffectStacks(playerStats.value, ET.MEMORY_FOG) > 0\n    ? 'partial'\n    : 'none'\n));\nconst playerPlayedCardVisual = ref<PlayerPlayedCardVisual | null>(null);\nconst resolvedPlayerCardVisual = ref<ResolvedCardVisual | null>(null);\nconst resolvedEnemyCardVisual = ref<ResolvedCardVisual | null>(null);\nconst resolvedCardVisualEntries = computed(() => (\n  [resolvedPlayerCardVisual.value, resolvedEnemyCardVisual.value]\n    .filter((visual): visual is ResolvedCardVisual => !!visual)\n));\nlet hoverPreviewTimer: ReturnType<typeof setTimeout> | null = null;\nlet enemyDicePreviewTimer: ReturnType<typeof setTimeout> | null = null;\nlet effectTooltipLongPressTimer: ReturnType<typeof setTimeout> | null = null;\nlet effectTooltipAutoHideTimer: ReturnType<typeof setTimeout> | null = null;\nlet floatingNumberId = 0;\nlet handCardKeySeed = 0;\nlet playerPlayedCardVisualId = 0;\nlet resolvedCardVisualId = 0;\nlet animationStopToken = 0;\nlet endCombatSequenceToken = 0;\nlet enemyManaLackHintTurn = -1;\nconst handCardKeys = new WeakMap<CardData, string>();\nconst invalidCardShakeKeys = ref<Set<string>>(new Set());\n\nconst normalizePersistedInt = (value: unknown): number => {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return 0;\n  return Math.max(0, Math.floor(parsed));\n};\n\nconst setFatigueDegree = (next: number) => {\n  const normalized = normalizePersistedInt(next);\n  fatigueDegree.value = normalized;\n  localStorage.setItem(FATIGUE_DEGREE_KEY, String(normalized));\n};\n\nconst loadFatigueDegree = () => {\n  const stored = localStorage.getItem(FATIGUE_DEGREE_KEY);\n  setFatigueDegree(normalizePersistedInt(stored ?? 0));\n};\n\nconst addFatigueDegree = (delta: number) => {\n  const amount = Math.max(0, Math.floor(delta));\n  if (amount <= 0) return;\n  setFatigueDegree(fatigueDegree.value + amount);\n};\n\n// Default relic modifiers (no relics yet)\nconst NO_RELIC_MOD = { globalMultiplier: 1, globalAddition: 0 };\nconst activePlayerRelics = resolveRelicMap(props.playerRelics);\nconst playerDiceRerollCharges = ref(0);\nconst relicRuntimeState = reactive<Record<string, Record<string, unknown>>>({});\nconst playerDamageTakenThisTurn = ref(0);\nconst freezePumpTriggersThisTurn = ref(0);\nconst freezeFlowCoreTriggeredThisTurn = ref(false);\nconst sealCircuitPendingMana = ref(0);\nconst modaoStabilizerTriggersThisTurn = ref(0);\nconst bloodpoolSkinMarkTriggersThisTurn = ref(0);\nconst bloodpoolFirstBleedFeastTriggered = ref(false);\nconst bloodpoolCriticalReboundTriggered = ref(false);\n\nconst getEntityBySide = (side: RelicSide): EntityStats => (side === 'player' ? playerStats.value : enemyStats.value);\n\nconst getRelicRuntimeState = (relicId: string) => {\n  if (!relicRuntimeState[relicId]) {\n    relicRuntimeState[relicId] = {};\n  }\n  return relicRuntimeState[relicId]!;\n};\n\nconst hasActiveRelic = (id: string) => activePlayerRelics.some((entry) => entry.relic.id === id && entry.count > 0);\nconst getActiveRelicCount = (id: string) => (\n  activePlayerRelics.find((entry) => entry.relic.id === id)?.count ?? 0\n);\n\nconst changeRerollCharges = (side: RelicSide, delta: number) => {\n  if (side !== 'player') return;\n  playerDiceRerollCharges.value = Math.max(0, playerDiceRerollCharges.value + Math.floor(delta));\n};\n\nconst consumeRerollCharge = (side: RelicSide, amount: number = 1): boolean => {\n  if (side !== 'player') return false;\n  const need = Math.max(1, Math.floor(amount));\n  if (playerDiceRerollCharges.value < need) return false;\n  playerDiceRerollCharges.value -= need;\n  return true;\n};\n\nconst getRerollCharges = (side: RelicSide): number => {\n  if (side !== 'player') return 0;\n  return playerDiceRerollCharges.value;\n};\n\nconst forEachPlayerRelic = (\n  callback: (entry: ResolvedRelicEntry, relic: RelicData, state: Record<string, unknown>) => void,\n) => {\n  for (const entry of activePlayerRelics) {\n    callback(entry, entry.relic, getRelicRuntimeState(entry.relic.id));\n  }\n};\n\nconst logRelicMessage = (message: string) => {\n  log(`<span class=\"text-amber-300 text-[9px]\">[圣遗物] ${message}</span>`);\n};\n\nconst addPlayerDamageTakenThisTurn = (amount: number) => {\n  const value = Math.max(0, Math.floor(amount));\n  if (value <= 0) return;\n  playerDamageTakenThisTurn.value += value;\n};\n\nconst applyPlayerSkinMarkDamageReduction = (rawDamage: number, reason: string): number => {\n  const damage = Math.max(0, Math.floor(rawDamage));\n  if (damage <= 0) return 0;\n  const markCount = getActiveRelicCount('bloodpool_skin_mark');\n  if (markCount <= 0) return damage;\n  if (bloodpoolSkinMarkTriggersThisTurn.value >= 2) return damage;\n  const reduced = Math.min(damage, markCount);\n  if (reduced <= 0) return damage;\n  bloodpoolSkinMarkTriggersThisTurn.value += 1;\n  logRelicMessage(`[皮肤印记] ${reason}伤害 -${reduced}（本回合 ${bloodpoolSkinMarkTriggersThisTurn.value}/2）。`);\n  return damage - reduced;\n};\n\nconst applyPlayerHemostaticValveDamageCap = (rawDamage: number, reason: string): number => {\n  const damage = Math.max(0, Math.floor(rawDamage));\n  if (damage <= 0) return 0;\n  if (getActiveRelicCount('bloodpool_hemostatic_valve') <= 0) return damage;\n  const capped = Math.min(10, damage);\n  if (capped < damage) {\n    logRelicMessage(`[凝血限流阀] ${reason}伤害由 ${damage} 限制为 ${capped}。`);\n  }\n  return capped;\n};\n\nconst applyDamageToSideWithRelics = (\n  side: BattleSide,\n  target: EntityStats,\n  damage: number,\n  isTrueDamage: boolean,\n  reason: string,\n) => {\n  const incoming = Math.max(0, Math.floor(damage));\n  const adjusted = side === 'player'\n    ? applyPlayerHemostaticValveDamageCap(incoming, reason)\n    : incoming;\n  return applyDamageToEntity(target, adjusted, isTrueDamage);\n};\n\nconst applyDirectHpLossWithRelics = (\n  side: BattleSide,\n  target: EntityStats,\n  damage: number,\n  reason: string,\n): number => {\n  const incoming = Math.max(0, Math.floor(damage));\n  if (incoming <= 0) return 0;\n  const adjusted = side === 'player'\n    ? applyPlayerHemostaticValveDamageCap(incoming, reason)\n    : incoming;\n  const before = target.hp;\n  target.hp = Math.max(0, target.hp - adjusted);\n  return Math.max(0, before - target.hp);\n};\n\nconst handlePlayerArmorGainFromSingleEvent = (amount: number, source: string) => {\n  const gained = Math.max(0, Math.floor(amount));\n  if (gained <= 0) return;\n  const relicCount = getActiveRelicCount('yanhan_freeze_flow_core');\n  if (relicCount <= 0) return;\n  if (freezeFlowCoreTriggeredThisTurn.value) return;\n  if (gained < 5) return;\n  const restored = restoreManaForSide('player', relicCount);\n  if (restored <= 0) return;\n  freezeFlowCoreTriggeredThisTurn.value = true;\n  logRelicMessage(`[冻流泵芯] ${source}单次获得护甲≥5，额外回复 ${restored} 点魔力。`);\n};\n\nconst addArmorForSide = (side: RelicSide, amount: number): number => {\n  const value = Math.max(0, Math.floor(amount));\n  if (value <= 0) return 0;\n  const target = getEntityBySide(side);\n  const added = applyEffect(target, ET.ARMOR, value, { source: 'relic' }) ? value : 0;\n  if (added > 0) {\n    pushFloatingNumber(side, added, 'shield', '+');\n    if (side === 'player') {\n      handlePlayerArmorGainFromSingleEvent(added, '圣遗物');\n    }\n  }\n  return added;\n};\n\nconst tryTriggerModaoStabilizer = (side: RelicSide, actualDelta: number, reason: string) => {\n  if (side !== 'player') return;\n  if (actualDelta < 3) return;\n  const stabilizerCount = getActiveRelicCount('modao_stabilizer_pin');\n  if (stabilizerCount <= 0) return;\n  if (modaoStabilizerTriggersThisTurn.value >= 2) return;\n  const gained = addArmorForSide('player', stabilizerCount);\n  if (gained <= 0) return;\n  modaoStabilizerTriggersThisTurn.value += 1;\n  logRelicMessage(`[稳压回针] ${reason}单次回蓝 ${actualDelta}，获得 ${gained} 点护甲（本回合 ${modaoStabilizerTriggersThisTurn.value}/2）。`);\n};\n\nconst restoreManaForSide = (side: RelicSide, amount: number): number => {\n  const value = Math.max(0, Math.floor(amount));\n  if (value <= 0) return 0;\n  const target = getEntityBySide(side);\n  const before = target.mp;\n  target.mp = Math.max(0, target.mp + value);\n  const delta = target.mp - before;\n  if (delta > 0) {\n    pushFloatingNumber(side, delta, 'mana', '+');\n    tryTriggerModaoStabilizer(side, delta, '回合/效果触发，');\n  }\n  return delta;\n};\n\nconst healForSide = (\n  side: RelicSide,\n  amount: number,\n  options?: { overflowToArmor?: boolean },\n): { healed: number; overflow: number } => {\n  const baseValue = Math.max(0, Math.floor(amount));\n  if (baseValue <= 0) return { healed: 0, overflow: 0 };\n\n  let value = baseValue;\n  if (side === 'player') {\n    const healAmpCount = getActiveRelicCount('bloodpool_crimson_plasma');\n    if (healAmpCount > 0) {\n      value = Math.max(0, Math.floor(value * (1 + 0.25 * healAmpCount)));\n    }\n  }\n  if (value <= 0) return { healed: 0, overflow: 0 };\n\n  const target = getEntityBySide(side);\n  const before = target.hp;\n  target.hp = Math.max(0, Math.min(target.maxHp, target.hp + value));\n  const healed = target.hp - before;\n  const overflowRaw = Math.max(0, value - healed);\n  if (healed > 0) {\n    pushFloatingNumber(side, healed, 'heal', '+');\n  }\n  if (options?.overflowToArmor && overflowRaw > 0) {\n    addArmorForSide(side, overflowRaw);\n  }\n  if (side === 'player' && healed > 0) {\n    const reflowCount = getActiveRelicCount('bloodpool_reflow_mark');\n    if (reflowCount > 0) {\n      const state = getRelicRuntimeState('bloodpool_reflow_mark');\n      const current = Math.max(0, Math.floor(Number(state['healTriggersThisTurn'] ?? 0)));\n      const cap = Math.max(0, 2 * reflowCount);\n      if (current < cap) {\n        const next = Math.min(cap, current + 1);\n        state['healTriggersThisTurn'] = next;\n      }\n    }\n  }\n  return { healed, overflow: overflowRaw };\n};\n\nconst shouldAllowStatusEffectWithRelics = (\n  targetSide: RelicSide,\n  effectType: EffectType,\n  stacks: number,\n  options?: RelicApplyEffectOptions,\n) => {\n  let allowed = true;\n  const target = getEntityBySide(targetSide);\n  forEachPlayerRelic((entry, relic, state) => {\n    if (!allowed) return;\n    const hook = relic.hooks?.onBeforeApplyEffect;\n    if (!hook) return;\n\n    const ctx: RelicBeforeApplyEffectHookContext = {\n      count: entry.count,\n      side: 'player',\n      self: playerStats.value,\n      opponent: enemyStats.value,\n      state,\n      addLog: logRelicMessage,\n      hasRelic: hasActiveRelic,\n      getRelicCount: getActiveRelicCount,\n      addStatusEffect: (side, targetEffectType, targetStacks, applyOptions) => (\n        applyStatusEffectWithRelics(side, targetEffectType, targetStacks, applyOptions)\n      ),\n      addArmor: addArmorForSide,\n      restoreMana: restoreManaForSide,\n      heal: healForSide,\n      addRerollCharges: changeRerollCharges,\n      getRerollCharges,\n      targetSide,\n      target,\n      effectType,\n      stacks,\n      source: options?.source,\n      restrictedTypes: options?.restrictedTypes,\n    };\n    const result = hook(ctx);\n    if (result === false) {\n      allowed = false;\n    }\n  });\n  return allowed;\n};\n\nconst applyStatusEffectWithRelics = (\n  side: RelicSide,\n  effectType: EffectType,\n  stacks: number,\n  options?: RelicApplyEffectOptions,\n): boolean => {\n  const value = Math.max(0, Math.floor(stacks));\n  if (value <= 0) return false;\n  if (!shouldAllowStatusEffectWithRelics(side, effectType, value, options)) return false;\n  const target = getEntityBySide(side);\n  const hpBeforeApply = target.hp;\n  const applied = applyEffect(target, effectType, value, {\n    restrictedTypes: options?.restrictedTypes,\n    source: options?.source,\n    lockDecayThisTurn: options?.lockDecayThisTurn,\n  });\n  if (\n    applied\n    && side === 'player'\n    && effectType === ET.CORROSION\n    && hpBeforeApply > 0\n    && target.hp <= 0\n  ) {\n    log('<span class=\"text-red-400\">[侵蚀] 侵蚀指数越过了临界值，我方战败，失去对身体的控制权。</span>');\n    queuePlayerLethalNegativeStatus(PLAYER_CORROSION_LETHAL_NEGATIVE_STATUS, '侵蚀');\n  }\n  if (applied && side === 'enemy' && effectType === ET.COLD) {\n    const sourceTag = options?.source ?? '';\n    const fromEnemyCard = typeof sourceTag === 'string' && sourceTag.startsWith('enemy_');\n    const freezePumpCount = getActiveRelicCount('yanhan_freeze_pump');\n    if (!fromEnemyCard && freezePumpCount > 0 && freezePumpTriggersThisTurn.value < 2) {\n      const gained = addArmorForSide('player', freezePumpCount);\n      if (gained > 0) {\n        freezePumpTriggersThisTurn.value += 1;\n        logRelicMessage(`[冻结泵] 施加寒冷触发，获得 ${gained} 点护甲（本回合 ${freezePumpTriggersThisTurn.value}/2）。`);\n      }\n    }\n  }\n  return applied;\n};\n\nconst createPlayerLifecycleContext = (\n  relic: RelicData,\n  count: number,\n  state: Record<string, unknown>,\n): RelicLifecycleHookContext => ({\n  count,\n  side: 'player',\n  self: playerStats.value,\n  opponent: enemyStats.value,\n  state,\n  addLog: logRelicMessage,\n  hasRelic: hasActiveRelic,\n  getRelicCount: getActiveRelicCount,\n  addStatusEffect: (side, effectType, stacks, options) => (\n    applyStatusEffectWithRelics(side, effectType, stacks, {\n      source: options?.source ?? `relic:${relic.id}`,\n      restrictedTypes: options?.restrictedTypes,\n      lockDecayThisTurn: options?.lockDecayThisTurn,\n    })\n  ),\n  addArmor: addArmorForSide,\n  restoreMana: restoreManaForSide,\n  heal: healForSide,\n  addRerollCharges: changeRerollCharges,\n  getRerollCharges,\n});\n\nconst triggerPlayerRelicLifecycleHooks = (\n  hookName: keyof Pick<NonNullable<RelicData['hooks']>, 'onBattleStart' | 'onTurnStart' | 'onTurnEnd' | 'onDeckShuffle'>,\n) => {\n  forEachPlayerRelic((entry, relic, state) => {\n    const hook = relic.hooks?.[hookName];\n    if (!hook) return;\n    hook(createPlayerLifecycleContext(relic, entry.count, state));\n  });\n};\n\nconst triggerPlayerRelicBeforeBurnDamageHooks = (\n  targetSide: RelicSide,\n  burnStacks: number,\n  damage: number,\n  turn: number,\n) => {\n  let currentDamage = Math.max(0, Math.floor(damage));\n  let isTrueDamage = false;\n  const target = getEntityBySide(targetSide);\n\n  forEachPlayerRelic((entry, relic, state) => {\n    const hook = relic.hooks?.onBeforeBurnDamage;\n    if (!hook) return;\n    const shared = createPlayerLifecycleContext(relic, entry.count, state);\n    const ctx: RelicBurnDamageHookContext = {\n      ...shared,\n      targetSide,\n      target,\n      turn,\n      burnStacks,\n      damage: currentDamage,\n      isTrueDamage,\n    };\n    hook(ctx);\n    currentDamage = Math.max(0, Math.floor(ctx.damage));\n    isTrueDamage = !!ctx.isTrueDamage;\n  });\n\n  return { damage: currentDamage, isTrueDamage };\n};\n\nconst triggerPlayerRelicAfterBurnDamageTakenHooks = (\n  targetSide: RelicSide,\n  burnStacks: number,\n  damage: number,\n  isTrueDamage: boolean,\n  turn: number,\n) => {\n  const target = getEntityBySide(targetSide);\n  forEachPlayerRelic((entry, relic, state) => {\n    const hook = relic.hooks?.onAfterBurnDamageTaken;\n    if (!hook) return;\n    const shared = createPlayerLifecycleContext(relic, entry.count, state);\n    const ctx: RelicAfterBurnDamageTakenHookContext = {\n      ...shared,\n      targetSide,\n      target,\n      turn,\n      burnStacks,\n      damage: Math.max(0, Math.floor(damage)),\n      isTrueDamage,\n    };\n    hook(ctx);\n  });\n};\n\nconst triggerPlayerRelicHitHooks = (\n  sourceSide: RelicSide,\n  targetSide: RelicSide,\n  card: CardData,\n  finalPoint: number,\n  hitIndex: number,\n  hitCount: number,\n  attemptedDamage: number,\n  actualDamage: number,\n) => {\n  const source = getEntityBySide(sourceSide);\n  const target = getEntityBySide(targetSide);\n\n  forEachPlayerRelic((entry, relic, state) => {\n    const shared = createPlayerLifecycleContext(relic, entry.count, state);\n    const ctx: RelicHitHookContext = {\n      ...shared,\n      sourceSide,\n      targetSide,\n      source,\n      target,\n      card,\n      finalPoint,\n      hitIndex,\n      hitCount,\n      attemptedDamage: Math.max(0, Math.floor(attemptedDamage)),\n      actualDamage: Math.max(0, Math.floor(actualDamage)),\n    };\n    relic.hooks?.onAfterHitDealt?.(ctx);\n    relic.hooks?.onAfterHitTaken?.(ctx);\n  });\n};\n\n// --- Helpers ---\nconst scaleDuration = (ms: number) => Math.max(60, Math.floor(ms / speedMultiplier.value));\nconst wait = (ms: number) => new Promise<void>((resolve) => setTimeout(resolve, scaleDuration(ms)));\nconst transitionStyle = (ms: number) => ({ transitionDuration: `${scaleDuration(ms)}ms` });\nconst withTransition = (style: Record<string, string>, ms: number) => ({\n  ...style,\n  transitionDuration: `${scaleDuration(ms)}ms`,\n});\nconst HP_BAR_ANIMATION_MS = 500;\nconst RESULT_DELAY_MS = 500;\nconst RESULT_BANNER_STAY_MS = 1500;\n\nconst playerPlayedCardStyle = computed(() => {\n  const visual = playerPlayedCardVisual.value;\n  const entered = !!visual?.entered;\n  return {\n    left: entered ? '29%' : '50%',\n    top: entered ? '23%' : '84%',\n    transform: `translate(-50%, -50%) scale(${entered ? 1 : 0.96})`,\n    opacity: entered ? '1' : '0',\n    transitionProperty: 'left, top, transform, opacity',\n    transitionDuration: `${scaleDuration(540)}ms`,\n    transitionTimingFunction: 'cubic-bezier(0.22, 0.9, 0.2, 1)',\n  };\n});\n\nconst resolvedCardVisualInnerClass = (visual: ResolvedCardVisual) => {\n  const sideClass = visual.source === 'player'\n    ? 'resolved-card-visual-inner--player'\n    : 'resolved-card-visual-inner--enemy';\n  const variantClass = visual.variant === 'attack'\n    ? 'resolved-card-visual-inner--attack'\n    : (visual.variant === 'self'\n      ? 'resolved-card-visual-inner--self'\n      : 'resolved-card-visual-inner--fade');\n  return `${sideClass} ${variantClass}`;\n};\n\nconst showEnemyIntentCard = computed(() => {\n  if (!combatState.value.enemyIntentCard) return false;\n  if (enemyIntentConsumedThisTurn.value) return false;\n  return !resolvedEnemyCardVisual.value;\n});\n\nconst floatingColors: Record<FloatingNumberKind, string> = {\n  physical: 'text-red-400 drop-shadow-[0_0_8px_rgba(248,113,113,0.85)]',\n  magic: 'text-red-400 drop-shadow-[0_0_8px_rgba(248,113,113,0.85)]',\n  shield: 'text-gray-300 drop-shadow-[0_0_8px_rgba(209,213,219,0.85)]',\n  heal: 'text-green-400 drop-shadow-[0_0_8px_rgba(74,222,128,0.85)]',\n  mana: 'text-blue-400 drop-shadow-[0_0_8px_rgba(96,165,250,0.85)]',\n  true: 'text-zinc-500 drop-shadow-[0_0_8px_rgba(39,39,42,0.9)]',\n};\n\nconst floatingNumbersFor = (side: BattleSide) => floatingNumbers.value.filter((entry) => entry.side === side);\nconst handCardKey = (card: CardData) => {\n  let key = handCardKeys.get(card);\n  if (!key) {\n    handCardKeySeed += 1;\n    key = `hand-${handCardKeySeed}`;\n    handCardKeys.set(card, key);\n  }\n  return key;\n};\n\nconst isCardShaking = (card: CardData) => invalidCardShakeKeys.value.has(handCardKey(card));\n\nconst triggerInvalidCardShake = (card: CardData) => {\n  const key = handCardKey(card);\n  const withoutKey = new Set(invalidCardShakeKeys.value);\n  withoutKey.delete(key);\n  invalidCardShakeKeys.value = withoutKey;\n\n  requestAnimationFrame(() => {\n    const next = new Set(invalidCardShakeKeys.value);\n    next.add(key);\n    invalidCardShakeKeys.value = next;\n    setTimeout(() => {\n      const removed = new Set(invalidCardShakeKeys.value);\n      removed.delete(key);\n      invalidCardShakeKeys.value = removed;\n    }, scaleDuration(360));\n  });\n};\n\nconst resolveTargetSide = (source: BattleSide, target: 'self' | 'enemy') => {\n  if (target === 'self') return source;\n  return source === 'player' ? 'enemy' : 'player';\n};\n\nconst removeCardsById = (cards: CardData[], cardId: string): CardData[] => (\n  cards.filter((card) => card.id !== cardId)\n);\n\nconst removeSingleCardById = (cards: CardData[], cardId: string): CardData[] => {\n  let removed = false;\n  return cards.filter((card) => {\n    if (!removed && card.id === cardId) {\n      removed = true;\n      return false;\n    }\n    return true;\n  });\n};\n\nconst insertCardIntoDeckRandomly = (deck: CardData[], card: CardData): CardData[] => {\n  const index = Math.floor(Math.random() * (deck.length + 1));\n  return [...deck.slice(0, index), card, ...deck.slice(index)];\n};\n\nconst applyPurgeTraitAfterUse = (source: BattleSide, card: CardData) => {\n  if (!card.traits.purgeOnUse) return;\n  if (source === 'player') {\n    combatState.value.discardPile = removeSingleCardById(combatState.value.discardPile, card.id);\n  } else {\n    combatState.value.enemyDeck = removeSingleCardById(combatState.value.enemyDeck, card.id);\n    combatState.value.enemyDiscard = removeSingleCardById(combatState.value.enemyDiscard, card.id);\n  }\n  log(`<span class=\"text-zinc-300\">【${card.name}】触发移除，自我销毁。</span>`);\n};\n\nconst applyInsertTrait = (source: BattleSide, card: CardData) => {\n  const toInsert = card.traits.insertCardsToEnemyDeck ?? [];\n  if (toInsert.length <= 0) return;\n  const sourceLabel = source === 'player' ? '我方' : '敌方';\n  const targetSide: BattleSide = source === 'player' ? 'enemy' : 'player';\n  for (const cardName of toInsert) {\n    const inserted = getCardByName(cardName);\n    if (!inserted) continue;\n    const battleCard = cloneCardForBattle(inserted);\n    if (targetSide === 'player') {\n      combatState.value.playerDeck = insertCardIntoDeckRandomly(combatState.value.playerDeck, battleCard);\n      log(`<span class=\"text-fuchsia-300\">${sourceLabel}【${card.name}】向对方牌库插入了【${cardName}】（牌库${combatState.value.playerDeck.length} / 弃牌${combatState.value.discardPile.length}）。</span>`);\n    } else {\n      combatState.value.enemyDeck = insertCardIntoDeckRandomly(combatState.value.enemyDeck, battleCard);\n      log(`<span class=\"text-fuchsia-300\">${sourceLabel}【${card.name}】向对方牌库插入了【${cardName}】（敌方牌库${combatState.value.enemyDeck.length} / 弃牌${combatState.value.enemyDiscard.length}）。</span>`);\n    }\n  }\n};\n\nconst destroyOpponentCardByTrait = (winnerSide: BattleSide, loserCard: CardData) => {\n  if (loserCard.id === PASS_CARD.id) return;\n  if (winnerSide === 'player') {\n    combatState.value.enemyDeck = removeCardsById(combatState.value.enemyDeck, loserCard.id);\n    combatState.value.enemyDiscard = removeCardsById(combatState.value.enemyDiscard, loserCard.id);\n  } else {\n    combatState.value.playerDeck = removeCardsById(combatState.value.playerDeck, loserCard.id);\n    combatState.value.playerHand = removeCardsById(combatState.value.playerHand, loserCard.id);\n    combatState.value.discardPile = removeCardsById(combatState.value.discardPile, loserCard.id);\n    if (combatState.value.playerSelectedCard?.id === loserCard.id) {\n      combatState.value.playerSelectedCard = null;\n    }\n  }\n  log(`<span class=\"text-violet-300\">【销毁】${loserCard.name}在本次战斗中被临时移除。</span>`);\n};\n\nconst applyShockOnManaLoss = (side: BattleSide, lostMp: number, reason: string) => {\n  const loss = Math.max(0, Math.floor(lostMp));\n  if (loss <= 0) return;\n\n  const target = side === 'player' ? playerStats.value : enemyStats.value;\n  const label = side === 'player' ? '我方' : '敌方';\n  const shockStacks = getEffectStacks(target, ET.SHOCK);\n  if (shockStacks <= 0) return;\n\n  const { actualDamage, logs: shockDamageLogs } = applyDamageToSideWithRelics(side, target, shockStacks, false, '电击');\n  if (actualDamage > 0) {\n    pushFloatingNumber(side, actualDamage, 'magic', '-');\n  }\n\n  const nextStacks = Math.max(0, shockStacks - 1);\n  if (nextStacks <= 0) {\n    removeEffect(target, ET.SHOCK);\n  } else {\n    const shockEffect = target.effects.find((effect) => effect.type === ET.SHOCK);\n    if (shockEffect) {\n      shockEffect.stacks = nextStacks;\n    }\n  }\n\n  log(`<span class=\"text-violet-300\">${label}因${reason}触发电击，损失 ${actualDamage} 点生命（电击 ${shockStacks}→${nextStacks}）。</span>`);\n  for (const dl of shockDamageLogs) {\n    const normalized = dl.startsWith('受到') ? `${label}${dl}` : dl;\n    log(`<span class=\"text-gray-500 text-[9px]\">${normalized}</span>`);\n  }\n  if (side === 'player' && actualDamage > 0 && target.hp <= 0) {\n    queuePlayerLethalNegativeStatus(PLAYER_SHOCK_LETHAL_NEGATIVE_STATUS, '电击');\n  }\n};\n\nconst changeManaWithShock = (\n  side: BattleSide,\n  delta: number,\n  reason: string,\n  options?: { requireEnoughForDecrease?: boolean; showPositiveFloating?: boolean },\n): { ok: boolean; actualDelta: number } => {\n  const value = Math.floor(delta);\n  if (value === 0) return { ok: true, actualDelta: 0 };\n\n  const target = side === 'player' ? playerStats.value : enemyStats.value;\n  const before = target.mp;\n\n  if (value < 0 && options?.requireEnoughForDecrease && before < -value) {\n    return { ok: false, actualDelta: 0 };\n  }\n\n  target.mp = Math.max(0, before + value);\n  const actualDelta = target.mp - before;\n\n  if (actualDelta > 0 && options?.showPositiveFloating !== false) {\n    pushFloatingNumber(side, actualDelta, 'mana', '+');\n  }\n  if (actualDelta < 0) {\n    applyShockOnManaLoss(side, -actualDelta, reason);\n  }\n  if (actualDelta > 0) {\n    tryTriggerModaoStabilizer(side, actualDelta, `${reason}，`);\n  }\n\n  return { ok: true, actualDelta };\n};\n\nconst spendManaWithShock = (side: BattleSide, amount: number, reason: string): boolean => {\n  const cost = Math.max(0, Math.floor(amount));\n  if (cost <= 0) return true;\n  return changeManaWithShock(side, -cost, reason, { requireEnoughForDecrease: true }).ok;\n};\n\nconst hasModaoWeaveBackupInPlayerHand = () => (\n  combatState.value.playerHand.some((entry) => entry.id === 'modao_weave_backup')\n);\n\nconst getSecondMagicCardInPlayerHand = (): CardData | null => {\n  let seen = 0;\n  for (const card of combatState.value.playerHand) {\n    if (card.type !== CardType.MAGIC) continue;\n    seen += 1;\n    if (seen === 2) return card;\n  }\n  return null;\n};\n\nconst getEffectiveManaCost = (side: BattleSide, card: CardData): number => {\n  const base = Math.max(0, Math.floor(card.manaCost ?? 0));\n  if (card.type !== CardType.MAGIC) return base;\n  if (side !== 'player') return base;\n\n  let discount = 0;\n  if (hasModaoWeaveBackupInPlayerHand()) {\n    discount += 1;\n  }\n\n  const hostCount = getActiveRelicCount('modao_arcane_host');\n  if (hostCount > 0 && getSecondMagicCardInPlayerHand() === card) {\n    discount += (2 * hostCount);\n  }\n\n  return Math.max(0, base - discount);\n};\n\nconst withEffectiveManaCost = (side: BattleSide, card: CardData): CardData => {\n  const manaCost = getEffectiveManaCost(side, card);\n  if (manaCost === card.manaCost) return card;\n  return { ...card, manaCost };\n};\n\nconst resolveCardSelfDamage = (\n  card: CardData,\n): { value: number; mode: 'fixed' | 'percent'; target: 'hp' | 'maxHp' } | null => {\n  const raw = card.selfDamage;\n  if (raw === undefined || raw === null) return null;\n\n  if (typeof raw === 'number') {\n    const amount = Math.max(0, Math.floor(raw));\n    if (amount <= 0) return null;\n    return { value: amount, mode: 'fixed', target: 'hp' };\n  }\n\n  const mode = raw.mode ?? 'fixed';\n  const target = raw.target ?? 'hp';\n  const baseAmount = Number.isFinite(raw.value) ? raw.value : 0;\n  if (baseAmount <= 0) return null;\n  if (mode === 'percent') {\n    return { value: baseAmount, mode: 'percent', target };\n  }\n  return { value: Math.max(0, Math.floor(baseAmount)), mode: 'fixed', target };\n};\n\nconst triggerBleedProc = (targetSide: BattleSide, reason: string): number => {\n  const target = targetSide === 'player' ? playerStats.value : enemyStats.value;\n  const targetLabel = targetSide === 'player' ? '我方' : '敌方';\n  const bleedStacks = Math.max(0, getEffectStacks(target, ET.BLEED));\n  if (bleedStacks <= 0) {\n    log(`<span class=\"text-gray-400\">[流血] ${reason}未触发：${targetLabel}当前无流血。</span>`);\n    return 0;\n  }\n\n  const { actualDamage, logs: bleedLogs } = applyDamageToSideWithRelics(targetSide, target, bleedStacks, true, '流血');\n  if (actualDamage > 0) {\n    pushFloatingNumber(targetSide, actualDamage, 'true', '-');\n  }\n  log(`<span class=\"text-rose-300\">[流血] ${reason}触发：${targetLabel}受到 ${actualDamage} 点真实伤害。</span>`);\n  for (const dl of bleedLogs) {\n    const normalized = dl.startsWith('受到') ? `${targetLabel}${dl}` : dl;\n    log(`<span class=\"text-gray-500 text-[9px]\">${normalized}</span>`);\n  }\n\n  if (targetSide === 'enemy' && actualDamage > 0) {\n    const feastCount = getActiveRelicCount('bloodpool_first_bleed_feast');\n    if (feastCount > 0 && !bloodpoolFirstBleedFeastTriggered.value) {\n      bloodpoolFirstBleedFeastTriggered.value = true;\n      const { healed } = healForSide('player', actualDamage * feastCount);\n      logRelicMessage(`[噬血水蛭] 敌方首次受到流血伤害，回复 ${healed} 点生命。`);\n    }\n  }\n\n  return actualDamage;\n};\n\nconst applyBloodbladeAttachOnClash = (sourceSide: BattleSide, targetSide: BattleSide) => {\n  const sourceStats = sourceSide === 'player' ? playerStats.value : enemyStats.value;\n  const stacks = getEffectStacks(sourceStats, ET.BLOODBLADE_ATTACH);\n  if (stacks <= 0) return;\n  applyStatusEffectWithRelics(targetSide, ET.BLEED, stacks, { source: 'effect:bloodblade_attach' });\n  const sourceLabel = sourceSide === 'player' ? '我方' : '敌方';\n  log(`<span class=\"text-rose-300\">${sourceLabel}[血刃附加] 为对方施加了 ${stacks} 层流血。</span>`);\n};\n\nconst applyLightningAttachOnDodge = (dodgerSide: BattleSide, targetSide: BattleSide) => {\n  const sourceStats = dodgerSide === 'player' ? playerStats.value : enemyStats.value;\n  const stacks = getEffectStacks(sourceStats, ET.LIGHTNING_ATTACH);\n  if (stacks <= 0) return;\n  applyStatusEffectWithRelics(targetSide, ET.SHOCK, stacks, { source: 'effect:lightning_attach' });\n  const sourceLabel = dodgerSide === 'player' ? '我方' : '敌方';\n  log(`<span class=\"text-indigo-300\">${sourceLabel}[雷电附加] 为对方施加了 ${stacks} 层电击。</span>`);\n};\n\nconst cardEffectMatchesTrigger = (effectTrigger: CardEffectTrigger[] | undefined, trigger: CardEffectTrigger) => {\n  if (!effectTrigger || effectTrigger.length === 0) return trigger === 'on_use';\n  return effectTrigger.includes(trigger);\n};\n\nconst applyCardEffectsByTrigger = (\n  source: BattleSide,\n  card: CardData,\n  finalPoint: number,\n  trigger: CardEffectTrigger = 'on_use',\n) => {\n  const attacker = source === 'player' ? playerStats.value : enemyStats.value;\n  const defender = source === 'player' ? enemyStats.value : playerStats.value;\n  const label = source === 'player' ? '我方' : '敌方';\n  let hasEffect = false;\n\n  for (const ce of card.cardEffects) {\n    if (!cardEffectMatchesTrigger(ce.triggers, trigger)) continue;\n\n    const targetKey = ce.target ?? 'self';\n    const targetEntity = targetKey === 'self' ? attacker : defender;\n    const targetSide = resolveTargetSide(source, targetKey);\n\n    if (ce.kind === 'heal') {\n      const healAmount = ce.valueMode === 'point_scale'\n        ? Math.floor(finalPoint * (ce.scale ?? 1))\n        : Math.floor(ce.fixedValue ?? 0);\n      const { healed } = healForSide(targetSide, healAmount);\n      log(`<span class=\"text-green-400\">${label}【${card.name}】回复了 ${healed} 点生命</span>`);\n      hasEffect = true;\n    } else if (ce.kind === 'apply_buff') {\n      const beforeMaxHp = targetEntity.maxHp;\n      const beforeHp = targetEntity.hp;\n      const stacks = ce.valueMode === 'point_scale'\n        ? Math.floor(finalPoint * (ce.scale ?? 1))\n        : ce.valueMode === 'max_hp_percent'\n          ? Math.floor(targetEntity.maxHp * (ce.scale ?? 0))\n          : Math.floor(ce.fixedValue ?? 1);\n      const applied = applyStatusEffectWithRelics(targetSide, ce.effectType!, stacks, {\n        restrictedTypes: ce.restrictedTypes,\n        source: card.id,\n        lockDecayThisTurn: ce.effectType === ET.BIND || ce.effectType === ET.SILENCE,\n      });\n      if (!applied) {\n        continue;\n      }\n      if (ce.effectType === ET.ARMOR) {\n        pushFloatingNumber(targetSide, stacks, 'shield', '+');\n        if (targetSide === 'player') {\n          handlePlayerArmorGainFromSingleEvent(stacks, `卡牌【${card.name}】`);\n        }\n      }\n      if (ce.effectType === ET.MAX_HP_REDUCTION) {\n        const actualMaxHpLoss = Math.max(0, beforeMaxHp - targetEntity.maxHp);\n        const hpLossByCap = Math.max(0, beforeHp - targetEntity.hp);\n        if (hpLossByCap > 0) {\n          pushFloatingNumber(targetSide, hpLossByCap, 'true', '-');\n        }\n        log(`<span class=\"text-fuchsia-300\">${label}【${card.name}】使目标生命上限 -${actualMaxHpLoss}${hpLossByCap > 0 ? `（当前生命 -${hpLossByCap}）` : ''}</span>`);\n      } else if (ce.effectType === ET.TEMP_MAX_HP) {\n        const actualMaxHpGain = Math.max(0, targetEntity.maxHp - beforeMaxHp);\n        log(`<span class=\"text-rose-300\">${label}【${card.name}】使目标临时生命上限 +${actualMaxHpGain}</span>`);\n      } else {\n        log(`<span class=\"text-yellow-400\">${label}【${card.name}】获得了 ${stacks} 层${EFFECT_REGISTRY[ce.effectType!]?.name ?? ce.effectType}</span>`);\n      }\n      hasEffect = true;\n    } else if (ce.kind === 'restore_mana') {\n      const restoreAmount = ce.valueMode === 'point_scale'\n        ? Math.floor(finalPoint * (ce.scale ?? 1))\n        : Math.floor(ce.fixedValue ?? 0);\n      const manaResult = changeManaWithShock(\n        targetSide,\n        restoreAmount,\n        `法力变化（${label}【${card.name}】）`,\n        { showPositiveFloating: true },\n      );\n      const actualRestore = Math.max(0, manaResult.actualDelta);\n      if (actualRestore > 0) {\n        log(`<span class=\"text-blue-400\">${label}【${card.name}】回复了 ${actualRestore} 点魔力</span>`);\n        hasEffect = true;\n      } else if (manaResult.actualDelta < 0) {\n        log(`<span class=\"text-blue-400\">${label}【${card.name}】使目标法力减少 ${Math.abs(manaResult.actualDelta)} 点</span>`);\n        hasEffect = true;\n      } else if (restoreAmount !== 0) {\n        log(`<span class=\"text-blue-400\">${label}【${card.name}】未造成法力变化</span>`);\n        hasEffect = true;\n      }\n    } else if (ce.kind === 'cleanse') {\n      const cleanseTargets = ce.cleanseTypes && ce.cleanseTypes.length > 0\n        ? ce.cleanseTypes\n        : targetEntity.effects.map((eff) => eff.type);\n      for (const et of cleanseTargets) {\n        removeEffect(targetEntity, et);\n      }\n      log(`<span class=\"text-cyan-300\">${label}【${card.name}】清除了负面效果</span>`);\n      hasEffect = true;\n    }\n  }\n\n  return hasEffect;\n};\n\nconst applyToxinSpreadOnPhysicalPlay = (source: BattleSide, card: CardData) => {\n  if (card.id === PASS_CARD.id || card.type !== CardType.PHYSICAL) return;\n\n  const spreadOwnerSide: BattleSide = source === 'player' ? 'enemy' : 'player';\n  const spreadOwner = spreadOwnerSide === 'player' ? playerStats.value : enemyStats.value;\n  const spreadStacks = getEffectStacks(spreadOwner, ET.TOXIN_SPREAD);\n  if (spreadStacks <= 0) return;\n\n  applyStatusEffectWithRelics(source, ET.POISON, spreadStacks, { source: 'effect:toxin_spread' });\n  const sourceLabel = source === 'player' ? '我方' : '敌方';\n  const spreadOwnerLabel = spreadOwnerSide === 'player' ? '我方' : '敌方';\n  log(`<span class=\"text-emerald-300\">${spreadOwnerLabel}[毒素蔓延] ${sourceLabel}打出物理牌，获得 ${spreadStacks} 层中毒。</span>`);\n};\n\nconst applyAmbushOnCardPlay = (source: BattleSide, card: CardData) => {\n  if (card.id === PASS_CARD.id) return;\n  if (card.type !== CardType.PHYSICAL && card.type !== CardType.DODGE) return;\n\n  const ambushOwnerSide: BattleSide = source === 'player' ? 'enemy' : 'player';\n  const ambushOwner = ambushOwnerSide === 'player' ? playerStats.value : enemyStats.value;\n  const ambushStacks = getEffectStacks(ambushOwner, ET.AMBUSH);\n  if (ambushStacks <= 0) return;\n\n  applyStatusEffectWithRelics(source, ET.BIND, 1, {\n    source: 'effect:ambush',\n    restrictedTypes: [CardType.PHYSICAL, CardType.DODGE],\n    lockDecayThisTurn: true,\n  });\n  reduceEffectStacks(ambushOwner, ET.AMBUSH, 1);\n\n  const sourceLabel = source === 'player' ? '我方' : '敌方';\n  const ambushOwnerLabel = ambushOwnerSide === 'player' ? '我方' : '敌方';\n  log(`<span class=\"text-violet-300\">${ambushOwnerLabel}[伏击] 触发：${sourceLabel}获得 1 层束缚。</span>`);\n};\n\nconst withFirstUseLightningAmbushBonus = (\n  source: BattleSide,\n  card: CardData,\n  options?: { consume?: boolean; announce?: boolean },\n): CardData => {\n  if (card.id !== 'enemy_vinewalker_lightning_ambush') return card;\n  if (lightningAmbushFirstUseConsumed.value[source]) return card;\n\n  const shouldConsume = options?.consume ?? true;\n  const shouldAnnounce = options?.announce ?? shouldConsume;\n  if (shouldConsume) {\n    lightningAmbushFirstUseConsumed.value[source] = true;\n  }\n  const boosted = cloneCardForBattle(card);\n  boosted.calculation.addition += 4;\n\n  if (shouldAnnounce) {\n    const sourceLabel = source === 'player' ? '我方' : '敌方';\n    log(`<span class=\"text-indigo-300\">${sourceLabel}【${card.name}】首次使用，点数 +4</span>`);\n  }\n  return boosted;\n};\n\nlet poisonAmountImmediateCheckRunning = false;\nconst applyImmediatePoisonAmountLethalCheck = (side: BattleSide) => {\n  const target = side === 'player' ? playerStats.value : enemyStats.value;\n  if (target.hp <= 0) return;\n\n  const poisonAmount = getEffectStacks(target, ET.POISON_AMOUNT);\n  if (poisonAmount <= 0 || poisonAmount < target.hp) return;\n\n  removeEffect(target, ET.POISON_AMOUNT);\n  const { actualDamage, logs: poisonLogs } = applyDamageToSideWithRelics(side, target, poisonAmount, true, '中毒量');\n  if (actualDamage > 0) {\n    pushFloatingNumber(side, actualDamage, 'true', '-');\n  }\n\n  const label = side === 'player' ? '我方' : '敌方';\n  log(`<span class=\"text-zinc-300\">${label}[中毒量] 即时致死判定触发，造成 ${actualDamage} 点真实伤害</span>`);\n  for (const poisonLog of poisonLogs) {\n    const normalized = poisonLog.startsWith('受到') ? `${label}${poisonLog}` : poisonLog;\n    log(`<span class=\"text-gray-500 text-[9px]\">${normalized}</span>`);\n  }\n  if (side === 'player' && actualDamage > 0 && target.hp <= 0) {\n    queuePlayerLethalNegativeStatus(PLAYER_POISON_LETHAL_NEGATIVE_STATUS, '中毒量致死判定');\n  }\n};\n\nconst rollIntInRange = (min: number, max: number) => {\n  const low = Math.floor(Math.min(min, max));\n  const high = Math.floor(Math.max(min, max));\n  if (high <= low) return low;\n  return Math.floor(Math.random() * (high - low + 1)) + low;\n};\n\nconst applyFatigueDegreePenaltyOnTurnStart = () => {\n  const current = fatigueDegree.value;\n  if (current < 200) return false;\n\n  if (current >= 300) {\n    playerStats.value.maxHp = 0;\n    playerStats.value.hp = 0;\n    log('<span class=\"text-red-400\">[疲劳度] 已达到 300，生命上限归零，直接战败。</span>');\n    return true;\n  }\n\n  const fatigueStacks = rollIntInRange(1, 3);\n  applyStatusEffectWithRelics('player', ET.FATIGUE, fatigueStacks, { source: 'system:fatigue_degree' });\n  log(`<span class=\"text-amber-300\">[疲劳度] 回合开始获得 ${fatigueStacks} 层疲劳。</span>`);\n\n  if (current >= 200) {\n    const poisonStacks = rollIntInRange(1, 2);\n    applyStatusEffectWithRelics('player', ET.POISON, poisonStacks, { source: 'system:fatigue_degree' });\n    log(`<span class=\"text-emerald-300\">[疲劳度] 额外获得 ${poisonStacks} 层中毒。</span>`);\n  }\n\n  return false;\n};\n\nconst queueCardNegativeEffectForPlayer = (source: BattleSide, card: CardData) => {\n  if (source !== 'enemy') return;\n  const negativeEffect = (card.negativeEffect ?? '').trim();\n  if (!negativeEffect) return;\n  pendingCardNegativeEffects.value.push(negativeEffect);\n  log(`<span class=\"text-fuchsia-300\">我方获得负面效果：${negativeEffect}</span>`);\n};\n\nconst applyHitAttachEffects = (\n  source: BattleSide,\n  card: CardData,\n  attacker: EntityStats,\n  defenderSide: RelicSide,\n) => {\n  const flameStacks = getEffectStacks(attacker, ET.FLAME_ATTACH);\n  if (flameStacks > 0 && (card.type === CardType.PHYSICAL || card.type === CardType.MAGIC)) {\n    applyStatusEffectWithRelics(defenderSide, ET.BURN, flameStacks, { source: 'effect:flame_attach' });\n  }\n\n  const poisonStacks = getEffectStacks(attacker, ET.POISON_ATTACH);\n  if (poisonStacks > 0 && card.type === CardType.MAGIC) {\n    applyStatusEffectWithRelics(defenderSide, ET.POISON, poisonStacks, { source: 'effect:poison_attach' });\n  }\n\n  const totalApplied = flameStacks + (card.type === CardType.MAGIC ? poisonStacks : 0);\n  if (totalApplied > 0) {\n    const label = source === 'player' ? '我方' : '敌方';\n    log(`<span class=\"text-orange-300\">${label}[附加效果] 命中后追加了状态效果。</span>`);\n  }\n};\n\nconst consumeChargeOnRoll = (stats: EntityStats, label: string, rolled: number) => {\n  let next = rolled;\n\n  const chargeStacks = getEffectStacks(stats, ET.CHARGE);\n  if (chargeStacks > 0) {\n    removeEffect(stats, ET.CHARGE);\n    next = Math.max(0, Math.floor(next + chargeStacks));\n    log(`<span class=\"text-cyan-300\">${label}[蓄力] +${chargeStacks}，原始骰子 ${rolled} → ${next}</span>`);\n  }\n\n  const fatigueStacks = getEffectStacks(stats, ET.FATIGUE);\n  if (fatigueStacks > 0) {\n    removeEffect(stats, ET.FATIGUE);\n    const reduced = Math.max(0, Math.floor(next - fatigueStacks));\n    log(`<span class=\"text-amber-300\">${label}[疲劳] -${fatigueStacks}，骰子 ${next} → ${reduced}</span>`);\n    next = reduced;\n  }\n\n  return next;\n};\n\nconst clearDicePreview = () => {\n  previewPlayerDice.value = null;\n  previewEnemyDice.value = null;\n  playerDicePreviewLines.value = [];\n  enemyDicePreviewLines.value = [];\n  playerDicePreviewCardName.value = '';\n  enemyDicePreviewCardName.value = '';\n  if (hoverPreviewTimer) {\n    clearTimeout(hoverPreviewTimer);\n    hoverPreviewTimer = null;\n  }\n  if (enemyDicePreviewTimer) {\n    clearTimeout(enemyDicePreviewTimer);\n    enemyDicePreviewTimer = null;\n  }\n};\n\nconst clearPlayerPlayedCard = () => {\n  playerPlayedCardVisual.value = null;\n};\n\nconst clearResolvedCardVisual = () => {\n  resolvedPlayerCardVisual.value = null;\n  resolvedEnemyCardVisual.value = null;\n};\n\nconst stopAllCardAnimations = () => {\n  animationStopToken += 1;\n  clearPlayerPlayedCard();\n  clearResolvedCardVisual();\n  impactShake.value = false;\n  showClashAnimation.value = false;\n  shatteringTarget.value = null;\n};\n\nconst showPlayerPlayedCard = (card: CardData) => {\n  if (endCombatPending.value) return;\n  const token = animationStopToken;\n  const id = ++playerPlayedCardVisualId;\n  playerPlayedCardVisual.value = { id, card, entered: false };\n  requestAnimationFrame(() => {\n    if (token !== animationStopToken || endCombatPending.value) return;\n    if (playerPlayedCardVisual.value?.id === id) {\n      playerPlayedCardVisual.value.entered = true;\n    }\n  });\n};\n\nconst playResolvedCardAnimation = async (source: BattleSide, card: CardData) => {\n  if (card.id === PASS_CARD.id || endCombatPending.value) return;\n\n  const token = animationStopToken;\n\n  const variant: ResolvedCardAnimVariant =\n    (card.type === CardType.PHYSICAL || card.type === CardType.MAGIC)\n      ? 'attack'\n      : (card.type === CardType.DODGE ? 'fade' : 'self');\n  const id = ++resolvedCardVisualId;\n  const slot = source === 'player' ? resolvedPlayerCardVisual : resolvedEnemyCardVisual;\n  slot.value = { id, source, card, variant };\n\n  if (variant === 'attack') {\n    const impactDelay = scaleDuration(720);\n    setTimeout(() => {\n      if (token !== animationStopToken || endCombatPending.value) return;\n      impactShake.value = true;\n      setTimeout(() => {\n        if (token !== animationStopToken) return;\n        impactShake.value = false;\n      }, scaleDuration(220));\n    }, impactDelay);\n  }\n\n  const animDuration = variant === 'attack' ? 930 : 570;\n  await wait(animDuration);\n  if (token !== animationStopToken || endCombatPending.value) return;\n  if (slot.value?.id === id) {\n    slot.value = null;\n  }\n};\n\nconst getCardFinalPoint = (\n  source: 'player' | 'enemy',\n  card: CardData,\n  baseDice: number,\n  isPreview: boolean = false,\n) => {\n  const attacker = source === 'player' ? playerStats.value : enemyStats.value;\n  const defender = source === 'player' ? enemyStats.value : playerStats.value;\n\n  let finalPoint = calculateFinalPoint({\n    baseDice,\n    card,\n    entityEffects: attacker.effects,\n    relicModifiers: NO_RELIC_MOD,\n  });\n\n  // 卡牌专属点数修正：敌方每有2层燃烧，点数+1\n  if (card.id === 'burn_inferno_judgement') {\n    finalPoint += Math.floor(getEffectStacks(defender, ET.BURN) / 2);\n  }\n  // 血债重击：自身每损失3点生命，点数+1\n  if (card.id === 'bloodpool_blood_debt_strike') {\n    const lostHp = Math.max(0, Math.floor(attacker.maxHp - attacker.hp));\n    finalPoint += Math.floor(lostHp / 3);\n  }\n\n  if (source === 'player') {\n    forEachPlayerRelic((entry, relic, state) => {\n      const hook = relic.hooks?.modifyFinalPoint;\n      if (!hook) return;\n      const ctx: RelicPointHookContext = {\n        count: entry.count,\n        side: 'player',\n        card,\n        baseDice,\n        currentPoint: finalPoint,\n        self: attacker,\n        opponent: defender,\n        state,\n        isPreview,\n        addLog: logRelicMessage,\n        hasRelic: hasActiveRelic,\n        getRelicCount: getActiveRelicCount,\n      };\n      finalPoint = hook(ctx);\n    });\n  }\n\n  return Math.max(0, Math.floor(finalPoint));\n};\n\nconst formatPointValue = (value: number): string => {\n  const rounded = Math.round(value * 100) / 100;\n  if (Number.isInteger(rounded)) return String(Math.trunc(rounded));\n  return rounded.toFixed(2).replace(/\\.?0+$/, '');\n};\n\nconst formatRelicPointDelta = (relicId: string, before: number, after: number): string => {\n  if (relicId === 'modao_witch_hat' && Math.abs(before) > 0.0001) {\n    return `x${formatPointValue(after / before)}（${formatPointValue(before)}→${formatPointValue(after)}）`;\n  }\n  const delta = after - before;\n  if (Math.abs(delta) < 0.0001) return '±0';\n  const roundedInt = Math.round(delta);\n  if (Math.abs(delta - roundedInt) < 0.0001) {\n    return `${roundedInt >= 0 ? '+' : ''}${roundedInt}（${formatPointValue(before)}→${formatPointValue(after)}）`;\n  }\n  return `${delta >= 0 ? '+' : ''}${formatPointValue(delta)}（${formatPointValue(before)}→${formatPointValue(after)}）`;\n};\n\nconst buildCardPreviewLines = (source: 'player' | 'enemy', card: CardData, baseDice: number): string[] => {\n  const attacker = source === 'player' ? playerStats.value : enemyStats.value;\n  const defender = source === 'player' ? enemyStats.value : playerStats.value;\n  const lines: string[] = [];\n\n  lines.push(`原始：${baseDice}`);\n  let finalPoint = calculateFinalPoint({\n    baseDice,\n    card,\n    entityEffects: attacker.effects,\n    relicModifiers: NO_RELIC_MOD,\n  });\n  const multiplierText = formatPointValue(card.calculation.multiplier);\n  const addition = card.calculation.addition;\n  const additionText = addition >= 0 ? `+${addition}` : `${addition}`;\n  lines.push(`卡牌修正 x${multiplierText} ${additionText} => ${finalPoint}`);\n\n  if (card.id === 'burn_inferno_judgement') {\n    const bonus = Math.floor(getEffectStacks(defender, ET.BURN) / 2);\n    if (bonus > 0) {\n      finalPoint += bonus;\n      lines.push(`炎狱判决 +${bonus} => ${finalPoint}`);\n    }\n  }\n  if (card.id === 'bloodpool_blood_debt_strike') {\n    const lostHp = Math.max(0, Math.floor(attacker.maxHp - attacker.hp));\n    const bonus = Math.floor(lostHp / 3);\n    if (bonus > 0) {\n      finalPoint += bonus;\n      lines.push(`血债重击（已损失${lostHp}） +${bonus} => ${finalPoint}`);\n    }\n  }\n\n  if (source === 'player') {\n    forEachPlayerRelic((entry, relic, state) => {\n      const hook = relic.hooks?.modifyFinalPoint;\n      if (!hook) return;\n      const before = finalPoint;\n      const ctx: RelicPointHookContext = {\n        count: entry.count,\n        side: 'player',\n        card,\n        baseDice,\n        currentPoint: finalPoint,\n        self: attacker,\n        opponent: defender,\n        state,\n        isPreview: true,\n        addLog: logRelicMessage,\n        hasRelic: hasActiveRelic,\n        getRelicCount: getActiveRelicCount,\n      };\n      finalPoint = hook(ctx);\n      if (Math.abs(finalPoint - before) < 0.0001) return;\n      lines.push(`${relic.name} ${formatRelicPointDelta(relic.id, before, finalPoint)} => ${formatPointValue(finalPoint)}`);\n    });\n  }\n\n  lines.push(`最终：${Math.max(0, Math.floor(finalPoint))}`);\n  return lines;\n};\n\nconst getCardPreviewPoint = (source: 'player' | 'enemy', card: CardData, baseDice: number) => {\n  return getCardFinalPoint(source, card, baseDice, true);\n};\n\nconst handlePlayerCardHoverStart = (card: CardData) => {\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n  previewPlayerDice.value = getCardPreviewPoint('player', card, combatState.value.playerBaseDice);\n  playerDicePreviewCardName.value = card.name;\n  playerDicePreviewLines.value = buildCardPreviewLines('player', card, combatState.value.playerBaseDice);\n};\n\nconst handlePlayerCardHoverEnd = () => {\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n  previewPlayerDice.value = null;\n  playerDicePreviewCardName.value = '';\n  playerDicePreviewLines.value = [];\n};\n\nconst handlePlayerCardTouchStart = (card: CardData) => {\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n  if (hoverPreviewTimer) clearTimeout(hoverPreviewTimer);\n  hoverPreviewTimer = setTimeout(() => {\n    if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n    previewPlayerDice.value = getCardPreviewPoint('player', card, combatState.value.playerBaseDice);\n    playerDicePreviewCardName.value = card.name;\n    playerDicePreviewLines.value = buildCardPreviewLines('player', card, combatState.value.playerBaseDice);\n  }, 260);\n};\n\nconst handlePlayerCardTouchEnd = () => {\n  if (hoverPreviewTimer) {\n    clearTimeout(hoverPreviewTimer);\n    hoverPreviewTimer = null;\n  }\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n  previewPlayerDice.value = null;\n  playerDicePreviewCardName.value = '';\n  playerDicePreviewLines.value = [];\n};\n\nconst rollDiceInRange = (min: number, max: number) => {\n  const low = Math.floor(Math.min(min, max));\n  const high = Math.floor(Math.max(min, max));\n  if (high <= low) return low;\n  return Math.floor(Math.random() * (high - low + 1)) + low;\n};\n\nconst handlePlayerDiceClick = () => {\n  if (!canPlayerRerollDice.value) return;\n\n  const chargesBeforeHooks = getRerollCharges('player');\n  let rerolled: number | null = null;\n  forEachPlayerRelic((entry, relic, state) => {\n    if (rerolled !== null) return;\n    const hook = relic.hooks?.onDiceClick;\n    if (!hook) return;\n    const ctx: RelicDiceClickHookContext = {\n      count: entry.count,\n      side: 'player',\n      currentDice: combatState.value.playerBaseDice,\n      minDice: playerStats.value.minDice,\n      maxDice: playerStats.value.maxDice,\n      state,\n      roll: rollDiceInRange,\n      consumeRerollCharge,\n      getRerollCharges,\n      addLog: logRelicMessage,\n    };\n    rerolled = hook(ctx);\n  });\n\n  if (rerolled === null) {\n    if (getRerollCharges('player') < chargesBeforeHooks) return;\n    if (!consumeRerollCharge('player', 1)) return;\n    rerolled = rollDiceInRange(playerStats.value.minDice, playerStats.value.maxDice);\n    log(`<span class=\"text-amber-300\">[基础重掷] 消耗1次重掷，剩余 ${getRerollCharges('player')} 次。</span>`);\n  }\n\n  const before = combatState.value.playerBaseDice;\n  const after = consumeChargeOnRoll(playerStats.value, '我方', Math.max(0, Math.floor(rerolled)));\n  combatState.value.playerBaseDice = after;\n  previewPlayerDice.value = null;\n  log(`<span class=\"text-amber-200\">我方骰子重掷：${before} → ${after}</span>`);\n};\n\nconst canPreviewEnemyDice = () => {\n  return (\n    combatState.value.phase === CombatPhase.PLAYER_INPUT &&\n    !isRolling.value &&\n    !showClashAnimation.value &&\n    !!combatState.value.enemyIntentCard\n  );\n};\n\nconst showEnemyDicePreview = () => {\n  if (!canPreviewEnemyDice()) return;\n  const card = combatState.value.enemyIntentCard;\n  if (!card) return;\n  const previewCard = withFirstUseLightningAmbushBonus('enemy', card, {\n    consume: false,\n    announce: false,\n  });\n  const preview = getCardPreviewPoint('enemy', previewCard, combatState.value.enemyBaseDice);\n  if (preview === null) return;\n  previewEnemyDice.value = preview;\n  enemyDicePreviewCardName.value = previewCard.name;\n  enemyDicePreviewLines.value = buildCardPreviewLines('enemy', previewCard, combatState.value.enemyBaseDice);\n};\n\nconst hideEnemyDicePreview = () => {\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n  if (showClashAnimation.value) return;\n  previewEnemyDice.value = null;\n  enemyDicePreviewCardName.value = '';\n  enemyDicePreviewLines.value = [];\n};\n\nconst handleEnemyDiceHoverStart = () => {\n  showEnemyDicePreview();\n};\n\nconst handleEnemyDiceHoverEnd = () => {\n  hideEnemyDicePreview();\n};\n\nconst handleEnemyDiceTouchStart = () => {\n  if (enemyDicePreviewTimer) {\n    clearTimeout(enemyDicePreviewTimer);\n    enemyDicePreviewTimer = null;\n  }\n  enemyDicePreviewTimer = setTimeout(() => {\n    showEnemyDicePreview();\n  }, 260);\n};\n\nconst handleEnemyDiceTouchEnd = () => {\n  if (enemyDicePreviewTimer) {\n    clearTimeout(enemyDicePreviewTimer);\n    enemyDicePreviewTimer = null;\n  }\n  hideEnemyDicePreview();\n};\n\nconst clearEffectTooltipTimers = () => {\n  if (effectTooltipLongPressTimer) {\n    clearTimeout(effectTooltipLongPressTimer);\n    effectTooltipLongPressTimer = null;\n  }\n  if (effectTooltipAutoHideTimer) {\n    clearTimeout(effectTooltipAutoHideTimer);\n    effectTooltipAutoHideTimer = null;\n  }\n};\n\nconst showEffectTooltipForTarget = (target: HTMLElement, effect: EffectInstance, align: TooltipAlign = 'center') => {\n  const rootRect = combatRootEl.value?.getBoundingClientRect();\n  if (!rootRect) return;\n\n  const rect = target.getBoundingClientRect();\n  const top = Math.max(8, rect.top - rootRect.top - 8);\n  const tooltipMaxWidth = 256;\n  const x = align === 'right'\n    ? Math.max(8, Math.min(rect.right - rootRect.left + 10, rootRect.width - tooltipMaxWidth - 8))\n    : Math.max(100, Math.min(rect.left + rect.width / 2 - rootRect.left, rootRect.width - 100));\n  effectTooltip.value = {\n    x,\n    y: top,\n    name: getEffectName(effect.type),\n    description: getEffectDescription(effect.type),\n    stacks: effect.stacks,\n    align,\n  };\n};\n\nconst showEffectTooltip = (\n  event: MouseEvent | FocusEvent,\n  effect: EffectInstance,\n  align: TooltipAlign = 'center',\n) => {\n  const target = event.currentTarget as HTMLElement | null;\n  if (!target) return;\n  clearEffectTooltipTimers();\n  showEffectTooltipForTarget(target, effect, align);\n};\n\nconst hideEffectTooltip = () => {\n  clearEffectTooltipTimers();\n  effectTooltip.value = null;\n};\n\nconst handleEffectTouchStart = (\n  event: TouchEvent,\n  effect: EffectInstance,\n  align: TooltipAlign = 'center',\n) => {\n  const target = event.currentTarget as HTMLElement | null;\n  if (!target) return;\n\n  clearEffectTooltipTimers();\n  effectTooltipLongPressTimer = setTimeout(() => {\n    showEffectTooltipForTarget(target, effect, align);\n    effectTooltipAutoHideTimer = setTimeout(() => {\n      effectTooltip.value = null;\n      effectTooltipAutoHideTimer = null;\n    }, scaleDuration(1800));\n  }, scaleDuration(320));\n};\n\nconst handleEffectTouchEnd = () => {\n  if (effectTooltipLongPressTimer) {\n    clearTimeout(effectTooltipLongPressTimer);\n    effectTooltipLongPressTimer = null;\n  }\n};\n\nconst pushFloatingNumber = (side: BattleSide, value: number, kind: FloatingNumberKind, sign: '+' | '-' = '+') => {\n  const amount = Math.max(0, Math.floor(value));\n  if (amount <= 0) return;\n\n  const id = ++floatingNumberId;\n  const duration = kind === 'heal' ? scaleDuration(1800) : scaleDuration(1350);\n  floatingNumbers.value.push({\n    id,\n    side,\n    kind,\n    text: `${sign}${amount}`,\n    colorClass: floatingColors[kind],\n    leftOffset: Math.floor((Math.random() - 0.5) * 120),\n    topOffset: 24 + Math.floor(Math.random() * 20),\n    duration,\n  });\n\n  setTimeout(() => {\n    floatingNumbers.value = floatingNumbers.value.filter((entry) => entry.id !== id);\n  }, duration);\n};\n\nconst pushFloatingText = (\n  side: BattleSide,\n  text: string,\n  colorClass: string = 'text-sky-300',\n  duration: number = scaleDuration(1050),\n) => {\n  const id = ++floatingNumberId;\n  floatingNumbers.value.push({\n    id,\n    side,\n    text,\n    colorClass,\n    leftOffset: Math.floor((Math.random() - 0.5) * 90),\n    topOffset: 18 + Math.floor(Math.random() * 18),\n    duration,\n  });\n  setTimeout(() => {\n    floatingNumbers.value = floatingNumbers.value.filter((entry) => entry.id !== id);\n  }, duration);\n};\n\nconst notifyEnemyManaInsufficient = () => {\n  if (enemyManaLackHintTurn === combatState.value.turn) return;\n  enemyManaLackHintTurn = combatState.value.turn;\n  pushFloatingText('enemy', '魔力不足', 'text-blue-300');\n  log('<span class=\"text-blue-300\">敌方魔力不足，本回合视为跳过。</span>');\n};\n\nconst log = (msg: string) => {\n  combatState.value.logs = [msg, ...combatState.value.logs].slice(0, 240);\n};\n\nif (activePlayerRelics.length > 0) {\n  const relicSummary = activePlayerRelics\n    .map((entry) => (entry.count > 1 ? `${entry.relic.name}x${entry.count}` : entry.relic.name))\n    .join('、');\n  log(`<span class=\"text-amber-300\">本场圣遗物：${relicSummary}</span>`);\n}\ntriggerPlayerRelicLifecycleHooks('onBattleStart');\n\nonMounted(() => {\n  battleSpeedUp.value = localStorage.getItem(SPEED_SETTING_KEY) === '1';\n  loadFatigueDegree();\n  addFatigueDegree(10);\n  void initPortraitUrls();\n});\nonUnmounted(() => {\n  portraitLoaderDisposed = true;\n  if (hoverPreviewTimer) {\n    clearTimeout(hoverPreviewTimer);\n    hoverPreviewTimer = null;\n  }\n  if (enemyDicePreviewTimer) {\n    clearTimeout(enemyDicePreviewTimer);\n    enemyDicePreviewTimer = null;\n  }\n  clearEffectTooltipTimers();\n});\nwatch(battleSpeedUp, (enabled) => {\n  localStorage.setItem(SPEED_SETTING_KEY, enabled ? '1' : '0');\n});\nwatch(\n  [\n    () => combatState.value.phase,\n    () => combatState.value.turn,\n    () => combatState.value.playerBaseDice,\n    () => combatState.value.enemyBaseDice,\n    isPlayerDiceObscured,\n    isEnemyDiceObscured,\n  ],\n  () => {\n    playerDiceUiNoise.value = isPlayerDiceObscured.value ? rerollUiNoise() : 0;\n    enemyDiceUiNoise.value = isEnemyDiceObscured.value ? rerollUiNoise() : 0;\n  },\n  { immediate: true },\n);\n\nconst drawCards = (count: number, currentDeck: CardData[], currentDiscard: CardData[]) => {\n  let deck = [...currentDeck];\n  let discard = [...currentDiscard];\n  const drawn: CardData[] = [];\n\n  for (let i = 0; i < count; i++) {\n    if (deck.length === 0) {\n      if (discard.length === 0) break;\n      deck = [...discard].sort(() => Math.random() - 0.5);\n      discard = [];\n      triggerPlayerRelicLifecycleHooks('onDeckShuffle');\n    }\n    const card = deck.pop();\n    if (card) drawn.push(card);\n  }\n  return { drawn, newDeck: deck, newDiscard: discard };\n};\n\nconst handCardClass = (card: CardData) => {\n  const selected = combatState.value.playerSelectedCard;\n  const isSelected = selected === card;\n  const isNotSelected = selected && !isSelected;\n  const isActionPhase = combatState.value.phase === CombatPhase.PLAYER_INPUT;\n\n  return [\n    isSelected ? '-translate-y-12 scale-110 z-50 ring-2 ring-dungeon-gold rounded-lg shadow-[0_0_30px_#d4af37]' : '',\n    isNotSelected ? 'opacity-30 scale-90 translate-y-8 grayscale' : 'hover:scale-110 hover:-translate-y-4 hover:z-50',\n    !isActionPhase && !isSelected ? 'opacity-50 grayscale cursor-not-allowed' : 'cursor-pointer',\n  ];\n};\n\nconst getDisplayHandCard = (card: CardData): CardData => withEffectiveManaCost('player', card);\n\n// --- Enemy AI Card Selection ---\nfunction selectEnemyCard(): CardData {\n  // 眩晕中的敌方本回合直接跳过\n  if (getEffectStacks(enemyStats.value, ET.STUN) > 0) {\n    log('<span class=\"text-gray-400\">敌方处于眩晕，跳过回合。</span>');\n    return PASS_CARD;\n  }\n\n  if (combatState.value.enemyDeck.length === 0) {\n    if (combatState.value.enemyDiscard.length === 0) return PASS_CARD; // Fallback\n    combatState.value.enemyDeck = [...combatState.value.enemyDiscard].sort(() => Math.random() - 0.5);\n    combatState.value.enemyDiscard = [];\n  }\n\n  let selectedCard: CardData;\n  if (enemyDef) {\n    // Use the enemy's custom AI logic\n    const ctx: EnemyAIContext = {\n      enemyStats: enemyStats.value,\n      playerStats: playerStats.value,\n      deck: combatState.value.enemyDeck,\n      turn: combatState.value.turn,\n      flags: aiFlags,\n    };\n    selectedCard = enemyDef.selectCard(ctx);\n  } else {\n    // Fallback: random selection (should never happen with proper registry)\n    const idx = Math.floor(Math.random() * combatState.value.enemyDeck.length);\n    selectedCard = combatState.value.enemyDeck[idx]!;\n  }\n\n  const check = canPlayCard(enemyStats.value, selectedCard, enemyTurnRawDice.value);\n  if (!check.allowed) {\n    log(`<span class=\"text-gray-400\">敌方无法出牌：${check.reason ?? '本回合跳过。'}</span>`);\n    return PASS_CARD;\n  }\n  return selectedCard;\n}\n\n// --- Phase Management ---\n\nconst startTurn = () => {\n  if (endCombatPending.value) return;\n  log(`<span class=\"text-slate-300\">——第${combatState.value.turn}回合——</span>`);\n  enemyManaLackHintTurn = -1;\n  if (sealCircuitPendingMana.value > 0) {\n    const pending = sealCircuitPendingMana.value;\n    sealCircuitPendingMana.value = 0;\n    const restored = restoreManaForSide('player', pending);\n    if (restored > 0) {\n      logRelicMessage(`[封存回路] 释放储能，回复 ${restored} 点魔力。`);\n    }\n  }\n  const reverseCircuitCount = getActiveRelicCount('burn_reverse_circuit');\n  if (reverseCircuitCount > 0 && getEffectStacks(playerStats.value, ET.BURN) > 0) {\n    const hpLoss = Math.min(playerStats.value.hp, reverseCircuitCount);\n    let actualHpLoss = 0;\n    if (hpLoss > 0) {\n      actualHpLoss = applyDirectHpLossWithRelics('player', playerStats.value, hpLoss, '逆燃回路');\n      pushFloatingNumber('player', actualHpLoss, 'true', '-');\n      addPlayerDamageTakenThisTurn(actualHpLoss);\n    }\n    const restored = restoreManaForSide('player', reverseCircuitCount);\n    logRelicMessage(`[逆燃回路] 检测到自身燃烧，失去 ${actualHpLoss} 点生命并回复 ${restored} 点魔力。`);\n    if (playerStats.value.hp <= 0) return;\n  }\n  const scaleRingCount = getActiveRelicCount('modao_scale_ring');\n  if (scaleRingCount > 0 && combatState.value.turn % 3 === 0) {\n    const restored = restoreManaForSide('player', scaleRingCount);\n    if (restored > 0) {\n      logRelicMessage(`[刻度环] 第 ${combatState.value.turn} 回合触发，回复 ${restored} 点魔力。`);\n    }\n  }\n  clearDicePreview();\n  stopAllCardAnimations();\n  combatState.value.phase = CombatPhase.DRAW_PHASE;\n  combatState.value.playerSelectedCard = null;\n  combatState.value.enemyIntentCard = null;\n  enemyIntentConsumedThisTurn.value = false;\n  enemyIntentManaSpentThisTurn.value = false;\n  isRolling.value = true;\n  shatteringTarget.value = null;\n  showClashAnimation.value = false;\n  triggerPlayerRelicLifecycleHooks('onTurnStart');\n  const pulseMarkCount = getActiveRelicCount('bloodpool_pulse_mark');\n  if (pulseMarkCount > 0 && playerStats.value.hp > 0) {\n    const pulseDamage = Math.max(0, pulseMarkCount * 2);\n    if (pulseDamage > 0) {\n      const { actualDamage, logs: pulseLogs } = applyDamageToSideWithRelics('player', playerStats.value, pulseDamage, true, '脉搏印记');\n      if (actualDamage > 0) {\n        pushFloatingNumber('player', actualDamage, 'true', '-');\n        addPlayerDamageTakenThisTurn(actualDamage);\n        logRelicMessage(`[脉搏印记] 回合开始受到 ${actualDamage} 点真实伤害。`);\n        triggerPlayerRelicHitHooks(\n          'enemy',\n          'player',\n          PASS_CARD,\n          0,\n          1,\n          1,\n          actualDamage,\n          actualDamage,\n        );\n      }\n      for (const pulseLog of pulseLogs) {\n        const normalized = pulseLog.startsWith('受到') ? `我方${pulseLog}` : pulseLog;\n        log(`<span class=\"text-gray-500 text-[9px]\">${normalized}</span>`);\n      }\n      if (playerStats.value.hp <= 0) return;\n    }\n  }\n\n  setTimeout(() => {\n    if (endCombatPending.value) return;\n    const pRawRoll = Math.floor(Math.random() * (playerStats.value.maxDice - playerStats.value.minDice + 1)) + playerStats.value.minDice;\n    const eRawRoll = Math.floor(Math.random() * (enemyStats.value.maxDice - enemyStats.value.minDice + 1)) + enemyStats.value.minDice;\n    const pRoll = consumeChargeOnRoll(playerStats.value, '我方', pRawRoll);\n    const eRoll = consumeChargeOnRoll(enemyStats.value, '敌方', eRawRoll);\n    playerTurnRawDice.value = pRawRoll;\n    enemyTurnRawDice.value = eRawRoll;\n\n    isRolling.value = false;\n    combatState.value.playerBaseDice = pRoll;\n    combatState.value.enemyBaseDice = eRoll;\n    combatState.value.phase = CombatPhase.DRAW_PHASE;\n    log(`掷骰结果：我方 [${pRoll}] vs 敌方 [${eRoll}]`);\n  }, scaleDuration(1500));\n};\n\n// Watch for INIT phase\nwatch(\n  () => combatState.value.phase,\n  (phase) => {\n     if (endCombatPending.value) return;\n     if (phase === CombatPhase.TURN_START) {\n      playerDamageTakenThisTurn.value = 0;\n      freezePumpTriggersThisTurn.value = 0;\n      freezeFlowCoreTriggeredThisTurn.value = false;\n      modaoStabilizerTriggersThisTurn.value = 0;\n      bloodpoolSkinMarkTriggersThisTurn.value = 0;\n      if (combatState.value.turn === 1) {\n        bloodpoolFirstBleedFeastTriggered.value = false;\n        bloodpoolCriticalReboundTriggered.value = false;\n      }\n      const defeatedByFatigueDegree = applyFatigueDegreePenaltyOnTurnStart();\n      if (defeatedByFatigueDegree) {\n        return;\n      }\n      // Process turn-start effects (poison, burn, mana spring, etc.)\n      if (combatState.value.turn > 1) {\n        for (const [side, label, stats] of [['player', '我方', playerStats], ['enemy', '敌方', enemyStats]] as const) {\n          const targetSide = side as RelicSide;\n          const opponentSide: RelicSide = side === 'player' ? 'enemy' : 'player';\n          const opponentStats = side === 'player' ? enemyStats : playerStats;\n          const poisonAmountBeforeTurnStart = getEffectStacks(stats.value, ET.POISON_AMOUNT);\n          const hpBeforeTurnStart = stats.value.hp;\n          const poisonAmountLethalTriggered = poisonAmountBeforeTurnStart > 0 && poisonAmountBeforeTurnStart >= hpBeforeTurnStart;\n          const result = processOnTurnStart(stats.value);\n          let turnStartLogs = [...result.logs];\n          let burnDamageTaken = 0;\n          let shownTrueDamage = 0;\n          let burnIsTrueDamage = false;\n          let pendingBurnDamageNonTrue = 0;\n          let pendingRegenHeal = 0;\n\n          const regenLog = result.logs.find((entry) => entry.includes('[生命回复]'));\n          if (regenLog) {\n            const regenMatch = regenLog.match(/回复\\s+(\\d+)\\s+点生命/);\n            pendingRegenHeal = regenMatch ? Math.max(0, Number(regenMatch[1])) : 0;\n          }\n\n          if (combatState.value.turn % 3 === 0) {\n            const growthBigStacks = getEffectStacks(stats.value, ET.POINT_GROWTH_BIG);\n            if (growthBigStacks > 0) {\n              stats.value.maxDice += growthBigStacks;\n              turnStartLogs.push(`[点数成长（大）] 最大骰子点数 +${growthBigStacks}（当前 ${stats.value.maxDice}）`);\n            }\n\n            const growthSmallStacks = getEffectStacks(stats.value, ET.POINT_GROWTH_SMALL);\n            if (growthSmallStacks > 0) {\n              stats.value.minDice += growthSmallStacks;\n              if (stats.value.minDice > stats.value.maxDice) {\n                stats.value.maxDice = stats.value.minDice;\n              }\n              turnStartLogs.push(`[点数成长（小）] 最小骰子点数 +${growthSmallStacks}（当前 ${stats.value.minDice}）`);\n            }\n          }\n\n          for (const pending of result.applyToOpponent) {\n            applyStatusEffectWithRelics(opponentSide, pending.type, pending.stacks, { source: `effect:${pending.type}` });\n          }\n\n          if (result.opponentHpChange !== 0) {\n            if (result.opponentHpChange > 0) {\n              healForSide(opponentSide, result.opponentHpChange);\n            } else {\n              const hpBeforeOpponent = opponentStats.value.hp;\n              opponentStats.value.hp = Math.max(0, Math.min(opponentStats.value.maxHp, opponentStats.value.hp + result.opponentHpChange));\n              const actualOpponentHpDelta = opponentStats.value.hp - hpBeforeOpponent;\n              if (actualOpponentHpDelta < 0) {\n                pushFloatingNumber(opponentSide, Math.abs(actualOpponentHpDelta), 'magic', '-');\n              }\n            }\n          }\n\n          // 燃烧伤害单独结算，以支持圣遗物修改\n          const burnLog = result.logs.find((entry) => entry.includes('[燃烧]'));\n          if (burnLog) {\n            const burnMatch = burnLog.match(/损失\\s+(\\d+)\\s+点生命/);\n            const rawBurnDamage = burnMatch ? Number(burnMatch[1]) : 0;\n            const burnStacks = getEffectStacks(stats.value, ET.BURN);\n            turnStartLogs = turnStartLogs.filter((entry) => entry !== burnLog);\n\n            if (rawBurnDamage > 0) {\n              const burnResult = triggerPlayerRelicBeforeBurnDamageHooks(\n                targetSide,\n                burnStacks,\n                rawBurnDamage,\n                combatState.value.turn,\n              );\n\n              result.hpChange += rawBurnDamage; // 移除 processOnTurnStart 的基础燃烧伤害\n\n                if (burnResult.damage > 0) {\n                  if (burnResult.isTrueDamage) {\n                  const burnTrueDamage = targetSide === 'player'\n                    ? applyPlayerHemostaticValveDamageCap(burnResult.damage, '燃烧')\n                    : burnResult.damage;\n                  pushFloatingNumber(side, burnTrueDamage, 'true', '-');\n                  burnDamageTaken = burnTrueDamage;\n                  shownTrueDamage += burnTrueDamage;\n                  burnIsTrueDamage = true;\n                  result.trueDamage += burnTrueDamage;\n                  turnStartLogs.push(`[燃烧] 受到 ${burnTrueDamage} 点真实伤害。`);\n                } else {\n                  let pendingBurnDamage = burnResult.damage;\n                  if (getEffectStacks(stats.value, ET.BARRIER) > 0) {\n                    reduceEffectStacks(stats.value, ET.BARRIER, 1);\n                    pendingBurnDamage = 0;\n                    turnStartLogs.push(`[结界] 抵挡了 ${burnResult.damage} 点燃烧伤害。`);\n                  }\n\n                  if (pendingBurnDamage > 0) {\n                    const armorStacks = getEffectStacks(stats.value, ET.ARMOR);\n                    if (armorStacks > 0) {\n                      const absorbed = Math.min(armorStacks, pendingBurnDamage);\n                      if (absorbed > 0) {\n                        reduceEffectStacks(stats.value, ET.ARMOR, absorbed);\n                        pendingBurnDamage -= absorbed;\n                        turnStartLogs.push(`[护甲] 抵挡了 ${absorbed} 点燃烧伤害。`);\n                      }\n                    }\n                  }\n\n                  if (pendingBurnDamage > 0) {\n                    if (targetSide === 'player') {\n                      pendingBurnDamage = applyPlayerHemostaticValveDamageCap(pendingBurnDamage, '燃烧');\n                    }\n                    burnDamageTaken = pendingBurnDamage;\n                    pendingBurnDamageNonTrue = pendingBurnDamage;\n                    result.hpChange -= pendingBurnDamage;\n                    pushFloatingNumber(side, pendingBurnDamage, 'magic', '-');\n                    turnStartLogs.push(`[燃烧] 损失 ${pendingBurnDamage} 点生命。`);\n                  } else {\n                    turnStartLogs.push('[燃烧] 伤害被完全抵挡。');\n                  }\n                }\n              } else {\n                turnStartLogs.push('[燃烧] 伤害为 0。');\n              }\n            }\n          }\n\n          if (pendingBurnDamageNonTrue > 0) {\n            stats.value.hp = Math.max(0, stats.value.hp - pendingBurnDamageNonTrue);\n          }\n\n          const residualHpChange = result.hpChange + pendingBurnDamageNonTrue - pendingRegenHeal;\n          if (pendingRegenHeal > 0) {\n            healForSide(targetSide, pendingRegenHeal);\n          }\n\n          if (residualHpChange !== 0) {\n            if (residualHpChange > 0) {\n              healForSide(targetSide, residualHpChange);\n            } else {\n              stats.value.hp = Math.max(0, Math.min(stats.value.maxHp, stats.value.hp + residualHpChange));\n            }\n          }\n          if (result.mpChange !== 0) {\n            changeManaWithShock(side, result.mpChange, '法力变化（回合开始）', { showPositiveFloating: true });\n          }\n          if (result.trueDamage > 0) {\n            const trueDamageToApply = targetSide === 'player'\n              ? applyPlayerHemostaticValveDamageCap(result.trueDamage, '回合开始真实伤害')\n              : result.trueDamage;\n            const hpBeforeTrueDamage = stats.value.hp;\n            stats.value.hp = Math.max(0, stats.value.hp - trueDamageToApply);\n            const pendingTrueDamage = Math.max(0, trueDamageToApply - shownTrueDamage);\n            if (pendingTrueDamage > 0) {\n              pushFloatingNumber(side, pendingTrueDamage, 'true', '-');\n            }\n            if (\n              targetSide === 'player'\n              && poisonAmountLethalTriggered\n              && hpBeforeTrueDamage > 0\n              && stats.value.hp <= 0\n            ) {\n              queuePlayerLethalNegativeStatus(PLAYER_POISON_LETHAL_NEGATIVE_STATUS, '中毒量致死判定');\n            }\n          }\n          if (targetSide === 'player') {\n            const turnStartDamageTaken = Math.max(\n              0,\n              pendingBurnDamageNonTrue + result.trueDamage + Math.max(0, -residualHpChange),\n            );\n            addPlayerDamageTakenThisTurn(turnStartDamageTaken);\n          }\n          if (burnDamageTaken > 0) {\n            triggerPlayerRelicAfterBurnDamageTakenHooks(\n              targetSide,\n              getEffectStacks(stats.value, ET.BURN),\n              burnDamageTaken,\n              burnIsTrueDamage,\n              combatState.value.turn,\n            );\n          }\n          const reviveResult = triggerSwarmReviveIfNeeded(stats.value);\n          for (const reviveLog of reviveResult.logs) {\n            log(`<span class=\"text-violet-300 text-[9px]\">${label}: ${reviveLog}</span>`);\n          }\n          for (const l of turnStartLogs) {\n            log(`<span class=\"text-gray-400 text-[9px]\">${label}: ${l}</span>`);\n          }\n        }\n      }\n      setTimeout(() => {\n        if (endCombatPending.value) return;\n        startTurn();\n      }, scaleDuration(1000));\n    }\n  },\n  { immediate: true },\n);\n\n// Watch for DRAW_PHASE\nwatch(\n  [() => combatState.value.phase, isRolling],\n  ([phase, rolling]) => {\n    if (endCombatPending.value) return;\n    if (phase === CombatPhase.DRAW_PHASE && !rolling) {\n      // Use enemy AI to select card\n      const eCard = selectEnemyCard();\n      const { drawn, newDeck, newDiscard } = drawCards(3, combatState.value.playerDeck, combatState.value.discardPile);\n\n      combatState.value.enemyIntentCard = eCard;\n      enemyIntentConsumedThisTurn.value = false;\n      enemyIntentManaSpentThisTurn.value = false;\n      combatState.value.playerHand = drawn;\n      combatState.value.playerDeck = newDeck;\n      combatState.value.discardPile = newDiscard;\n      combatState.value.phase = CombatPhase.PLAYER_INPUT;\n    }\n  },\n);\n\n// Handle Card Select\nconst handleCardSelect = (card: CardData, handIdx: number) => {\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n  if (handIdx < 0 || handIdx >= combatState.value.playerHand.length) return;\n  if (combatState.value.playerHand[handIdx] !== card) return;\n\n  const runtimeCard = withEffectiveManaCost('player', card);\n  const check = canPlayCard(playerStats.value, runtimeCard, playerTurnRawDice.value);\n  if (!check.allowed) {\n    triggerInvalidCardShake(card);\n    log(`<span class=\"text-red-400\">${check.reason ?? '当前无法使用该卡牌。'}</span>`);\n    return;\n  }\n\n  if (runtimeCard.type === CardType.MAGIC) {\n    const canSpend = spendManaWithShock('player', runtimeCard.manaCost, `使用【${card.name}】`);\n    if (!canSpend) {\n      triggerInvalidCardShake(card);\n      log('<span class=\"text-red-400\">法力不足，无法使用该魔法卡牌。</span>');\n      return;\n    }\n  }\n\n  // 出牌后立即离开手牌（卡牌“消失”），并进入弃牌堆\n  const [played] = combatState.value.playerHand.splice(handIdx, 1);\n  if (!played) return;\n  clearDicePreview();\n  showPlayerPlayedCard(played);\n  addFatigueDegree(1);\n  combatState.value.discardPile.push(played);\n  combatState.value.playerSelectedCard = played;\n  combatState.value.phase = CombatPhase.RESOLUTION;\n};\n\nconst handleSkipTurn = () => {\n  if (combatState.value.phase !== CombatPhase.PLAYER_INPUT) return;\n  if (!combatState.value.enemyIntentCard) return;\n\n  clearDicePreview();\n  clearPlayerPlayedCard();\n  combatState.value.playerSelectedCard = PASS_CARD;\n  combatState.value.phase = CombatPhase.RESOLUTION;\n  log('<span class=\"text-gray-400\">你选择了跳过当前回合。</span>');\n};\n\n// Clashable check\nconst isClashable = (card1: CardData, card2: CardData): boolean => {\n  const t1 = card1.type;\n  const t2 = card2.type;\n\n  const bypassDodge =\n    (card1.ignoreDodge && t2 === CardType.DODGE && (t1 === CardType.PHYSICAL || t1 === CardType.MAGIC))\n    || (card2.ignoreDodge && t1 === CardType.DODGE && (t2 === CardType.PHYSICAL || t2 === CardType.MAGIC));\n  if (bypassDodge) return false;\n\n  if (t1 === CardType.PHYSICAL && t2 === CardType.PHYSICAL) return true;\n  if (t1 === CardType.MAGIC && t2 === CardType.MAGIC) return true;\n  if (t1 === CardType.DODGE && (t2 === CardType.PHYSICAL || t2 === CardType.MAGIC)) return true;\n  if (t2 === CardType.DODGE && (t1 === CardType.PHYSICAL || t1 === CardType.MAGIC)) return true;\n  return false;\n};\n\n// Resolution\nconst resolveCombat = async (pCard: CardData, eCard: CardData, pDice: number, eDice: number) => {\n  if (endCombatPending.value) return;\n  try {\n  let resolvedPlayerCard = pCard;\n  let resolvedEnemyCard = eCard;\n  if (\n    resolvedEnemyCard.type === CardType.MAGIC\n    && resolvedEnemyCard.id !== PASS_CARD.id\n    && !enemyIntentManaSpentThisTurn.value\n  ) {\n    enemyIntentManaSpentThisTurn.value = true;\n    const canSpend = spendManaWithShock('enemy', resolvedEnemyCard.manaCost, `使用【${resolvedEnemyCard.name}】`);\n    if (!canSpend) {\n      resolvedEnemyCard = PASS_CARD;\n      combatState.value.enemyIntentCard = PASS_CARD;\n      notifyEnemyManaInsufficient();\n    }\n  }\n\n  resolvedPlayerCard = withFirstUseLightningAmbushBonus('player', resolvedPlayerCard);\n  resolvedEnemyCard = withFirstUseLightningAmbushBonus('enemy', resolvedEnemyCard);\n\n  if (resolvedPlayerCard.traits.combo) {\n    comboUiMaskBridge.value = true;\n  }\n\n  const shouldClash = isClashable(resolvedPlayerCard, resolvedEnemyCard);\n  const clashBypassedByIgnoreDodge =\n    (resolvedPlayerCard.ignoreDodge\n      && resolvedEnemyCard.type === CardType.DODGE\n      && (resolvedPlayerCard.type === CardType.PHYSICAL || resolvedPlayerCard.type === CardType.MAGIC))\n    || (resolvedEnemyCard.ignoreDodge\n      && resolvedPlayerCard.type === CardType.DODGE\n      && (resolvedEnemyCard.type === CardType.PHYSICAL || resolvedEnemyCard.type === CardType.MAGIC));\n  if (!shouldClash && clashBypassedByIgnoreDodge) {\n    log('<span class=\"text-indigo-300\">[无视闪避] 闪避拼点被跳过，卡牌将直接生效。</span>');\n  }\n  const playerSkippedTurn = resolvedPlayerCard.id === PASS_CARD.id;\n  const enemySkippedTurn = resolvedEnemyCard.id === PASS_CARD.id;\n  let resolvedPlayerDice = pDice;\n  let resolvedEnemyDice = eDice;\n  const rerollByTrait = (source: BattleSide, card: CardData) => {\n    if (card.id === PASS_CARD.id || card.traits.reroll === 'none') return;\n    const sourceLabel = source === 'player' ? '我方' : '敌方';\n    let target: BattleSide = source;\n    if (card.traits.reroll === 'enemy') {\n      target = source === 'player' ? 'enemy' : 'player';\n    }\n    const targetLabel = target === 'player' ? '我方' : '敌方';\n    const targetStats = target === 'player' ? playerStats.value : enemyStats.value;\n    const rerolled = rollDiceInRange(targetStats.minDice, targetStats.maxDice);\n    const before = target === 'player' ? resolvedPlayerDice : resolvedEnemyDice;\n\n    if (target === 'player') {\n      resolvedPlayerDice = rerolled;\n      combatState.value.playerBaseDice = rerolled;\n    } else {\n      resolvedEnemyDice = rerolled;\n      combatState.value.enemyBaseDice = rerolled;\n    }\n    log(`<span class=\"text-amber-300\">${sourceLabel}【${card.name}】触发重掷：${targetLabel}骰子 ${before} → ${rerolled}</span>`);\n  };\n  rerollByTrait('player', resolvedPlayerCard);\n  rerollByTrait('enemy', resolvedEnemyCard);\n\n  const pClashPoint = getCardPreviewPoint('player', resolvedPlayerCard, resolvedPlayerDice);\n  const eClashPoint = getCardPreviewPoint('enemy', resolvedEnemyCard, resolvedEnemyDice);\n\n  const clearBurnForSide = (side: 'player' | 'enemy', reason: string) => {\n    const target = side === 'player' ? playerStats.value : enemyStats.value;\n    const label = side === 'player' ? '我方' : '敌方';\n    const burnStacks = getEffectStacks(target, ET.BURN);\n    if (burnStacks <= 0) return;\n    removeEffect(target, ET.BURN);\n    log(`<span class=\"text-orange-300\">${reason} ${label}燃烧清空（${burnStacks}层）。</span>`);\n  };\n\n  if (enemySkippedTurn) {\n    clearBurnForSide('player', '敌方跳过回合。');\n  }\n  if (playerSkippedTurn) {\n    clearBurnForSide('enemy', '我方跳过回合。');\n  }\n\n  applyToxinSpreadOnPhysicalPlay('player', resolvedPlayerCard);\n  applyToxinSpreadOnPhysicalPlay('enemy', resolvedEnemyCard);\n  applyAmbushOnCardPlay('player', resolvedPlayerCard);\n  applyAmbushOnCardPlay('enemy', resolvedEnemyCard);\n\n  let pSuccess = true;\n  let eSuccess = true;\n  let resultMsg = '';\n  let clashWinner: 'player' | 'enemy' | 'tie' | null = null;\n\n  if (shouldClash) {\n    previewPlayerDice.value = pClashPoint;\n    previewEnemyDice.value = eClashPoint;\n    showClashAnimation.value = true;\n    await wait(600);\n\n    screenShake.value = true;\n    setTimeout(() => (screenShake.value = false), scaleDuration(500));\n\n    // 血刃附加：进入拼点即触发\n    applyBloodbladeAttachOnClash('player', 'enemy');\n    applyBloodbladeAttachOnClash('enemy', 'player');\n\n    let successfulDodger: BattleSide | null = null;\n\n    if (resolvedPlayerCard.type === resolvedEnemyCard.type) {\n      if (pClashPoint > eClashPoint) {\n        eSuccess = false;\n        clashWinner = 'player';\n        resultMsg = '我方拼点成功！';\n      } else if (eClashPoint > pClashPoint) {\n        pSuccess = false;\n        clashWinner = 'enemy';\n        resultMsg = '敌方拼点成功！';\n      } else {\n        pSuccess = false;\n        eSuccess = false;\n        clashWinner = 'tie';\n        resultMsg = '势均力敌！';\n      }\n    } else if (resolvedPlayerCard.type === CardType.DODGE) {\n      if (eClashPoint > pClashPoint) {\n        eSuccess = false;\n        clashWinner = 'player';\n        resultMsg = '我方闪避成功！';\n        successfulDodger = 'player';\n      } else {\n        pSuccess = false;\n        clashWinner = 'enemy';\n        resultMsg = '我方闪避失败！';\n      }\n    } else if (resolvedEnemyCard.type === CardType.DODGE) {\n      if (pClashPoint > eClashPoint) {\n        pSuccess = false;\n        clashWinner = 'enemy';\n        resultMsg = '敌方闪避成功！';\n        successfulDodger = 'enemy';\n      } else {\n        eSuccess = false;\n        clashWinner = 'player';\n        resultMsg = '敌方闪避失败！';\n      }\n    }\n\n    if (clashWinner === 'player') shatteringTarget.value = 'enemy';\n    else if (clashWinner === 'enemy') shatteringTarget.value = 'player';\n    else if (clashWinner === 'tie') {\n      shatteringTarget.value = 'both';\n    }\n\n    if (resultMsg) {\n      log(`<span class=\"text-gray-300\">${resultMsg}</span>`);\n    }\n    // 流血：只要发生拼点，双方都按各自当前流血层数受到真实伤害\n    const playerBleedStacksOnClash = Math.max(0, getEffectStacks(playerStats.value, ET.BLEED));\n    if (playerBleedStacksOnClash > 0) {\n      triggerBleedProc('player', '拼点阶段');\n    }\n    const enemyBleedStacksOnClash = Math.max(0, getEffectStacks(enemyStats.value, ET.BLEED));\n    if (enemyBleedStacksOnClash > 0) {\n      triggerBleedProc('enemy', '拼点阶段');\n    }\n    if (clashWinner === 'enemy') {\n      changeRerollCharges('player', 1);\n      log('<span class=\"text-amber-300\">拼点失败：重掷次数 +1</span>');\n    }\n\n    if (clashWinner === 'player') {\n      clearBurnForSide('player', '拼点胜利。');\n    } else if (clashWinner === 'enemy') {\n      clearBurnForSide('enemy', '拼点胜利。');\n    }\n    if (clashWinner === 'player') {\n      const pointMarkCount = getActiveRelicCount('bloodpool_clash_point_mark');\n      if (pointMarkCount > 0) {\n        if (applyStatusEffectWithRelics('enemy', ET.BLEED, pointMarkCount, { source: 'relic:bloodpool_clash_point_mark' })) {\n          logRelicMessage(`[骰蚀刻印] 拼点成功，对敌方施加 ${pointMarkCount} 层流血。`);\n        }\n      }\n    }\n\n    if (successfulDodger === 'player') {\n      applyLightningAttachOnDodge('player', 'enemy');\n      applyCardEffectsByTrigger('player', resolvedPlayerCard, pClashPoint, 'on_dodge_success');\n    } else if (successfulDodger === 'enemy') {\n      applyLightningAttachOnDodge('enemy', 'player');\n      applyCardEffectsByTrigger('enemy', resolvedEnemyCard, eClashPoint, 'on_dodge_success');\n    }\n\n    if (clashWinner === 'player' && resolvedPlayerCard.traits.destroyOnClashWin) {\n      destroyOpponentCardByTrait('player', resolvedEnemyCard);\n    } else if (clashWinner === 'enemy' && resolvedEnemyCard.traits.destroyOnClashWin) {\n      destroyOpponentCardByTrait('enemy', resolvedPlayerCard);\n    }\n\n    await wait(650);\n    showClashAnimation.value = false;\n    clearDicePreview();\n  } else {\n    await wait(500);\n    pSuccess = true;\n    eSuccess = true;\n  }\n\n  // “移除”特性：打出即销毁，若该行动未进入执行阶段，则在此处兜底清理\n  if (!pSuccess && resolvedPlayerCard.traits.purgeOnUse && resolvedPlayerCard.id !== PASS_CARD.id) {\n    applyPurgeTraitAfterUse('player', resolvedPlayerCard);\n  }\n  if (!eSuccess && resolvedEnemyCard.traits.purgeOnUse && resolvedEnemyCard.id !== PASS_CARD.id) {\n    applyPurgeTraitAfterUse('enemy', resolvedEnemyCard);\n  }\n\n  // Execution Phase - use algorithms.ts for proper damage calculation\n  const executeCard = async (source: 'player' | 'enemy', card: CardData, baseDice: number) => {\n    if (endCombatPending.value) return;\n    const attacker = source === 'player' ? playerStats.value : enemyStats.value;\n    const defender = source === 'player' ? enemyStats.value : playerStats.value;\n    const label = source === 'player' ? '我方' : '敌方';\n    const defenderSide = source === 'player' ? 'enemy' : 'player';\n    const defenderLabel = defenderSide === 'player' ? '我方' : '敌方';\n    const opponentSkippedTurn = source === 'player' ? enemySkippedTurn : playerSkippedTurn;\n    const enemyColdBeforeAction = getEffectStacks(enemyStats.value, ET.COLD);\n    const playerBurnBeforeAction = getEffectStacks(playerStats.value, ET.BURN);\n    const playerHpBeforeAction = playerStats.value.hp;\n    let relicTrackingHandled = false;\n\n    if (source === 'enemy' && card.id !== PASS_CARD.id) {\n      enemyIntentConsumedThisTurn.value = true;\n    }\n\n    if (source === 'player') {\n      clearPlayerPlayedCard();\n    }\n    if (card.id !== PASS_CARD.id) {\n      log(`${label}使用了【${card.name}】`);\n    }\n    await playResolvedCardAnimation(source, card);\n    if (endCombatPending.value) return;\n\n    // Calculate final point for this card\n    const finalPoint = getCardFinalPoint(source, card, baseDice);\n    const applyCardExtraAttributes = () => {\n      const selfDamage = resolveCardSelfDamage(card);\n      if (selfDamage) {\n        const rawAmount = selfDamage.mode === 'percent'\n          ? Math.floor(attacker.maxHp * (selfDamage.value / 100))\n          : Math.floor(selfDamage.value);\n        const amount = Math.max(0, rawAmount);\n        if (amount > 0) {\n          if (selfDamage.target === 'maxHp') {\n            const beforeMaxHp = attacker.maxHp;\n            const beforeHp = attacker.hp;\n            attacker.maxHp = Math.max(0, attacker.maxHp - amount);\n            if (attacker.hp > attacker.maxHp) {\n              attacker.hp = attacker.maxHp;\n            }\n            const actualMaxHpLoss = Math.max(0, beforeMaxHp - attacker.maxHp);\n            const hpLossByCap = Math.max(0, beforeHp - attacker.hp);\n            if (hpLossByCap > 0) {\n              pushFloatingNumber(source, hpLossByCap, 'true', '-');\n            }\n            log(`<span class=\"text-rose-300\">${label}【${card.name}】自伤：生命上限 -${actualMaxHpLoss}${hpLossByCap > 0 ? `（当前生命 -${hpLossByCap}）` : ''}</span>`);\n          } else {\n            const actualSelfDamage = applyDirectHpLossWithRelics(source, attacker, amount, `卡牌【${card.name}】自伤`);\n            if (actualSelfDamage > 0) {\n              pushFloatingNumber(source, actualSelfDamage, 'true', '-');\n            }\n            log(`<span class=\"text-rose-300\">${label}【${card.name}】自伤了 ${actualSelfDamage} 点生命</span>`);\n          }\n          const reviveResult = triggerSwarmReviveIfNeeded(attacker);\n          for (const reviveLog of reviveResult.logs) {\n            log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n          }\n        }\n      }\n\n      const manaDrain = Math.max(0, Math.floor(card.manaDrain ?? 0));\n      if (manaDrain > 0) {\n        const drainResult = changeManaWithShock(\n          defenderSide,\n          -manaDrain,\n          `法力汲取（${label}【${card.name}】）`,\n        );\n        const drainedMana = Math.max(0, -drainResult.actualDelta);\n        const overflowHpDamage = Math.max(0, manaDrain - drainedMana);\n        let actualOverflowHpDamage = 0;\n\n        if (overflowHpDamage > 0) {\n          actualOverflowHpDamage = applyDirectHpLossWithRelics(defenderSide, defender, overflowHpDamage, `卡牌【${card.name}】法力汲取溢出`);\n          pushFloatingNumber(defenderSide, actualOverflowHpDamage, 'true', '-');\n        }\n\n        const gainResult = changeManaWithShock(\n          source,\n          manaDrain,\n          `法力汲取（${label}【${card.name}】）`,\n          { showPositiveFloating: true },\n        );\n        const gainedMana = Math.max(0, gainResult.actualDelta);\n\n        const overflowDamageText = actualOverflowHpDamage > 0\n          ? `，额外造成 ${actualOverflowHpDamage} 点真实伤害`\n          : '';\n        log(`<span class=\"text-blue-300\">${label}【${card.name}】法力汲取：吸收 ${drainedMana} 点法力并回复自身 ${gainedMana} 点法力${overflowDamageText}</span>`);\n\n        if (actualOverflowHpDamage > 0) {\n          const reviveResult = triggerSwarmReviveIfNeeded(defender);\n          for (const reviveLog of reviveResult.logs) {\n            log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n          }\n        }\n      }\n    };\n\n    const triggerPostActionRelicTracking = () => {\n      if (relicTrackingHandled) return;\n      relicTrackingHandled = true;\n\n      const enemyColdAfterAction = getEffectStacks(enemyStats.value, ET.COLD);\n      const reducedCold = Math.max(0, enemyColdBeforeAction - enemyColdAfterAction);\n      if (reducedCold > 0) {\n        const frostStorageCount = getActiveRelicCount('yanhan_frost_storage_plate');\n        if (frostStorageCount > 0) {\n          const gained = addArmorForSide('player', frostStorageCount);\n          if (gained > 0) {\n            logRelicMessage(`[凝霜蓄板] 检测到敌方寒冷减少，获得 ${gained} 点护甲。`);\n          }\n        }\n\n        const abyssRiftCount = getActiveRelicCount('yanhan_cold_abyss_rift');\n        if (abyssRiftCount > 0) {\n          const trueDamage = 2 * abyssRiftCount;\n          const actualTrueDamage = applyDirectHpLossWithRelics('enemy', enemyStats.value, trueDamage, '寒渊裂隙');\n          pushFloatingNumber('enemy', actualTrueDamage, 'true', '-');\n          logRelicMessage(`[寒渊裂隙] 检测到敌方寒冷减少，对敌方造成 ${actualTrueDamage} 点真实伤害。`);\n          const reviveResult = triggerSwarmReviveIfNeeded(enemyStats.value);\n          for (const reviveLog of reviveResult.logs) {\n            log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n          }\n        }\n      }\n\n      const playerBurnAfterAction = getEffectStacks(playerStats.value, ET.BURN);\n      const reducedPlayerBurn = Math.max(0, playerBurnBeforeAction - playerBurnAfterAction);\n      if (reducedPlayerBurn > 0) {\n        const heatExchangeCount = getActiveRelicCount('burn_heat_exchange_fin');\n        if (heatExchangeCount > 0) {\n          const gained = addArmorForSide('player', 5 * heatExchangeCount);\n          if (gained > 0) {\n            logRelicMessage(`[热交换鳍片] 检测到自身燃烧减少，获得 ${gained} 点护甲。`);\n          }\n        }\n      }\n\n      addPlayerDamageTakenThisTurn(Math.max(0, playerHpBeforeAction - playerStats.value.hp));\n    };\n\n    const finalizeCardExecution = () => {\n      applyCardExtraAttributes();\n      queueCardNegativeEffectForPlayer(source, card);\n      applyInsertTrait(source, card);\n      applyPurgeTraitAfterUse(source, card);\n    };\n    const finalizeAndTrack = () => {\n      finalizeCardExecution();\n      triggerPostActionRelicTracking();\n    };\n\n    const triggerLowTempEngraverOnFunctionPlay = () => {\n      if (source !== 'player') return;\n      if (card.id === PASS_CARD.id || card.type !== CardType.FUNCTION) return;\n      const count = getActiveRelicCount('yanhan_low_temp_engraver');\n      if (count <= 0) return;\n      if (applyStatusEffectWithRelics('enemy', ET.COLD, count, { source: 'relic:yanhan_low_temp_engraver' })) {\n        logRelicMessage(`[低温刻刀] 打出功能牌，敌方寒冷 +${count}。`);\n      }\n    };\n\n    const syncCurrentPointForUi = () => {\n      if (card.type !== CardType.FUNCTION || card.id === PASS_CARD.id) return;\n      const nextPoint = Math.max(0, Math.floor(finalPoint));\n      if (source === 'player') {\n        if (combatState.value.playerBaseDice !== nextPoint) {\n          combatState.value.playerBaseDice = nextPoint;\n          log(`<span class=\"text-dungeon-gold/80\">我方当前点数调整为 ${nextPoint}</span>`);\n        }\n      } else if (combatState.value.enemyBaseDice !== nextPoint) {\n        combatState.value.enemyBaseDice = nextPoint;\n      }\n    };\n\n    const applyCardEffects = (trigger: CardEffectTrigger = 'on_use') => (\n      applyCardEffectsByTrigger(source, card, finalPoint, trigger)\n    );\n\n    if (opponentSkippedTurn) {\n      applyCardEffects('on_opponent_skip');\n    }\n    triggerLowTempEngraverOnFunctionPlay();\n\n    if (card.id === 'yanhan_zero_boundary_verdict') {\n      const coldStacks = getEffectStacks(defender, ET.COLD);\n      if (coldStacks >= 10) {\n        reduceEffectStacks(defender, ET.COLD, 10);\n        applyStatusEffectWithRelics(defenderSide, ET.STUN, 1, { source: card.id });\n        log(`<span class=\"text-sky-300\">${label}【${card.name}】消耗了敌方10层寒冷并施加了1回合眩晕</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】敌方寒冷不足10层，未触发眩晕分支</span>`);\n      }\n      applyCardEffects();\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'bloodpool_ratio_inversion') {\n      const attackerRatio = attacker.maxHp > 0 ? attacker.hp / attacker.maxHp : 0;\n      const defenderRatio = defender.maxHp > 0 ? defender.hp / defender.maxHp : 0;\n      const nextAttackerHp = Math.max(0, Math.min(attacker.maxHp, Math.floor(attacker.maxHp * defenderRatio)));\n      const nextDefenderHp = Math.max(0, Math.min(defender.maxHp, Math.floor(defender.maxHp * attackerRatio)));\n\n      const attackerDelta = nextAttackerHp - attacker.hp;\n      const defenderDelta = nextDefenderHp - defender.hp;\n      attacker.hp = nextAttackerHp;\n      defender.hp = nextDefenderHp;\n\n      if (attackerDelta > 0) {\n        pushFloatingNumber(source, attackerDelta, 'heal', '+');\n      } else if (attackerDelta < 0) {\n        pushFloatingNumber(source, Math.abs(attackerDelta), 'true', '-');\n      }\n      if (defenderDelta > 0) {\n        pushFloatingNumber(defenderSide, defenderDelta, 'heal', '+');\n      } else if (defenderDelta < 0) {\n        pushFloatingNumber(defenderSide, Math.abs(defenderDelta), 'true', '-');\n      }\n\n      log(`<span class=\"text-rose-300\">${label}【${card.name}】互换了双方生命百分比（我方 ${Math.round(attackerRatio * 100)}% ↔ 敌方 ${Math.round(defenderRatio * 100)}%）</span>`);\n      const defenderRevive = triggerSwarmReviveIfNeeded(defender);\n      for (const reviveLog of defenderRevive.logs) {\n        log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n      }\n      const attackerRevive = triggerSwarmReviveIfNeeded(attacker);\n      for (const reviveLog of attackerRevive.logs) {\n        log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n      }\n      applyCardEffects();\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'bloodpool_bleed_transfusion') {\n      const selfBleed = Math.max(0, getEffectStacks(attacker, ET.BLEED));\n      if (selfBleed > 0) {\n        removeEffect(attacker, ET.BLEED);\n        applyStatusEffectWithRelics(defenderSide, ET.BLEED, selfBleed, { source: card.id });\n        log(`<span class=\"text-rose-300\">${label}【${card.name}】将自身 ${selfBleed} 层流血转移给了对手</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】自身没有可转移的流血</span>`);\n      }\n\n      const triggerTimes = 3;\n      for (let i = 0; i < triggerTimes; i += 1) {\n        const damage = triggerBleedProc(defenderSide, `${label}【${card.name}】第${i + 1}次`);\n        triggerPlayerRelicHitHooks(\n          source,\n          defenderSide,\n          card,\n          finalPoint,\n          i + 1,\n          triggerTimes,\n          damage,\n          damage,\n        );\n        if (defender.hp <= 0) break;\n      }\n      applyCardEffects();\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_muxinlan_liquidation') {\n      const cleanseTargets: EffectType[] = [...ELEMENTAL_DEBUFF_TYPES];\n      let removedStacks = 0;\n      for (const et of cleanseTargets) {\n        const stacks = getEffectStacks(defender, et);\n        if (stacks > 0) {\n          removedStacks += stacks;\n          removeEffect(defender, et);\n        }\n      }\n      const trueDamage = removedStacks * 2;\n      if (trueDamage > 0) {\n        const actualTrueDamage = applyDirectHpLossWithRelics(defenderSide, defender, trueDamage, `卡牌【${card.name}】`);\n        pushFloatingNumber(defenderSide, actualTrueDamage, 'true', '-');\n        log(`<span class=\"text-zinc-300\">${label}【${card.name}】清算了 ${removedStacks} 层状态，造成 ${actualTrueDamage} 点真实伤害</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】未清算到可移除状态</span>`);\n      }\n      const reviveResult = triggerSwarmReviveIfNeeded(defender);\n      for (const reviveLog of reviveResult.logs) {\n        log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n      }\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_muxinlan_liquid_fire') {\n      const coldStacks = getEffectStacks(defender, ET.COLD);\n      if (coldStacks > 0) {\n        removeEffect(defender, ET.COLD);\n        applyStatusEffectWithRelics(defenderSide, ET.BURN, coldStacks, { source: card.id });\n        log(`<span class=\"text-orange-300\">${label}【${card.name}】将 ${coldStacks} 层寒冷转化为燃烧</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】未找到可转化的寒冷</span>`);\n      }\n      applyHitAttachEffects(source, card, attacker, defenderSide);\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_muxinlan_activated_slime') {\n      const currentElementals = ELEMENTAL_DEBUFF_TYPES\n        .map((et) => ({ type: et, stacks: getEffectStacks(defender, et) }))\n        .filter((entry) => entry.stacks > 0);\n      if (currentElementals.length > 0) {\n        const picked = currentElementals[Math.floor(Math.random() * currentElementals.length)]!;\n        applyStatusEffectWithRelics(defenderSide, picked.type, picked.stacks, { source: card.id });\n        log(`<span class=\"text-teal-300\">${label}【${card.name}】使${EFFECT_REGISTRY[picked.type]?.name ?? picked.type}层数翻倍</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】目标无可翻倍的元素debuff</span>`);\n      }\n      applyHitAttachEffects(source, card, attacker, defenderSide);\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_muxinlan_premium_shield') {\n      const x = Math.max(0, Math.floor(defender.mp));\n      if (x > 0) {\n        applyStatusEffectWithRelics(source, ET.STURDY, x, { source: card.id });\n        attacker.mp += x;\n        pushFloatingNumber(source, x, 'shield', '+');\n        pushFloatingNumber(source, x, 'mana', '+');\n      }\n      log(`<span class=\"text-cyan-300\">${label}【${card.name}】获得 ${x} 层坚固与 ${x} 点魔力</span>`);\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_muxinlan_cunning') {\n      applyStatusEffectWithRelics(defenderSide, ET.PEEP_FORBIDDEN, 1, { source: card.id });\n      applyStatusEffectWithRelics(defenderSide, ET.COGNITIVE_INTERFERENCE, 1, { source: card.id });\n      log(`<span class=\"text-violet-300\">${label}【${card.name}】使对手陷入窥视禁忌与认知干涉</span>`);\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_springspirit_internal_manipulation') {\n      const currentCorrosion = Math.max(0, getEffectStacks(defender, ET.CORROSION));\n      const addStacks = Math.min(10, currentCorrosion);\n      if (addStacks > 0) {\n        applyStatusEffectWithRelics(defenderSide, ET.CORROSION, addStacks, { source: card.id });\n        log(`<span class=\"text-emerald-300\">${label}【${card.name}】使对手侵蚀 +${addStacks}</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】未检测到可翻倍的侵蚀层数</span>`);\n      }\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_springspirit_undead_condense') {\n      const selfElementals = ELEMENTAL_DEBUFF_TYPES\n        .map((type) => ({ type, stacks: getEffectStacks(attacker, type) }))\n        .filter((entry) => entry.stacks > 0);\n      if (selfElementals.length > 0) {\n        const picked = selfElementals[Math.floor(Math.random() * selfElementals.length)]!;\n        removeEffect(attacker, picked.type);\n        log(`<span class=\"text-cyan-300\">${label}【${card.name}】清除了自身的${EFFECT_REGISTRY[picked.type]?.name ?? picked.type}</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】自身没有可清除的元素debuff</span>`);\n      }\n\n      const healAmount = Math.max(0, Math.floor(finalPoint));\n      const { healed } = healForSide(source, healAmount);\n      log(`<span class=\"text-green-300\">${label}【${card.name}】回复了 ${healed} 点生命</span>`);\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_nymph_giant_projection') {\n      const hadIllusoryBody = getEffectStacks(attacker, ET.ILLUSORY_BODY) > 0;\n      if (hadIllusoryBody) {\n        removeEffect(attacker, ET.ILLUSORY_BODY);\n      }\n\n      attacker.minDice += 2;\n      attacker.maxDice += 4;\n      if (attacker.minDice > attacker.maxDice) {\n        attacker.maxDice = attacker.minDice;\n      }\n\n      syncCurrentPointForUi();\n      log(`<span class=\"text-violet-300\">${label}【${card.name}】${hadIllusoryBody ? '移除了自身的虚幻之躯，' : ''}最小点数 +2，最大点数 +4（当前 ${attacker.minDice}~${attacker.maxDice}）</span>`);\n      applyCardEffects();\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.id === 'enemy_mata_fungal_repair') {\n      const poisonAmount = Math.max(0, getEffectStacks(defender, ET.POISON_AMOUNT));\n      if (poisonAmount > 0) {\n        removeEffect(defender, ET.POISON_AMOUNT);\n        log(`<span class=\"text-emerald-300\">${label}【${card.name}】清空了对手 ${poisonAmount} 层中毒量</span>`);\n      } else {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】未检测到可清空的中毒量</span>`);\n      }\n\n      const triggerCount = Math.floor(poisonAmount / 2);\n      if (triggerCount > 0) {\n        const healAmount = triggerCount * 2;\n        const { healed } = healForSide(source, healAmount);\n\n        const beforeMaxHp = defender.maxHp;\n        const beforeHp = defender.hp;\n        applyStatusEffectWithRelics(defenderSide, ET.MAX_HP_REDUCTION, triggerCount, { source: card.id });\n        const actualMaxHpLoss = Math.max(0, beforeMaxHp - defender.maxHp);\n        const hpLossByCap = Math.max(0, beforeHp - defender.hp);\n        if (hpLossByCap > 0) {\n          pushFloatingNumber(defenderSide, hpLossByCap, 'true', '-');\n        }\n\n        log(`<span class=\"text-fuchsia-300\">${label}【${card.name}】触发 ${triggerCount} 次：回复 ${healed} 点生命，并使对手生命上限 -${actualMaxHpLoss}${hpLossByCap > 0 ? `（当前生命 -${hpLossByCap}）` : ''}</span>`);\n      } else if (poisonAmount > 0) {\n        log(`<span class=\"text-gray-400\">${label}【${card.name}】中毒量不足2层，未触发后续转化效果</span>`);\n      }\n      finalizeAndTrack();\n      return;\n    }\n\n    if (card.type === CardType.FUNCTION) {\n      if (card.id === 'burn_char_convert') {\n        const burned = getEffectStacks(attacker, ET.BURN);\n        syncCurrentPointForUi();\n        if (burned > 0) {\n          removeEffect(attacker, ET.BURN);\n          attacker.mp += burned;\n          pushFloatingNumber(source, burned, 'mana', '+');\n          log(`<span class=\"text-blue-400\">${label}【${card.name}】清除了 ${burned} 层燃烧并回复了 ${burned} 点魔力</span>`);\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】未检测到燃烧层数</span>`);\n        }\n        finalizeAndTrack();\n        return;\n      }\n      if (card.id === 'yanhan_pressure_cycle') {\n        syncCurrentPointForUi();\n        const armorStacks = Math.max(0, getEffectStacks(attacker, ET.ARMOR));\n        const consumedArmor = Math.min(10, armorStacks);\n        if (consumedArmor > 0) {\n          reduceEffectStacks(attacker, ET.ARMOR, consumedArmor);\n        }\n        const cycles = Math.max(0, Math.floor(consumedArmor / 2));\n        if (cycles > 0) {\n          applyStatusEffectWithRelics(defenderSide, ET.COLD, cycles, { source: card.id });\n          const manaResult = changeManaWithShock(source, cycles, `法力变化（${label}【${card.name}】）`, {\n            showPositiveFloating: true,\n          });\n          const restored = Math.max(0, manaResult.actualDelta);\n          log(`<span class=\"text-sky-300\">${label}【${card.name}】消耗 ${consumedArmor} 点护甲，施加 ${cycles} 层寒冷并回复 ${restored} 点魔力</span>`);\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】护甲不足2点，未触发转化</span>`);\n        }\n        finalizeAndTrack();\n        return;\n      }\n      if (card.id === 'yanhan_cold_source_rectifier') {\n        syncCurrentPointForUi();\n        const coldStacks = Math.max(0, getEffectStacks(defender, ET.COLD));\n        const consumedCold = Math.min(4, coldStacks);\n        if (consumedCold > 0) {\n          reduceEffectStacks(defender, ET.COLD, consumedCold);\n          const { healed } = healForSide(source, consumedCold);\n          log(`<span class=\"text-cyan-300\">${label}【${card.name}】消耗了 ${consumedCold} 层寒冷并回复 ${healed} 点生命</span>`);\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】敌方没有可整流的寒冷</span>`);\n        }\n        finalizeAndTrack();\n        return;\n      }\n      if (card.id === 'modao_mana_purify') {\n        syncCurrentPointForUi();\n        const currentMp = Math.max(0, Math.floor(attacker.mp));\n        const gain = Math.min(20, currentMp);\n        if (gain > 0) {\n          const manaResult = changeManaWithShock(source, gain, `法力变化（${label}【${card.name}】）`, {\n            showPositiveFloating: true,\n          });\n          const restored = Math.max(0, manaResult.actualDelta);\n          log(`<span class=\"text-blue-300\">${label}【${card.name}】将魔力翻倍，回复 ${restored} 点魔力</span>`);\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】当前魔力为0，未获得额外魔力</span>`);\n        }\n        finalizeAndTrack();\n        return;\n      }\n      if (card.id === 'modao_energy_barrier') {\n        syncCurrentPointForUi();\n        const consumedMp = Math.min(5, Math.max(0, Math.floor(attacker.mp)));\n        if (consumedMp > 0) {\n          changeManaWithShock(source, -consumedMp, `法力变化（${label}【${card.name}】）`);\n        }\n        const armorGain = consumedMp * 2;\n        if (armorGain > 0) {\n          applyStatusEffectWithRelics(source, ET.ARMOR, armorGain, { source: card.id });\n          pushFloatingNumber(source, armorGain, 'shield', '+');\n          if (source === 'player') {\n            handlePlayerArmorGainFromSingleEvent(armorGain, `卡牌【${card.name}】`);\n          }\n        }\n        log(`<span class=\"text-cyan-300\">${label}【${card.name}】消耗 ${consumedMp} 点魔力，获得 ${armorGain} 点护甲</span>`);\n        finalizeAndTrack();\n        return;\n      }\n\n      // Process card effects (heal, apply_buff, restore_mana, cleanse)\n      syncCurrentPointForUi();\n      const hasEffect = applyCardEffects();\n      if (card.id === 'enemy_rose_nectar_discipline') {\n        const targetHasBind = getEffectStacks(defender, ET.BIND) > 0;\n        if (targetHasBind) {\n          const poisonStacks = Math.max(0, Math.floor(finalPoint));\n          if (poisonStacks > 0) {\n            applyStatusEffectWithRelics(defenderSide, ET.POISON, poisonStacks, { source: card.id });\n            log(`<span class=\"text-emerald-300\">${label}【${card.name}】触发：目标已束缚，施加 ${poisonStacks} 层中毒</span>`);\n          }\n        }\n      }\n      if (!hasEffect) {\n        // Fallback for special function cards (e.g. MP recovery)\n        if (card.id === 'c5') {\n          attacker.mp += 5;\n          pushFloatingNumber(source, 5, 'mana', '+');\n        }\n      }\n      finalizeAndTrack();\n    } else if (card.type === CardType.PHYSICAL || card.type === CardType.MAGIC) {\n      if (card.id === 'burn_critical_boil') {\n        const coldStacks = Math.max(0, getEffectStacks(defender, ET.COLD));\n        const burnStacks = Math.max(0, getEffectStacks(defender, ET.BURN));\n        const consumedBurn = Math.max(0, Math.min(burnStacks, Math.floor(coldStacks / 2)));\n        const consumedCold = consumedBurn * 2;\n        const trueDamage = consumedBurn * 4;\n\n        if (consumedBurn > 0) {\n          reduceEffectStacks(defender, ET.COLD, consumedCold);\n          reduceEffectStacks(defender, ET.BURN, consumedBurn);\n          const actualTrueDamage = applyDirectHpLossWithRelics(defenderSide, defender, trueDamage, `卡牌【${card.name}】`);\n          if (actualTrueDamage > 0) {\n            pushFloatingNumber(defenderSide, actualTrueDamage, 'true', '-');\n          }\n          log(`<span class=\"text-orange-300\">${label}【${card.name}】按2:1消耗了 ${consumedCold} 层寒冷与 ${consumedBurn} 层燃烧，造成 ${actualTrueDamage} 点真实伤害</span>`);\n          triggerPlayerRelicHitHooks(\n            source,\n            defenderSide,\n            card,\n            finalPoint,\n            1,\n            1,\n            actualTrueDamage,\n            actualTrueDamage,\n          );\n          const reviveResult = triggerSwarmReviveIfNeeded(defender);\n          for (const reviveLog of reviveResult.logs) {\n            log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n          }\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】目标寒冷与燃烧不足以按2:1进行消耗</span>`);\n          triggerPlayerRelicHitHooks(\n            source,\n            defenderSide,\n            card,\n            finalPoint,\n            1,\n            1,\n            0,\n            0,\n          );\n        }\n\n        applyHitAttachEffects(source, card, attacker, defenderSide);\n        applyCardEffects();\n        finalizeAndTrack();\n        return;\n      }\n\n      const burnStacksOnDefender = getEffectStacks(defender, ET.BURN);\n      const baseHitCount = Math.max(1, Math.floor(card.hitCount ?? 1));\n      const defenderSwarmStacks = Math.max(0, getEffectStacks(defender, ET.SWARM));\n      let extraHitCount = card.id === 'enemy_moth_swarm_burst'\n        ? Math.max(0, getEffectStacks(attacker, ET.SWARM))\n        : 0;\n      let arcaneLanceBonusHit = false;\n      if (card.id === 'modao_echo_feedback') {\n        extraHitCount += defenderSwarmStacks;\n      }\n      if (card.id === 'modao_mana_hurricane') {\n        const consumedMp = Math.min(9, Math.max(0, Math.floor(attacker.mp)));\n        if (consumedMp > 0) {\n          changeManaWithShock(source, -consumedMp, `法力变化（${label}【${card.name}】）`);\n        }\n        const bonusHits = Math.floor(consumedMp / 3);\n        extraHitCount += bonusHits;\n        log(`<span class=\"text-blue-300\">${label}【${card.name}】额外消耗 ${consumedMp} 点魔力，追加 ${bonusHits} 次攻击</span>`);\n      }\n      if (card.id === 'modao_ring_collapse') {\n        const consumedMp = Math.min(20, Math.max(0, Math.floor(attacker.mp)));\n        if (consumedMp > 0) {\n          changeManaWithShock(source, -consumedMp, `法力变化（${label}【${card.name}】）`);\n        }\n        const bonusHits = Math.floor(consumedMp / 4);\n        extraHitCount += bonusHits;\n        log(`<span class=\"text-blue-300\">${label}【${card.name}】额外消耗 ${consumedMp} 点魔力，追加 ${bonusHits} 次攻击</span>`);\n      }\n      if (card.id === 'modao_arcane_lance' && attacker.mp >= 8) {\n        const canConsume = spendManaWithShock(source, 4, `法力变化（${label}【${card.name}】额外结算）`);\n        if (canConsume) {\n          extraHitCount += 1;\n          arcaneLanceBonusHit = true;\n          log(`<span class=\"text-blue-300\">${label}【${card.name}】额外消耗4点魔力，追加一次1.5倍伤害</span>`);\n        }\n      }\n      const totalHitCount = baseHitCount + extraHitCount;\n\n      if (card.id === 'yanhan_cold_chamber_duplicate') {\n        const currentCold = getEffectStacks(defender, ET.COLD);\n        if (currentCold > 0) {\n          applyStatusEffectWithRelics(defenderSide, ET.COLD, currentCold, { source: card.id });\n          log(`<span class=\"text-sky-300\">${label}【${card.name}】使敌方寒冷翻倍（+${currentCold}）</span>`);\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】敌方当前无寒冷，未触发翻倍</span>`);\n        }\n      }\n\n      if (totalHitCount > 1) {\n        log(`<span class=\"text-violet-300\">${label}【${card.name}】进行 ${totalHitCount} 段攻击</span>`);\n      }\n\n      let modaoMagicSwordTotalDamage = 0;\n      let totalActualDamageDealt = 0;\n      for (let hit = 0; hit < totalHitCount; hit++) {\n        // Attack card: calculate damage through the full pipeline\n        let cardForCalculation = card;\n        const customDamage =\n          card.id === 'burn_scorch_wind'\n            ? Math.floor(finalPoint * 0.5) + burnStacksOnDefender\n            : card.id === 'burn_detonation'\n              ? Math.floor(burnStacksOnDefender)\n              : card.id === 'modao_mana_hurricane'\n                ? Math.max(0, 12 - Math.floor(finalPoint))\n                : card.id === 'modao_prism_flow'\n                  ? Math.floor(finalPoint * (0.8 + Math.min(1.2, Math.floor(Math.max(0, attacker.mp) / 2) * 0.2)))\n                  : card.id === 'modao_arcane_lance' && arcaneLanceBonusHit && hit === totalHitCount - 1\n                    ? Math.floor(finalPoint * 1.5)\n              : card.id === 'enemy_rose_wangzhi_whip' && getEffectStacks(defender, ET.BIND) > 0\n                ? Math.floor(finalPoint) + 2\n              : null;\n\n        if (customDamage !== null) {\n          cardForCalculation = {\n            ...card,\n            damageLogic: { mode: 'fixed', value: Math.floor(customDamage) },\n          };\n        }\n\n        const { damage, isTrueDamage, logs: dmgLogs } = calculateFinalDamage({\n          finalPoint,\n          card: cardForCalculation,\n          attackerEffects: attacker.effects,\n          defenderEffects: defender.effects,\n          relicModifiers: NO_RELIC_MOD,\n        });\n        const adjustedDamage = defenderSide === 'player'\n          ? applyPlayerSkinMarkDamageReduction(damage, `${defenderLabel}受击`)\n          : damage;\n        const { actualDamage, logs: applyLogs } = applyDamageToSideWithRelics(defenderSide, defender, adjustedDamage, isTrueDamage, `卡牌【${card.name}】`);\n        const hitPrefix = totalHitCount > 1 ? `第${hit + 1}段` : '';\n        const damageLogColorClass = isTrueDamage ? 'text-zinc-500' : 'text-red-400';\n        log(`${label}【${card.name}】${hitPrefix}点数${finalPoint}，造成 <span class=\"${damageLogColorClass} font-bold\">${actualDamage}</span> 点伤害`);\n        if (actualDamage > 0) {\n          const damageKind: FloatingNumberKind = isTrueDamage\n            ? 'true'\n            : (card.type === CardType.MAGIC ? 'magic' : 'physical');\n          pushFloatingNumber(defenderSide, actualDamage, damageKind, '-');\n        }\n        if (card.id === 'modao_magic_sword' && actualDamage > 0) {\n          modaoMagicSwordTotalDamage += actualDamage;\n        }\n        if (actualDamage > 0) {\n          totalActualDamageDealt += actualDamage;\n        }\n\n        if (card.type === CardType.PHYSICAL && !isTrueDamage && actualDamage > 0) {\n          const thornStacks = getEffectStacks(defender, ET.THORNS);\n          if (thornStacks > 0) {\n            let reflectedDamage = Math.max(0, Math.floor(actualDamage * 0.5));\n            if (source === 'player') {\n              reflectedDamage = applyPlayerSkinMarkDamageReduction(reflectedDamage, '荆棘反弹');\n            }\n            if (reflectedDamage > 0) {\n              const { actualDamage: actualReflectedDamage, logs: reflectedLogs } = applyDamageToSideWithRelics(source, attacker, reflectedDamage, false, '荆棘反弹');\n              if (actualReflectedDamage > 0) {\n                pushFloatingNumber(source, actualReflectedDamage, 'physical', '-');\n              }\n              log(`<span class=\"text-lime-300\">${defenderLabel}[荆棘] 反弹了 ${actualReflectedDamage} 点伤害给${label}</span>`);\n              for (const reflectedLog of reflectedLogs) {\n                const normalized = reflectedLog.startsWith('受到') ? `${label}${reflectedLog}` : reflectedLog;\n                log(`<span class=\"text-gray-500 text-[9px]\">${normalized}</span>`);\n              }\n              const reviveResult = triggerSwarmReviveIfNeeded(attacker);\n              for (const reviveLog of reviveResult.logs) {\n                log(`<span class=\"text-violet-300 text-[9px]\">${reviveLog}</span>`);\n              }\n            }\n          }\n        }\n\n        const coldLogs = consumeColdAfterDealingDamage(attacker, actualDamage);\n        for (const coldLog of coldLogs) {\n          log(`<span class=\"text-sky-300 text-[9px]\">${label}: ${coldLog}</span>`);\n        }\n\n        for (const dl of dmgLogs) {\n          if (dl.startsWith('原始伤害:')) continue;\n          log(`<span class=\"text-gray-500 text-[9px]\">${dl}</span>`);\n        }\n        for (const dl of applyLogs) {\n          const normalized = dl.startsWith('受到') ? `${defenderLabel}${dl}` : dl;\n          log(`<span class=\"text-gray-500 text-[9px]\">${normalized}</span>`);\n        }\n        triggerPlayerRelicHitHooks(\n          source,\n          defenderSide,\n          card,\n          finalPoint,\n          hit + 1,\n          totalHitCount,\n          adjustedDamage,\n          actualDamage,\n        );\n        applyHitAttachEffects(source, card, attacker, defenderSide);\n        if (defender.hp <= 0) break;\n      }\n      if (card.id === 'modao_magic_sword' && modaoMagicSwordTotalDamage > 0) {\n        const manaResult = changeManaWithShock(source, modaoMagicSwordTotalDamage, `法力变化（${label}【${card.name}】）`, {\n          showPositiveFloating: true,\n        });\n        const restored = Math.max(0, manaResult.actualDelta);\n        log(`<span class=\"text-blue-300\">${label}【${card.name}】回收 ${restored} 点魔力</span>`);\n      }\n      if (card.id === 'bloodpool_siphon_slash') {\n        const healAmount = Math.max(0, Math.floor(totalActualDamageDealt * 0.5));\n        const { healed } = healForSide(source, healAmount);\n        log(`<span class=\"text-green-300\">${label}【${card.name}】吸血回复 ${healed} 点生命</span>`);\n      }\n      if (card.id === 'bloodpool_vital_reservoir') {\n        const maxHpGain = Math.max(0, Math.floor(totalActualDamageDealt));\n        if (maxHpGain > 0) {\n          const beforeMaxHp = attacker.maxHp;\n          const applied = applyStatusEffectWithRelics(source, ET.TEMP_MAX_HP, maxHpGain, { source: card.id });\n          const actualMaxHpGain = Math.max(0, attacker.maxHp - beforeMaxHp);\n          if (applied && actualMaxHpGain > 0) {\n            log(`<span class=\"text-rose-300\">${label}【${card.name}】临时生命上限 +${actualMaxHpGain}</span>`);\n          } else {\n            log(`<span class=\"text-gray-400\">${label}【${card.name}】未能获得临时生命上限</span>`);\n          }\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】未造成伤害，未获得临时生命上限</span>`);\n        }\n      }\n\n      // 攻击牌结算后同样触发附带效果（燃烧、易伤等）\n      applyCardEffects();\n      if (card.id === 'bloodpool_blood_debt_strike') {\n        const bleedStacks = 3;\n        if (applyStatusEffectWithRelics(defenderSide, ET.BLEED, bleedStacks, { source: card.id })) {\n          log(`<span class=\"text-rose-300\">${label}【${card.name}】施加 ${bleedStacks} 层流血</span>`);\n        }\n      }\n      if (card.id === 'bloodpool_scar_burst') {\n        const bleedDamage = triggerBleedProc(defenderSide, `${label}【${card.name}】`);\n        triggerPlayerRelicHitHooks(\n          source,\n          defenderSide,\n          card,\n          finalPoint,\n          1,\n          1,\n          bleedDamage,\n          bleedDamage,\n        );\n        const bleedStacks = Math.max(0, Math.floor(finalPoint * 0.5));\n        if (bleedStacks > 0) {\n          if (applyStatusEffectWithRelics(defenderSide, ET.BLEED, bleedStacks, { source: card.id })) {\n            log(`<span class=\"text-rose-300\">${label}【${card.name}】追加施加 ${bleedStacks} 层流血</span>`);\n          }\n        }\n      }\n\n      if (card.id === 'yanhan_feedback_freeze_wheel') {\n        const armorGain = Math.max(0, Math.floor(getEffectStacks(defender, ET.COLD) / 2));\n        if (armorGain > 0) {\n          applyStatusEffectWithRelics(source, ET.ARMOR, armorGain, { source: card.id });\n          pushFloatingNumber(source, armorGain, 'shield', '+');\n          if (source === 'player') {\n            handlePlayerArmorGainFromSingleEvent(armorGain, `卡牌【${card.name}】`);\n          }\n          log(`<span class=\"text-cyan-300\">${label}【${card.name}】回授获得 ${armorGain} 点护甲</span>`);\n        } else {\n          log(`<span class=\"text-gray-400\">${label}【${card.name}】敌方寒冷不足，未获得额外护甲</span>`);\n        }\n      }\n\n      if (card.id === 'enemy_blissbee_aphro_stinger') {\n        const targetHasVulnerable = getEffectStacks(defender, ET.VULNERABLE) > 0;\n        if (targetHasVulnerable) {\n          const poisonStacks = 2;\n          if (poisonStacks > 0) {\n            applyStatusEffectWithRelics(defenderSide, ET.POISON, poisonStacks, { source: card.id });\n          }\n          log(`<span class=\"text-emerald-300\">${label}【${card.name}】触发：对手易伤存在，额外施加 ${poisonStacks} 层中毒</span>`);\n        }\n      }\n\n      if (card.id === 'enemy_blissbee_precise_harvest') {\n        const targetHasPoison = getEffectStacks(defender, ET.POISON) > 0;\n        if (targetHasPoison) {\n          const shockStacks = Math.max(0, Math.floor(finalPoint * 0.5));\n          if (shockStacks > 0) {\n            applyStatusEffectWithRelics(defenderSide, ET.SHOCK, shockStacks, { source: card.id });\n          }\n          log(`<span class=\"text-indigo-300\">${label}【${card.name}】触发：对手中毒存在，额外施加 ${shockStacks} 层电击</span>`);\n        }\n      }\n\n      if (card.id === 'enemy_rose_life_drain') {\n        const targetHasBind = getEffectStacks(defender, ET.BIND) > 0;\n        if (targetHasBind) {\n          const healAmount = Math.max(0, Math.floor(finalPoint));\n          const { healed } = healForSide(source, healAmount);\n          if (healed > 0) {\n            log(`<span class=\"text-green-300\">${label}【${card.name}】触发：目标已束缚，回复了 ${healed} 点生命</span>`);\n          }\n        }\n      }\n\n      if (card.id === 'enemy_muxinlan_unstable_reagent') {\n        const stacks = Math.max(0, Math.floor(finalPoint * 0.5));\n        if (stacks > 0) {\n          const picked = ELEMENTAL_DEBUFF_TYPES[Math.floor(Math.random() * ELEMENTAL_DEBUFF_TYPES.length)]!;\n          applyStatusEffectWithRelics(defenderSide, picked, stacks, { source: card.id });\n          log(`<span class=\"text-fuchsia-300\">${label}【${card.name}】附加了 ${stacks} 层${EFFECT_REGISTRY[picked]?.name ?? picked}</span>`);\n        }\n      }\n      finalizeAndTrack();\n    } else {\n      finalizeAndTrack();\n    }\n  };\n\n  interface ActionEntry {\n    source: 'player' | 'enemy';\n    card: CardData;\n    type: CardType;\n    baseDice: number;\n  }\n\n  const queue: ActionEntry[] = [];\n  let deferredEnemyAction: ActionEntry | null = null;\n  if (pSuccess) queue.push({ source: 'player', card: resolvedPlayerCard, type: resolvedPlayerCard.type, baseDice: resolvedPlayerDice });\n  if (eSuccess) {\n    const enemyAction: ActionEntry = { source: 'enemy', card: resolvedEnemyCard, type: resolvedEnemyCard.type, baseDice: resolvedEnemyDice };\n    if (resolvedPlayerCard.traits.combo) {\n      // 连击过程中，敌方行动延后到“连击结束”时再结算一次\n      deferredEnemyAction = enemyAction;\n    } else {\n      queue.push(enemyAction);\n    }\n  }\n\n  const typePriority = (t: CardType) => {\n    if (t === CardType.FUNCTION) return 3;\n    if (t === CardType.MAGIC) return 2;\n    if (t === CardType.PHYSICAL) return 1;\n    return 0;\n  };\n\n  queue.sort((a, b) => typePriority(b.type) - typePriority(a.type));\n\n  const shouldRunSimultaneousVisuals = (\n    queue.length === 2\n    && queue.every((action) => action.type === CardType.DODGE || action.type === CardType.FUNCTION)\n  );\n\n  if (shouldRunSimultaneousVisuals) {\n    await Promise.all(queue.map((action) => executeCard(action.source, action.card, action.baseDice)));\n    if (endCombatPending.value) return;\n    await wait(630);\n  } else {\n    for (const action of queue) {\n      if (endCombatPending.value) break;\n      await executeCard(action.source, action.card, action.baseDice);\n      if (endCombatPending.value) break;\n      await wait(630);\n    }\n  }\n  stopAllCardAnimations();\n  if (endCombatPending.value) return;\n\n  // 连击：本次打出后，若带 draw 则补抽 1 张；并允许继续从剩余手牌出牌\n  if (resolvedPlayerCard.traits.combo) {\n    if (resolvedPlayerCard.traits.draw) {\n      const { drawn, newDeck, newDiscard } = drawCards(1, combatState.value.playerDeck, combatState.value.discardPile);\n      combatState.value.playerDeck = newDeck;\n      combatState.value.discardPile = newDiscard;\n      combatState.value.playerHand = [...combatState.value.playerHand, ...drawn];\n    }\n\n    if (combatState.value.playerHand.length > 0 && playerStats.value.hp > 0 && enemyStats.value.hp > 0) {\n      combatState.value.playerSelectedCard = null;\n      combatState.value.phase = CombatPhase.PLAYER_INPUT;\n      return;\n    }\n\n    // 连击无法继续时，再补结算一次敌方行动\n    if (deferredEnemyAction && playerStats.value.hp > 0 && enemyStats.value.hp > 0) {\n      if (endCombatPending.value) return;\n      await executeCard(deferredEnemyAction.source, deferredEnemyAction.card, deferredEnemyAction.baseDice);\n      if (endCombatPending.value) return;\n      await wait(630);\n    }\n  }\n\n  if (playerStats.value.hp <= 0 || enemyStats.value.hp <= 0) return;\n\n  // End-of-turn effect processing (armor halving, stun clear, etc.)\n  const playerArmorBeforeEnd = getEffectStacks(playerStats.value, ET.ARMOR);\n  const pEndLogs = processOnTurnEnd(playerStats.value);\n  const eEndLogs = processOnTurnEnd(enemyStats.value);\n  const playerArmorAfterEnd = getEffectStacks(playerStats.value, ET.ARMOR);\n  const armorLostOnDecay = Math.max(0, playerArmorBeforeEnd - playerArmorAfterEnd);\n\n  const sealCircuitCount = getActiveRelicCount('yanhan_seal_circuit');\n  if (sealCircuitCount > 0 && armorLostOnDecay > 0) {\n    const pending = Math.max(0, Math.floor((armorLostOnDecay * sealCircuitCount) / 3));\n    if (pending > 0) {\n      sealCircuitPendingMana.value += pending;\n      logRelicMessage(`[封存回路] 护甲衰减损失 ${armorLostOnDecay}，存储 ${pending} 点魔力用于下回合。`);\n    }\n  }\n\n  const reverseShellCount = getActiveRelicCount('yanhan_reverse_phase_shell');\n  if (reverseShellCount > 0 && playerDamageTakenThisTurn.value >= 10) {\n    const coldStacks = 2 * reverseShellCount;\n    if (applyStatusEffectWithRelics('enemy', ET.COLD, coldStacks, { source: 'relic:yanhan_reverse_phase_shell' })) {\n      logRelicMessage(`[反相壳层] 本回合累计受伤 ${playerDamageTakenThisTurn.value}，对敌方施加 ${coldStacks} 层寒冷。`);\n    }\n  }\n\n  for (const l of [...pEndLogs, ...eEndLogs]) {\n    log(`<span class=\"text-gray-500 text-[9px]\">${l}</span>`);\n  }\n  triggerPlayerRelicLifecycleHooks('onTurnEnd');\n  const magicDollCount = getActiveRelicCount('modao_magic_doll');\n  if (magicDollCount > 0 && playerStats.value.hp > 0 && enemyStats.value.hp > 0) {\n    for (let i = 0; i < magicDollCount; i++) {\n      const canSpend = spendManaWithShock('player', 1, '魔法玩偶');\n      if (!canSpend) break;\n      const { actualDamage, logs: dollLogs } = applyDamageToSideWithRelics('enemy', enemyStats.value, 2, false, '魔法玩偶');\n      if (actualDamage > 0) {\n        pushFloatingNumber('enemy', actualDamage, 'magic', '-');\n      }\n      logRelicMessage(`[魔法玩偶] 消耗1点魔力，对敌方造成 ${actualDamage} 点伤害。`);\n      for (const dl of dollLogs) {\n        const normalized = dl.startsWith('受到') ? `敌方${dl}` : dl;\n        log(`<span class=\"text-gray-500 text-[9px]\">${normalized}</span>`);\n      }\n      if (enemyStats.value.hp <= 0) break;\n    }\n  }\n\n  // Cleanup\n  combatState.value.discardPile = [...combatState.value.discardPile, ...combatState.value.playerHand];\n  combatState.value.playerHand = [];\n  combatState.value.turn += 1;\n  combatState.value.phase = CombatPhase.TURN_START;\n  } finally {\n    comboUiMaskBridge.value = false;\n  }\n};\n\n// Watch for RESOLUTION phase\nwatch(\n  () => combatState.value.phase,\n  (phase) => {\n    if (endCombatPending.value) return;\n    if (\n      phase === CombatPhase.RESOLUTION &&\n      combatState.value.playerSelectedCard &&\n      combatState.value.enemyIntentCard &&\n      !showClashAnimation.value\n    ) {\n      resolveCombat(\n        combatState.value.playerSelectedCard,\n        combatState.value.enemyIntentCard,\n        combatState.value.playerBaseDice,\n        combatState.value.enemyBaseDice,\n      );\n    }\n  },\n);\n\nconst runEndCombatSequence = async (win: boolean) => {\n  const token = ++endCombatSequenceToken;\n  await wait(HP_BAR_ANIMATION_MS);\n  if (token !== endCombatSequenceToken) return;\n\n  await wait(RESULT_DELAY_MS);\n  if (token !== endCombatSequenceToken) return;\n\n  stopAllCardAnimations();\n  battleResultBanner.value = win ? 'win' : 'lose';\n  combatState.value.phase = win ? CombatPhase.WIN : CombatPhase.LOSE;\n\n  await wait(RESULT_BANNER_STAY_MS);\n  if (token !== endCombatSequenceToken) return;\n  setFatigueDegree(0);\n  const finalPlayerStats = cloneEntityStats(playerStats.value);\n  if (getEffectStacks(finalPlayerStats, ET.TEMP_MAX_HP) > 0) {\n    removeEffect(finalPlayerStats, ET.TEMP_MAX_HP);\n  }\n  emit('endCombat', win, finalPlayerStats, [...combatState.value.logs], [...pendingCardNegativeEffects.value]);\n};\n\nwatch(\n  () => playerStats.value.hp,\n  (nextHp, prevHp) => {\n    if (endCombatPending.value) return;\n    if (!Number.isFinite(nextHp) || !Number.isFinite(prevHp)) return;\n\n    const maxHp = Math.max(1, playerStats.value.maxHp);\n    const halfHp = maxHp * 0.5;\n    const prevHalfState = prevHp > halfHp ? 1 : (prevHp < halfHp ? -1 : 0);\n    const nextHalfState = nextHp > halfHp ? 1 : (nextHp < halfHp ? -1 : 0);\n    const crossedHalf = prevHalfState * nextHalfState === -1;\n\n    const resonanceCount = getActiveRelicCount('bloodpool_halfline_resonance');\n    if (crossedHalf && resonanceCount > 0 && enemyStats.value.hp > 0) {\n      for (let i = 0; i < resonanceCount; i += 1) {\n        const damage = triggerBleedProc('enemy', `[半阈共振核] 阈值跨越触发（${i + 1}/${resonanceCount}）`);\n        if (damage <= 0 || enemyStats.value.hp <= 0) break;\n      }\n    }\n\n    const reboundCount = getActiveRelicCount('bloodpool_critical_rebound');\n    if (\n      reboundCount > 0\n      && !bloodpoolCriticalReboundTriggered.value\n      && nextHp > 0\n      && nextHp < halfHp\n    ) {\n      bloodpoolCriticalReboundTriggered.value = true;\n      const { healed } = healForSide('player', 5 * reboundCount);\n      logRelicMessage(`[危线回流] 首次低于半血，回复 ${healed} 点生命。`);\n    }\n  },\n);\n\n// 任何生命值/中毒量变化后，立即执行中毒量致死判定。\nwatch(\n  [\n    () => playerStats.value.hp,\n    () => enemyStats.value.hp,\n    () => getEffectStacks(playerStats.value, ET.POISON_AMOUNT),\n    () => getEffectStacks(enemyStats.value, ET.POISON_AMOUNT),\n  ],\n  () => {\n    if (endCombatPending.value || poisonAmountImmediateCheckRunning) return;\n    poisonAmountImmediateCheckRunning = true;\n    try {\n      applyImmediatePoisonAmountLethalCheck('player');\n      applyImmediatePoisonAmountLethalCheck('enemy');\n    } finally {\n      poisonAmountImmediateCheckRunning = false;\n    }\n  },\n);\n\n// Win/Lose check\nwatch(\n  [() => playerStats.value.hp, () => enemyStats.value.hp],\n  ([pHp, eHp]) => {\n    if (endCombatPending.value) return;\n\n    let win: boolean | null = null;\n    if (pHp <= 0) win = false;\n    else if (eHp <= 0) win = true;\n    if (win === null) return;\n\n    endCombatPending.value = true;\n    void runEndCombatSequence(win);\n  },\n);\n</script>\n\n<style scoped>\n.combat-float-number {\n  animation-name: combat-float-up;\n  animation-timing-function: ease-out;\n  animation-fill-mode: forwards;\n  line-height: 1;\n}\n\n.combat-float-number--heal {\n  color: #4ade80 !important;\n  text-shadow:\n    0 0 10px rgba(74, 222, 128, 0.95),\n    0 0 22px rgba(34, 197, 94, 0.6);\n  -webkit-text-stroke: 0.45px rgba(6, 78, 59, 0.9);\n}\n\n.player-played-card {\n  width: 10rem;\n  z-index: 56;\n  will-change: left, top, transform, opacity;\n}\n\n.player-played-card-bob {\n  animation: player-played-card-bob calc(1.2s / var(--combat-speed-multiplier)) ease-in-out infinite;\n}\n\n@keyframes player-played-card-bob {\n  0%,\n  100% {\n    transform: translateY(0);\n  }\n  50% {\n    transform: translateY(-6px);\n  }\n}\n\n.resolved-card-visual {\n  position: absolute;\n  width: 10rem;\n  transform: translate(-50%, -50%);\n  z-index: 58;\n  pointer-events: none;\n}\n\n.resolved-card-visual--player {\n  left: 29%;\n  top: 23%;\n}\n\n.resolved-card-visual--enemy {\n  left: 63%;\n  top: 23%;\n}\n\n.resolved-card-visual-inner {\n  opacity: 0.96;\n  transform: scale(1);\n  will-change: transform, opacity, filter;\n  filter: drop-shadow(0 0 18px rgba(0, 0, 0, 0.45));\n}\n\n.resolved-card-visual-inner--player.resolved-card-visual-inner--attack {\n  animation: card-attack-player calc(0.93s / var(--combat-speed-multiplier)) cubic-bezier(0.18, 0.9, 0.2, 1) forwards;\n}\n\n.resolved-card-visual-inner--enemy.resolved-card-visual-inner--attack {\n  animation: card-attack-enemy calc(0.93s / var(--combat-speed-multiplier)) cubic-bezier(0.18, 0.9, 0.2, 1) forwards;\n}\n\n.resolved-card-visual-inner--player.resolved-card-visual-inner--self {\n  animation: card-self-player calc(0.57s / var(--combat-speed-multiplier)) ease-out forwards;\n}\n\n.resolved-card-visual-inner--enemy.resolved-card-visual-inner--self {\n  animation: card-self-enemy calc(0.57s / var(--combat-speed-multiplier)) ease-out forwards;\n}\n\n.resolved-card-visual-inner--player.resolved-card-visual-inner--fade,\n.resolved-card-visual-inner--enemy.resolved-card-visual-inner--fade {\n  animation: card-fade-only calc(0.57s / var(--combat-speed-multiplier)) ease-out forwards;\n}\n\n@keyframes card-attack-player {\n  0% {\n    opacity: 0.96;\n    transform: translate3d(0, 0, 0) scale(1);\n  }\n  38% {\n    opacity: 1;\n    transform: translate3d(-90px, 40px, 0) scale(1.03);\n  }\n  78% {\n    opacity: 1;\n    transform: translate3d(56vw, 15vh, 0) scale(0.79);\n  }\n  100% {\n    opacity: 0;\n    transform: translate3d(58vw, 16vh, 0) scale(0.74);\n  }\n}\n\n@keyframes card-attack-enemy {\n  0% {\n    opacity: 0.96;\n    transform: translate3d(0, 0, 0) scale(1);\n  }\n  38% {\n    opacity: 1;\n    transform: translate3d(90px, -40px, 0) scale(1.03);\n  }\n  78% {\n    opacity: 1;\n    transform: translate3d(-50vw, 33vh, 0) scale(0.79);\n  }\n  100% {\n    opacity: 0;\n    transform: translate3d(-52vw, 34vh, 0) scale(0.74);\n  }\n}\n\n@keyframes card-self-player {\n  0% {\n    opacity: 0.96;\n    transform: translate3d(0, 0, 0) scale(1);\n  }\n  35% {\n    opacity: 1;\n    transform: translate3d(24px, -10px, 0) scale(1.02);\n  }\n  76% {\n    opacity: 1;\n    transform: translate3d(-170px, 300px, 0) scale(0.78);\n  }\n  100% {\n    opacity: 0;\n    transform: translate3d(-178px, 308px, 0) scale(0.74);\n  }\n}\n\n@keyframes card-self-enemy {\n  0% {\n    opacity: 0.96;\n    transform: translate3d(0, 0, 0) scale(1);\n  }\n  35% {\n    opacity: 1;\n    transform: translate3d(-24px, 10px, 0) scale(1.02);\n  }\n  76% {\n    opacity: 1;\n    transform: translate3d(180px, 120px, 0) scale(0.78);\n  }\n  100% {\n    opacity: 0;\n    transform: translate3d(188px, 126px, 0) scale(0.74);\n  }\n}\n\n@keyframes card-fade-only {\n  0% {\n    opacity: 0.96;\n    transform: scale(1);\n  }\n  100% {\n    opacity: 0;\n    transform: scale(0.96);\n  }\n}\n\n@keyframes combat-float-up {\n  0% {\n    opacity: 0;\n    transform: translate(-50%, 0) scale(0.85);\n  }\n  15% {\n    opacity: 1;\n  }\n  100% {\n    opacity: 0;\n    transform: translate(-50%, -42px) scale(1.05);\n  }\n}\n\n.combat-root :deep(.animate-float) {\n  animation-duration: calc(6s / var(--combat-speed-multiplier));\n}\n\n.combat-root :deep(.animate-clash-left),\n.combat-root :deep(.animate-clash-right),\n.combat-root :deep(.animate-shatter) {\n  animation-duration: calc(0.6s / var(--combat-speed-multiplier));\n}\n\n.combat-root :deep(.animate-shake) {\n  animation-duration: calc(0.5s / var(--combat-speed-multiplier));\n}\n\n.combat-root :deep(.animate-impact-shake) {\n  animation: impact-nudge calc(0.2s / var(--combat-speed-multiplier)) ease-out;\n}\n\n@keyframes impact-nudge {\n  0% {\n    transform: translate3d(0, 0, 0);\n  }\n  25% {\n    transform: translate3d(-3px, 2px, 0);\n  }\n  50% {\n    transform: translate3d(3px, -2px, 0);\n  }\n  75% {\n    transform: translate3d(-2px, 1px, 0);\n  }\n  100% {\n    transform: translate3d(0, 0, 0);\n  }\n}\n\n.effect-icon-btn {\n  position: relative;\n  width: 1.75rem;\n  height: 1.75rem;\n  border-radius: 0.35rem;\n  border-width: 1px;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  transition: transform calc(0.14s / var(--combat-speed-multiplier)) ease, filter calc(0.14s / var(--combat-speed-multiplier)) ease;\n}\n\n.effect-icon-btn:hover,\n.effect-icon-btn:focus-visible {\n  transform: translateY(-1px);\n  filter: brightness(1.12);\n  outline: none;\n}\n\n.status-effect-value-btn {\n  background: transparent;\n  border: none;\n  padding: 0;\n  margin: 0;\n  border-radius: 0.25rem;\n  cursor: help;\n  transition: filter calc(0.12s / var(--combat-speed-multiplier)) ease;\n}\n\n.status-effect-value-btn:hover,\n.status-effect-value-btn:focus-visible {\n  filter: brightness(1.08);\n  outline: none;\n}\n\n.effect-stack-badge {\n  position: absolute;\n  right: -0.28rem;\n  bottom: -0.28rem;\n  min-width: 0.9rem;\n  height: 0.9rem;\n  border-radius: 999px;\n  background: rgba(8, 12, 24, 0.95);\n  border: 1px solid rgba(255, 255, 255, 0.24);\n  color: rgba(255, 255, 255, 0.9);\n  font-size: 9px;\n  line-height: 1;\n  font-weight: 700;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  padding: 0 2px;\n}\n\n.effect-tooltip {\n  max-width: 16rem;\n  background: rgba(8, 10, 16, 0.96);\n  border: 1px solid rgba(255, 255, 255, 0.16);\n  border-radius: 0.5rem;\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.42);\n  padding: 0.5rem 0.6rem;\n}\n\n.effect-tooltip--center {\n  transform: translate(-50%, calc(-100% - 8px));\n}\n\n.effect-tooltip--right {\n  transform: translate(0, calc(-100% - 8px));\n}\n\n.effect-tooltip-name {\n  color: rgba(255, 255, 255, 0.95);\n  font-size: 11px;\n  font-weight: 700;\n  line-height: 1.2;\n}\n\n.effect-tooltip-desc {\n  margin-top: 0.25rem;\n  color: rgba(229, 231, 235, 0.92);\n  font-size: 10px;\n  line-height: 1.4;\n}\n\n.effect-tooltip-stacks {\n  margin-top: 0.25rem;\n  color: rgba(250, 204, 21, 0.92);\n  font-size: 10px;\n  line-height: 1.2;\n  font-weight: 700;\n}\n\n.poison-wave-bar {\n  background-image:\n    linear-gradient(180deg, rgba(16, 185, 129, 0.28), rgba(22, 163, 74, 0.8)),\n    repeating-linear-gradient(\n      -25deg,\n      rgba(255, 255, 255, 0.18) 0px,\n      rgba(255, 255, 255, 0.18) 10px,\n      rgba(255, 255, 255, 0) 10px,\n      rgba(255, 255, 255, 0) 20px\n    );\n  background-size: 100% 100%, 220% 100%;\n  background-position: 0 0, 0 0;\n  animation: poison-wave-slide calc(2.1s / var(--combat-speed-multiplier)) linear infinite;\n}\n\n@keyframes poison-wave-slide {\n  from {\n    background-position: 0 0, 0 0;\n  }\n  to {\n    background-position: 0 0, 220% 0;\n  }\n}\n\n.invalid-card-shake {\n  position: relative;\n  animation: invalid-card-shake calc(0.32s / var(--combat-speed-multiplier)) ease;\n}\n\n@keyframes invalid-card-shake {\n  0% { left: 0; }\n  18% { left: -8px; }\n  36% { left: 7px; }\n  54% { left: -5px; }\n  72% { left: 4px; }\n  100% { left: 0; }\n}\n</style>\n","<template>\n  <div\n    class=\"w-full h-screen bg-[#050505] font-body text-dungeon-paper overflow-hidden relative\"\n  >\n    <!-- Dynamic Background -->\n    <div class=\"absolute inset-0 z-0\">\n      <img\n        v-if=\"bgImageUrl\"\n        :src=\"bgImageUrl\"\n        class=\"absolute inset-0 w-full h-full object-cover\"\n        alt=\"\"\n        @error=\"onBgError\"\n      />\n      <div class=\"absolute inset-0\" :style=\"{ backgroundColor: `rgba(0,0,0,${bgOverlayOpacity})` }\"></div>\n    </div>\n\n    <!-- Sidebar: Individual Icons Top-Left (no back button, settings already has exit) -->\n    <div class=\"absolute top-6 left-6 z-50 flex flex-col space-y-4\">\n      <SidebarIcon\n        :icon=\"SettingsIcon\"\n        label=\"设置\"\n        tooltip-side=\"right\"\n        :active=\"activeModal === 'settings'\"\n        @click=\"activeModal = 'settings'\"\n      />\n      <SidebarIcon :icon=\"Scroll\" label=\"卡组\" tooltip-side=\"right\" :active=\"activeModal === 'deck'\" @click=\"activeModal = 'deck'\" />\n      <SidebarIcon :icon=\"Box\" label=\"物品\" tooltip-side=\"right\" :active=\"activeModal === 'relics'\" @click=\"activeModal = 'relics'\" />\n      <SidebarIcon :icon=\"Users\" label=\"羁绊\" tooltip-side=\"right\" :active=\"activeModal === 'bonds'\" @click=\"activeModal = 'bonds'\" />\n      <SidebarIcon :icon=\"MapIcon\" label=\"地图\" tooltip-side=\"right\" :active=\"activeModal === 'map'\" @click=\"activeModal = 'map'\" />\n      <SidebarIcon\n        :icon=\"magicBookSidebarIcon\"\n        :label=\"canEditMagicBooks ? '魔法书' : '魔法书（锁定）'\"\n        tooltip-side=\"right\"\n        :active=\"canEditMagicBooks && activeModal === 'magicBooks'\"\n        :highlight=\"canEditMagicBooks\"\n        :disabled=\"!canEditMagicBooks\"\n        @click=\"openMagicBookModal\"\n      />\n      <SidebarIcon\n        :icon=\"magicHatSidebarIcon\"\n        :label=\"canEditMagicBooks ? '魔法帽' : '魔法帽（锁定）'\"\n        tooltip-side=\"right\"\n        :active=\"canEditMagicBooks && activeModal === 'magicHat'\"\n        :highlight=\"canEditMagicBooks\"\n        :disabled=\"!canEditMagicBooks\"\n        @click=\"openMagicHatModal\"\n      />\n    </div>\n\n    <!-- Right sidebar: save/load only (reroll & edit moved into panel) -->\n    <div class=\"absolute top-6 right-4 z-50 flex flex-col space-y-4\">\n      <SidebarIcon\n        :icon=\"Maximize\"\n        label=\"全屏模式\"\n        tooltip-side=\"left\"\n        @click=\"toggleFullScreen\"\n      />\n      <SidebarIcon\n        :icon=\"BookOpen\"\n        label=\"读档\"\n        tooltip-side=\"left\"\n        :active=\"gameStore.isSaveLoadOpen\"\n        @click=\"openSaveLoad\"\n      />\n      <SidebarIcon\n        :icon=\"FileText\"\n        label=\"变量更新\"\n        tooltip-side=\"left\"\n        :active=\"isVariableUpdateOpen\"\n        @click=\"openVariableUpdate\"\n      />\n    </div>\n\n    <!-- Main Content Area -->\n    <div class=\"h-full w-full flex flex-col items-center\">\n      <div\n        class=\"w-full flex flex-col pt-2 pb-2 px-4 md:px-12 md:pl-24 transition-all duration-300 h-full\"\n        :style=\"{ maxWidth: textSettings.containerWidth + 'px' }\"\n      >\n        <!-- Story Text Area -->\n        <div\n          class=\"flex-1 bg-dungeon-dark/80 border border-dungeon-brown rounded-t-lg shadow-2xl backdrop-blur-sm p-6 md:p-10 overflow-y-auto min-h-0 custom-scrollbar relative\"\n        >\n          <!-- Decorative Corners -->\n          <div class=\"absolute top-2 left-2 w-4 h-4 border-t border-l border-dungeon-gold/30\"></div>\n          <div class=\"absolute top-2 right-2 w-4 h-4 border-t border-r border-dungeon-gold/30\"></div>\n\n          <!-- Loading Indicator -->\n          <div v-if=\"gameStore.isGenerating\" class=\"flex items-center gap-3 mb-4\">\n            <div class=\"flex gap-1\">\n              <span class=\"w-2 h-2 bg-dungeon-gold rounded-full animate-bounce\" style=\"animation-delay: 0s\"></span>\n              <span class=\"w-2 h-2 bg-dungeon-gold rounded-full animate-bounce\" style=\"animation-delay: 0.2s\"></span>\n              <span class=\"w-2 h-2 bg-dungeon-gold rounded-full animate-bounce\" style=\"animation-delay: 0.4s\"></span>\n            </div>\n            <span class=\"text-dungeon-gold/60 font-ui text-sm\">正在生成...</span>\n          </div>\n\n          <!-- Edit Mode -->\n          <div v-if=\"gameStore.isEditing\" class=\"flex flex-col h-full\">\n            <textarea\n              v-model=\"gameStore.editingText\"\n              class=\"flex-1 w-full bg-[#1a0f08] border border-dungeon-brown text-dungeon-paper rounded p-4 resize-none focus:outline-none focus:border-dungeon-gold focus:ring-1 focus:ring-dungeon-gold/50 font-ui custom-scrollbar\"\n              :style=\"{\n                fontSize: textSettings.fontSize + 'px',\n                lineHeight: textSettings.lineHeight,\n                fontFamily: textSettings.fontFamily,\n              }\"\n            ></textarea>\n            <!-- Edit Actions -->\n            <div class=\"flex justify-end gap-3 mt-4\">\n              <button\n                class=\"px-5 py-2 text-sm font-ui text-gray-400 border border-gray-700 rounded\n                       hover:bg-gray-800 transition-colors\"\n                @click=\"gameStore.cancelEdit()\"\n              >\n                取消\n              </button>\n              <button\n                class=\"px-5 py-2 text-sm font-ui text-dungeon-gold border border-dungeon-gold/40 rounded\n                       hover:bg-dungeon-gold/10 transition-colors\n                       shadow-[0_0_8px_rgba(212,175,55,0.15)]\"\n                @click=\"gameStore.saveEdit()\"\n              >\n                确认更改\n              </button>\n            </div>\n          </div>\n\n          <!-- Normal View (not editing) -->\n          <template v-else>\n            <!-- Story Content -->\n            <div\n              class=\"prose prose-invert max-w-none prose-p:text-dungeon-paper tracking-wide\"\n              :style=\"{\n                fontSize: textSettings.fontSize + 'px',\n                lineHeight: textSettings.lineHeight,\n                fontFamily: textSettings.fontFamily,\n              }\"\n            >\n              <!-- Streaming text (during generation) -->\n              <p v-if=\"isStreamingEnabled && gameStore.isGenerating && gameStore.streamingText\" class=\"whitespace-pre-wrap text-dungeon-paper/85\">\n                {{ gameStore.streamingText }}\n              </p>\n              <!-- Final main text -->\n              <div v-else class=\"story-rich-text\">\n                <p v-for=\"line in storyMainLines\" :key=\"line.key\" :class=\"['story-line', `story-line-level-${line.level}`]\">\n                  <template v-if=\"line.segments.length > 0\">\n                    <span\n                      v-for=\"segment in line.segments\"\n                      :key=\"segment.key\"\n                      :class=\"{\n                        'story-segment-muted': segment.type === 'muted',\n                        'story-segment-quote': segment.type === 'quote',\n                      }\"\n                    >\n                      {{ segment.text }}\n                    </span>\n                  </template>\n                  <span v-else class=\"story-line-empty\">&nbsp;</span>\n                </p>\n\n                <div v-if=\"storyTucaoSections.length > 0\" class=\"story-tucao-section-list\">\n                  <div v-for=\"(section, sectionIndex) in storyTucaoSections\" :key=\"section.key\" class=\"story-tucao-wrap\">\n                    <button class=\"story-tucao-toggle\" type=\"button\" @click=\"toggleTucao(section.key)\">\n                      {{\n                        isTucaoExpanded(section.key)\n                          ? `收起脑内剧场 ${sectionIndex + 1}`\n                          : `🎮 此方的脑内剧场 ${sectionIndex + 1}`\n                      }}\n                    </button>\n                    <Transition name=\"tucao-expand\">\n                      <div v-if=\"isTucaoExpanded(section.key)\" class=\"story-tucao-panel\">\n                        <p\n                          v-for=\"line in section.lines\"\n                          :key=\"line.key\"\n                          :class=\"['story-line', `story-line-level-${line.level}`]\"\n                        >\n                          <template v-if=\"line.segments.length > 0\">\n                            <span\n                              v-for=\"segment in line.segments\"\n                              :key=\"segment.key\"\n                              :class=\"{\n                                'story-segment-muted': segment.type === 'muted',\n                                'story-segment-quote': segment.type === 'quote',\n                              }\"\n                            >\n                              {{ segment.text }}\n                            </span>\n                          </template>\n                          <span v-else class=\"story-line-empty\">&nbsp;</span>\n                        </p>\n                      </div>\n                    </Transition>\n                  </div>\n                </div>\n              </div>\n            </div>\n\n            <!-- Options Section -->\n            <div v-if=\"!gameStore.isGenerating && (gameStore.options.length > 0 || gameStore.hasOptionE || gameStore.hasLeave || gameStore.hasRebirth)\" class=\"mt-8 flex flex-col space-y-3\">\n              <div\n                class=\"h-[1px] w-full bg-gradient-to-r from-transparent via-dungeon-gold/20 to-transparent mb-2\"\n              ></div>\n\n              <!-- A-D Normal Options -->\n              <button\n                v-for=\"(option, i) in gameStore.options\"\n                :key=\"'opt-' + i\"\n                class=\"w-full text-left px-5 py-3 bg-dungeon-dark/60 hover:bg-dungeon-brown/40\n                       text-dungeon-paper/80 hover:text-dungeon-paper\n                       rounded border border-dungeon-brown/50 hover:border-dungeon-gold/40\n                       font-ui text-sm tracking-wide\n                       transition-all duration-300\n                       hover:shadow-[0_0_12px_rgba(212,175,55,0.08)]\n                       hover:translate-x-1\"\n                @click=\"handleOptionClick(option)\"\n              >\n                {{ option }}\n              </button>\n\n              <!-- E Option: Special Room Action Button -->\n              <button\n                v-if=\"gameStore.hasOptionE && specialOptionConfig\"\n                class=\"w-full text-center px-6 py-4 rounded-lg border-2 font-heading text-base tracking-wider\n                       transition-all duration-400 hover:scale-[1.02] active:scale-[0.98]\"\n                :style=\"{\n                  backgroundColor: specialOptionConfig.bgColor,\n                  borderColor: specialOptionConfig.borderColor,\n                  color: specialOptionConfig.textColor,\n                  boxShadow: `0 0 20px ${specialOptionConfig.glowColor}, inset 0 1px 0 rgba(255,255,255,0.1)`,\n                }\"\n                @click=\"handleSpecialOption\"\n              >\n                <span class=\"text-xl mr-2\">{{ specialOptionConfig.icon }}</span>\n                {{ specialOptionConfig.label }}\n              </button>\n\n              <!-- [Leave] Portal System -->\n              <div v-if=\"gameStore.hasLeave && portalChoices.length > 0\" class=\"mt-4\">\n                <div class=\"text-center text-dungeon-gold/40 text-xs font-ui tracking-widest uppercase mb-3\">\n                  ─── 传送门 ───\n                </div>\n                <div class=\"flex justify-center gap-4\">\n                  <button\n                    v-for=\"(portal, i) in portalChoices\"\n                    :key=\"'portal-' + i\"\n                    class=\"portal-btn group relative flex flex-col items-center justify-center\n                           w-24 h-24 rounded-lg border-2 backdrop-blur-sm\n                           transition-all duration-500 hover:scale-110\n                           active:scale-95\"\n                    :style=\"{\n                      backgroundColor: portal.bgColor,\n                      borderColor: portal.borderColor,\n                      boxShadow: `0 0 15px ${portal.glowColor}, 0 0 30px ${portal.glowColor}40`,\n                    }\"\n                    @click=\"handlePortalClick(portal)\"\n                  >\n                    <!-- Portal glow ring -->\n                    <div\n                      class=\"absolute inset-0 rounded-lg opacity-50 group-hover:opacity-100 transition-opacity duration-500\"\n                      :style=\"{ boxShadow: `inset 0 0 20px ${portal.glowColor}60` }\"\n                    ></div>\n                    <!-- Portal icon -->\n                    <span class=\"text-2xl mb-1 relative z-10 drop-shadow-lg\">{{ portal.icon }}</span>\n                    <!-- Portal label -->\n                    <span\n                      class=\"text-[10px] font-ui tracking-wide relative z-10 text-center leading-tight\"\n                      :style=\"{ color: portal.textColor }\"\n                    >{{ portal.label }}</span>\n                    <!-- Animated ring -->\n                    <div\n                      class=\"absolute inset-1 rounded-md border border-dashed opacity-30 group-hover:opacity-70\n                             animate-[spin_8s_linear_infinite] transition-opacity\"\n                      :style=\"{ borderColor: portal.borderColor }\"\n                    ></div>\n                  </button>\n                </div>\n              </div>\n\n              <!-- [Rebirth] Reset Button -->\n              <div v-if=\"gameStore.hasRebirth\" class=\"mt-4\">\n                <div class=\"text-center text-red-300/70 text-xs font-ui tracking-widest uppercase mb-3\">\n                  ─── 回溯 ───\n                </div>\n                <div class=\"flex justify-center\">\n                  <button\n                    class=\"group relative px-7 py-3 rounded-lg border-2 font-heading text-sm tracking-wider\n                           transition-all duration-300 hover:scale-[1.02] active:scale-[0.98]\n                           bg-red-950/45 border-red-500/60 text-red-100\n                           shadow-[0_0_14px_rgba(239,68,68,0.35)] hover:shadow-[0_0_20px_rgba(248,113,113,0.5)]\"\n                    :disabled=\"gameStore.isGenerating\"\n                    @click=\"handleRebirthClick\"\n                  >\n                    <span class=\"text-base mr-2\">⟲</span>\n                    回溯重生\n                  </button>\n                </div>\n              </div>\n            </div>\n\n            <div\n              v-if=\"hotSpringCleanseMessage\"\n              :key=\"`spring-cleanse-${hotSpringCleanseMessage.id}`\"\n              class=\"spring-cleanse-float\"\n            >\n              {{ hotSpringCleanseMessage.text }}\n            </div>\n\n            <!-- Error Display -->\n            <div v-if=\"gameStore.error\" class=\"mt-6 p-4 bg-red-950/30 border border-red-900/50 rounded text-red-300 font-ui text-sm\">\n              {{ gameStore.error }}\n            </div>\n          </template>\n        </div>\n\n        <!-- Input Area -->\n        <div class=\"bg-[#0f0f0f] border-x border-b border-dungeon-brown rounded-b-lg p-4 shrink-0\">\n          <div class=\"relative w-full\">\n            <input\n              v-model=\"inputText\"\n              type=\"text\"\n              :disabled=\"gameStore.isGenerating\"\n              :placeholder=\"gameStore.isGenerating ? '等待回复中...' : '输入你的行动...'\"\n              class=\"w-full bg-[#1a0f08] border border-dungeon-brown text-dungeon-paper px-4 py-3 pr-14 rounded focus:outline-none focus:border-dungeon-gold focus:ring-1 focus:ring-dungeon-gold/50 font-ui placeholder-gray-700 transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n              @keydown.enter=\"handleSendInput\"\n            />\n            <button\n              class=\"absolute right-2 top-1/2 -translate-y-1/2 p-2 bg-[#1a0f08] border border-dungeon-gold/30 hover:bg-dungeon-brown hover:border-dungeon-gold text-dungeon-gold rounded transition-all disabled:opacity-30 disabled:cursor-not-allowed\"\n              :disabled=\"gameStore.isGenerating\"\n              @click=\"handleSendInput\"\n            >\n              <Send class=\"size-5\" />\n            </button>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <!-- Player Status HUD (Bottom Left) - Collapsible -->\n    <div class=\"absolute bottom-6 left-6 z-50 flex flex-col gap-2 select-none\">\n      <!-- Toggle Button -->\n      <button\n        class=\"w-10 h-10 rounded-lg flex items-center justify-center\n               bg-dungeon-dark/90 border border-dungeon-gold/30 text-dungeon-gold-dim\n               hover:bg-dungeon-brown hover:text-dungeon-gold hover:border-dungeon-gold/50\n               transition-all duration-300 shadow-lg backdrop-blur-md\"\n        :title=\"isStatusOpen ? '收起状态栏' : '展开状态栏'\"\n        @click=\"isStatusOpen = !isStatusOpen\"\n      >\n        <component :is=\"isStatusOpen ? ChevronDown : Activity\" class=\"size-5\" />\n      </button>\n\n      <!-- Expandable Status Panel -->\n      <Transition name=\"status-slide\">\n        <div\n          v-if=\"isStatusOpen\"\n          class=\"relative p-4 bg-dungeon-dark/90 border border-dungeon-gold/30 rounded-xl backdrop-blur-md shadow-[0_0_30px_rgba(0,0,0,0.8)]\"\n        >\n          <!-- Decorative Elements -->\n          <div class=\"absolute -top-1 -left-1 size-2 bg-dungeon-gold rotate-45 border border-black\"></div>\n          <div class=\"absolute -bottom-1 -right-1 size-2 bg-dungeon-gold rotate-45 border border-black\"></div>\n          <div class=\"absolute top-0 inset-x-0 h-[1px] bg-gradient-to-r from-transparent via-dungeon-gold/50 to-transparent\"></div>\n\n          <!-- HP & MP: Container-fill style -->\n          <div class=\"flex items-end gap-4 mb-3\">\n            <!-- HP Heart Container -->\n            <div class=\"flex flex-col items-center gap-1\">\n              <div class=\"stat-container-heart\" :title=\"`HP: ${displayHp}/${displayMaxHp}`\">\n                <svg viewBox=\"0 0 64 64\" class=\"w-14 h-14\">\n                  <defs>\n                    <clipPath id=\"heartClip\">\n                      <path d=\"M32 56 C32 56, 6 40, 6 22 C6 12, 14 4, 24 4 C28 4, 31 6, 32 9 C33 6, 36 4, 40 4 C50 4, 58 12, 58 22 C58 40, 32 56, 32 56Z\" />\n                    </clipPath>\n                    <filter id=\"hpGlow\">\n                      <feGaussianBlur stdDeviation=\"2\" result=\"glow\" />\n                      <feMerge>\n                        <feMergeNode in=\"glow\" />\n                        <feMergeNode in=\"SourceGraphic\" />\n                      </feMerge>\n                    </filter>\n                    <linearGradient id=\"hpGradient\" x1=\"0\" y1=\"1\" x2=\"0\" y2=\"0\">\n                      <stop offset=\"0%\" stop-color=\"#8a0e0e\" />\n                      <stop offset=\"50%\" stop-color=\"#cc2222\" />\n                      <stop offset=\"100%\" stop-color=\"#ee4444\" />\n                    </linearGradient>\n                  </defs>\n                  <!-- Heart outline (dark) -->\n                  <path\n                    d=\"M32 56 C32 56, 6 40, 6 22 C6 12, 14 4, 24 4 C28 4, 31 6, 32 9 C33 6, 36 4, 40 4 C50 4, 58 12, 58 22 C58 40, 32 56, 32 56Z\"\n                    fill=\"#1a0808\"\n                    stroke=\"#5c1a1a\"\n                    stroke-width=\"1.5\"\n                  />\n                  <!-- Fill level (clipped to heart) -->\n                  <g clip-path=\"url(#heartClip)\">\n                    <rect\n                      x=\"0\"\n                      :y=\"64 - (hpPercent / 100) * 60\"\n                      width=\"64\"\n                      :height=\"(hpPercent / 100) * 60\"\n                      fill=\"url(#hpGradient)\"\n                      filter=\"url(#hpGlow)\"\n                      class=\"transition-all duration-700 ease-out\"\n                    />\n                  </g>\n                  <!-- Highlight -->\n                  <ellipse cx=\"22\" cy=\"18\" rx=\"5\" ry=\"4\" fill=\"rgba(255,255,255,0.12)\" transform=\"rotate(-20,22,18)\" />\n                </svg>\n              </div>\n              <span class=\"text-[10px] font-ui text-dungeon-paper/80 tracking-wide\">\n                <span class=\"text-[#cc3333] font-bold\">{{ displayHp }}</span>\n                <span class=\"text-gray-600\">/{{ displayMaxHp }}</span>\n              </span>\n            </div>\n\n            <!-- MP Crystal Container -->\n            <div class=\"flex flex-col items-center gap-1\">\n              <div class=\"stat-container-mana\" :title=\"`MP: ${displayMp}`\">\n                <svg viewBox=\"0 0 64 64\" class=\"w-14 h-14\">\n                  <defs>\n                    <clipPath id=\"manaClip\">\n                      <path d=\"M32 4 L54 24 L32 60 L10 24 Z\" />\n                    </clipPath>\n                    <filter id=\"mpGlow\">\n                      <feGaussianBlur stdDeviation=\"2\" result=\"glow\" />\n                      <feMerge>\n                        <feMergeNode in=\"glow\" />\n                        <feMergeNode in=\"SourceGraphic\" />\n                      </feMerge>\n                    </filter>\n                    <linearGradient id=\"mpGradient\" x1=\"0\" y1=\"1\" x2=\"0\" y2=\"0\">\n                      <stop offset=\"0%\" stop-color=\"#1a1a8a\" />\n                      <stop offset=\"50%\" stop-color=\"#3344cc\" />\n                      <stop offset=\"100%\" stop-color=\"#5566ee\" />\n                    </linearGradient>\n                  </defs>\n                  <!-- Crystal outline -->\n                  <path\n                    d=\"M32 4 L54 24 L32 60 L10 24 Z\"\n                    fill=\"#080818\"\n                    stroke=\"#1a1a5c\"\n                    stroke-width=\"1.5\"\n                  />\n                  <!-- Fill level -->\n                  <g clip-path=\"url(#manaClip)\">\n                    <rect\n                      x=\"0\"\n                      :y=\"64 - (mpPercent / 100) * 60\"\n                      width=\"64\"\n                      :height=\"(mpPercent / 100) * 60\"\n                      fill=\"url(#mpGradient)\"\n                      filter=\"url(#mpGlow)\"\n                      class=\"transition-all duration-700 ease-out\"\n                    />\n                  </g>\n                  <!-- Highlight -->\n                  <polygon points=\"26,14 32,8 38,14 32,20\" fill=\"rgba(255,255,255,0.1)\" />\n                </svg>\n              </div>\n              <span class=\"text-[10px] font-ui text-dungeon-paper/80 tracking-wide\">\n                <span class=\"text-blue-400 font-bold\">{{ displayMp }}</span>\n              </span>\n            </div>\n          </div>\n\n          <!-- Divider -->\n          <div class=\"my-2 h-[1px] w-full bg-gradient-to-r from-transparent via-dungeon-gold/20 to-transparent\"></div>\n\n          <!-- Dice Range Row -->\n          <div class=\"flex items-center justify-between px-1 mb-2\">\n            <div class=\"flex items-center gap-2 text-dungeon-paper/70\">\n              <Dices class=\"size-4 text-dungeon-gold-dim drop-shadow-sm\" />\n              <span class=\"font-ui text-sm tracking-wide\">\n                <span class=\"text-dungeon-paper font-bold\">{{ displayMinDice }}</span>\n                <span class=\"text-gray-500\">~</span>\n                <span class=\"text-dungeon-paper font-bold\">{{ displayMaxDice }}</span>\n              </span>\n            </div>\n            <span class=\"text-[10px] text-[#5c3a21] uppercase tracking-widest font-bold\">Dice</span>\n          </div>\n\n          <!-- Gold Row -->\n          <div class=\"flex items-center justify-between px-1\">\n            <div class=\"flex items-center gap-2 text-dungeon-gold\">\n              <Coins class=\"size-4 drop-shadow-sm\" />\n              <span\n                class=\"font-heading text-lg tracking-wider text-transparent bg-clip-text bg-gradient-to-b from-[#f9e6a0] to-dungeon-gold-dim drop-shadow-sm\"\n              >\n                {{ displayGold }}\n              </span>\n            </div>\n            <span class=\"text-[10px] text-[#5c3a21] uppercase tracking-widest font-bold\">Gold</span>\n          </div>\n        </div>\n      </Transition>\n    </div>\n\n    <!-- Modals -->\n    <DungeonModal title=\"地牢地图\" :is-open=\"activeModal === 'map'\" panel-class=\"max-w-5xl\" @close=\"activeModal = null\">\n      <div class=\"map-modal\">\n        <div class=\"map-toolbar\">\n          <div class=\"map-summary\">\n            本层路径：<span class=\"map-summary-highlight\">{{ currentFloorPath.length }}</span> 房\n            <span class=\"map-summary-divider\">|</span>\n            统计计数：<span class=\"map-summary-highlight\">{{ currentLayerRoomCount }}</span> 房\n          </div>\n          <div class=\"map-controls\">\n            <button type=\"button\" class=\"map-control-btn\" @click=\"handleMapZoomOut\">-</button>\n            <button type=\"button\" class=\"map-control-btn\" @click=\"handleMapZoomIn\">+</button>\n            <button type=\"button\" class=\"map-control-btn map-control-btn--wide\" @click=\"handleMapResetView\">重置视图</button>\n          </div>\n        </div>\n        <div v-if=\"currentFloorPath.length === 0\" class=\"map-empty\">\n          本层暂无路径记录\n        </div>\n        <div\n          v-else\n          ref=\"mapViewportRef\"\n          class=\"map-viewport\"\n          @wheel.prevent=\"handleMapWheel\"\n          @pointerdown=\"handleMapPointerDown\"\n          @pointermove=\"handleMapPointerMove\"\n          @pointerup=\"handleMapPointerUp\"\n          @pointercancel=\"handleMapPointerUp\"\n        >\n          <div class=\"map-canvas\" :style=\"mapCanvasStyle\">\n            <svg\n              class=\"map-links\"\n              :width=\"mapContentWidth\"\n              :height=\"mapContentHeight\"\n              :viewBox=\"`0 0 ${mapContentWidth} ${mapContentHeight}`\"\n            >\n              <line\n                v-for=\"line in mapPathLines\"\n                :key=\"line.key\"\n                :x1=\"line.x1\"\n                :y1=\"line.y1\"\n                :x2=\"line.x2\"\n                :y2=\"line.y2\"\n                stroke=\"rgba(0,0,0,0.9)\"\n                stroke-width=\"4\"\n                stroke-linecap=\"round\"\n              />\n            </svg>\n            <div\n              v-for=\"node in mapPathNodes\"\n              :key=\"`path-node-${node.index}`\"\n              class=\"map-room-cell\"\n              :style=\"node.style\"\n            >\n              <span class=\"map-room-icon\">{{ node.icon }}</span>\n              <span class=\"map-room-step\">{{ node.index + 1 }}</span>\n            </div>\n          </div>\n        </div>\n      </div>\n    </DungeonModal>\n\n    <DungeonModal title=\"羁绊\" :is-open=\"activeModal === 'bonds'\" panel-class=\"max-w-4xl\" @close=\"activeModal = null\">\n      <div v-if=\"bondEntries.length > 0\" class=\"bond-list custom-scrollbar max-h-[64vh] overflow-y-auto pr-1\">\n        <div v-for=\"entry in bondEntries\" :key=\"`bond-${entry.name}`\" class=\"bond-row\">\n          <button type=\"button\" class=\"bond-portrait-frame bond-portrait-frame--clickable\" @click=\"openBondPortraitPreview(entry)\">\n            <img\n              v-if=\"!bondPortraitErrors[entry.name]\"\n              :src=\"entry.portraitUrl\"\n              :alt=\"`${entry.name} 立绘`\"\n              class=\"bond-portrait-image\"\n              loading=\"lazy\"\n              @error=\"handleBondPortraitError(entry.name)\"\n            />\n            <div v-else class=\"bond-portrait-fallback\">{{ entry.name.slice(0, 1) }}</div>\n          </button>\n          <div class=\"bond-affection-wrap\">\n            <div class=\"bond-affection-head\">\n              <span class=\"bond-role-name\">{{ entry.name }}</span>\n              <span\n                class=\"bond-affection-value\"\n                :class=\"entry.affection >= 0 ? 'bond-affection-value--positive' : 'bond-affection-value--negative'\"\n              >{{ formatBondAffection(entry.affection) }} / 1000</span>\n            </div>\n            <div class=\"bond-affection-track\">\n              <div\n                class=\"bond-affection-fill\"\n                :class=\"entry.affection >= 0 ? 'bond-affection-fill--positive' : 'bond-affection-fill--negative'\"\n                :style=\"{ width: `${Math.round(entry.affectionAbsRatio * 100)}%` }\"\n              ></div>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div v-else class=\"flex flex-col items-center justify-center gap-3 py-12\">\n        <Users class=\"size-12 text-dungeon-gold/20\" />\n        <span class=\"font-ui text-sm text-dungeon-paper/50\">暂无可显示的羁绊角色</span>\n      </div>\n    </DungeonModal>\n    <Transition name=\"combat-fade\">\n      <div v-if=\"bondPortraitPreview\" class=\"fixed inset-0 z-[230] flex items-center justify-center bg-black/85 p-6 backdrop-blur-sm\" @click=\"closeBondPortraitPreview\">\n        <div class=\"bond-preview-panel\" @click.stop>\n          <img :src=\"bondPortraitPreview.url\" :alt=\"`${bondPortraitPreview.name} 立绘大图`\" class=\"bond-preview-image\" />\n          <div class=\"bond-preview-footer\">\n            <span class=\"bond-preview-name\">{{ bondPortraitPreview.name }}</span>\n            <button type=\"button\" class=\"bond-preview-close-btn\" @click=\"closeBondPortraitPreview\">关闭</button>\n          </div>\n        </div>\n      </div>\n    </Transition>\n\n    <DungeonModal title=\"符文卡组\" :is-open=\"activeModal === 'deck'\" @close=\"activeModal = null\">\n      <div v-if=\"resolvedDeck.length > 0\" class=\"grid grid-cols-3 gap-8 overflow-y-auto max-h-[60%] p-4\">\n        <div v-for=\"(card, i) in resolvedDeck\" :key=\"i\" class=\"hover:scale-105 transition-transform flex justify-center\">\n          <DungeonCard :card=\"card\" disabled />\n        </div>\n      </div>\n      <div v-else class=\"flex flex-col items-center justify-center py-12 gap-4\">\n        <Scroll class=\"size-12 text-dungeon-gold/20\" />\n        <span class=\"font-ui text-dungeon-paper/40 text-sm\">卡组为空 — 尚未装备技能卡</span>\n      </div>\n    </DungeonModal>\n\n    <DungeonModal\n      title=\"魔法书\"\n      :is-open=\"activeModal === 'magicBooks'\"\n      panel-class=\"max-w-[92rem] max-h-[94%]\"\n      @close=\"activeModal = null\"\n    >\n      <div class=\"w-full max-w-[90rem] mx-auto flex flex-col gap-4\">\n        <div\n          v-if=\"carryableMagicBookNames.length > 0\"\n          class=\"grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6 max-h-[72vh] overflow-y-auto custom-scrollbar pr-1\"\n        >\n          <button\n            v-for=\"bookName in carryableMagicBookNames\"\n            :key=\"`magic-book-${bookName}`\"\n            type=\"button\"\n            class=\"relative rounded-lg border p-3 text-left transition-all duration-300 disabled:opacity-50 disabled:cursor-not-allowed bg-[#130c08]/80\"\n            :class=\"carriedMagicBookSet.has(bookName)\n              ? 'border-dungeon-gold/80 shadow-[0_0_20px_rgba(212,175,55,0.45)] ring-1 ring-dungeon-gold/70'\n              : 'border-dungeon-brown/70 hover:border-dungeon-gold/45'\"\n            :disabled=\"isUpdatingMagicBooks\"\n            @click=\"toggleMagicBook(bookName)\"\n          >\n            <div\n              class=\"relative w-full overflow-hidden rounded-md border\"\n              :class=\"carriedMagicBookSet.has(bookName) ? 'border-dungeon-gold/60' : 'border-dungeon-brown/60'\"\n            >\n              <img\n                :src=\"getMagicBookCoverUrl(bookName)\"\n                :alt=\"`${bookName} 魔法书封面`\"\n                class=\"w-full [aspect-ratio:832/1216] object-cover transition-all duration-300\"\n                :class=\"carriedMagicBookSet.has(bookName)\n                  ? 'brightness-100 saturate-110'\n                  : 'brightness-50 saturate-60'\"\n                loading=\"lazy\"\n              />\n              <div class=\"absolute inset-0 bg-gradient-to-t from-black/55 via-black/10 to-black/38\"></div>\n              <div class=\"absolute inset-x-2 top-2 z-10\">\n                <div class=\"magic-book-title text-center truncate text-[22px]\">{{ bookName }}之书</div>\n              </div>\n            </div>\n          </button>\n        </div>\n        <div v-else class=\"rounded border border-dungeon-brown/60 bg-dungeon-dark/40 py-8 text-center text-sm text-dungeon-paper/50\">\n          当前没有可选的附加魔法书。\n        </div>\n      </div>\n    </DungeonModal>\n\n    <DungeonModal\n      title=\"魔法帽\"\n      :is-open=\"activeModal === 'magicHat'\"\n      panel-class=\"max-w-3xl\"\n      @close=\"activeModal = null\"\n    >\n      <div class=\"w-full max-w-3xl mx-auto flex flex-col gap-5\">\n        <div class=\"rounded border border-dungeon-gold/30 bg-[#140d08]/70 px-4 py-3 flex items-center justify-between\">\n          <span class=\"font-ui text-dungeon-paper/75 text-sm\">可用技能点</span>\n          <span class=\"font-heading text-dungeon-gold text-xl\">{{ magicHatSkillPoints }}</span>\n        </div>\n\n        <div\n          v-for=\"track in magicHatTracks\"\n          :key=\"`magic-hat-${track.id}`\"\n          class=\"rounded border border-dungeon-brown/60 bg-[#160d08]/65 p-4\"\n        >\n          <div class=\"flex items-center justify-between gap-3\">\n            <div>\n              <div class=\"font-heading text-dungeon-gold text-base\">{{ track.label }}</div>\n              <div class=\"font-ui text-xs text-dungeon-paper/65 mt-1\">\n                当前 {{ track.currentValue }} · 等级 {{ track.currentLevel }}/{{ track.maxLevel }}\n              </div>\n            </div>\n            <button\n              type=\"button\"\n              class=\"px-3 py-1.5 rounded border text-xs font-ui transition-colors disabled:opacity-50 disabled:cursor-not-allowed\"\n              :class=\"track.isMax\n                ? 'border-dungeon-brown/60 text-dungeon-paper/45'\n                : 'border-dungeon-gold/45 text-dungeon-gold hover:bg-dungeon-gold/10'\"\n              :disabled=\"isUpgradingMagicHat || track.isMax\"\n              @click=\"upgradeMagicHatStat(track.id)\"\n            >\n              {{ track.isMax ? '已满级' : `升级（-${track.nextCost} 技能点）` }}\n            </button>\n          </div>\n          <div class=\"mt-3 h-2 rounded bg-black/45 border border-dungeon-brown/45 overflow-hidden\">\n            <div\n              class=\"h-full transition-all duration-300\"\n              :class=\"track.barClass\"\n              :style=\"{ width: `${track.progressPercent}%` }\"\n            ></div>\n          </div>\n          <div class=\"mt-2 font-ui text-[11px] text-dungeon-paper/60\">\n            {{ track.isMax ? '已达到可升级上限' : `下一级提升至 ${track.nextValue}` }}\n          </div>\n        </div>\n      </div>\n    </DungeonModal>\n\n    <DungeonModal title=\"圣遗物\" :is-open=\"activeModal === 'relics'\" @close=\"activeModal = null\">\n      <div v-if=\"relicEntries.length > 0\" class=\"grid grid-cols-3 sm:grid-cols-4 md:grid-cols-5 gap-x-6 gap-y-6 p-4 overflow-y-auto max-h-[60%]\">\n        <button\n          v-for=\"relic in relicEntries\"\n          :key=\"relic.name\"\n          type=\"button\"\n          class=\"relative flex flex-col items-center p-1.5 rounded border border-dungeon-brown/30 bg-[#1a0f08]/35 hover:border-dungeon-gold/40 transition-colors focus:outline-none focus:border-dungeon-gold/60\"\n          @mouseenter=\"showRelicTooltip($event, relic)\"\n          @mouseleave=\"hideRelicTooltip\"\n          @focus=\"showRelicTooltip($event, relic)\"\n          @blur=\"hideRelicTooltip\"\n          @touchstart.passive=\"handleRelicTouchStart($event, relic)\"\n          @touchend=\"handleRelicTouchEnd\"\n          @touchcancel=\"handleRelicTouchEnd\"\n        >\n          <div class=\"relative\">\n            <Box class=\"size-9 text-dungeon-gold/75\" />\n            <span class=\"absolute -bottom-1 -right-3 font-ui text-dungeon-gold/80 text-[10px] bg-dungeon-dark/70 border border-dungeon-brown/30 rounded px-0.5 leading-tight\">x{{ relic.count }}</span>\n          </div>\n          <span class=\"font-heading text-dungeon-gold text-[11px] text-center mt-1 leading-relaxed truncate w-full\">{{ relic.name }}</span>\n        </button>\n      </div>\n      <div v-else class=\"flex flex-col items-center justify-center py-12 gap-4\">\n        <Box class=\"size-12 text-dungeon-gold/20\" />\n        <span class=\"font-ui text-dungeon-paper/40 text-sm\">尚未获得圣遗物</span>\n      </div>\n    </DungeonModal>\n    <div\n      v-if=\"relicTooltip\"\n      class=\"fixed z-[220] pointer-events-none relic-tooltip\"\n      :style=\"{ left: `${relicTooltip.x}px`, top: `${relicTooltip.y}px` }\"\n    >\n      <div class=\"relic-tooltip-name\">{{ relicTooltip.name }}</div>\n      <div class=\"relic-tooltip-desc\">{{ relicTooltip.description }}</div>\n    </div>\n\n    <!-- Settings Modal -->\n    <DungeonModal title=\"系统设置\" :is-open=\"activeModal === 'settings'\" @close=\"activeModal = null\">\n      <div class=\"flex flex-col space-y-6 w-full max-w-lg mx-auto\">\n        <!-- Text Display Settings Section -->\n        <div>\n          <h3 class=\"font-heading text-dungeon-gold text-sm tracking-widest mb-4 uppercase\">正文显示</h3>\n          <div class=\"space-y-4\">\n            <!-- Font Size -->\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">字体大小</label>\n              <div class=\"flex items-center gap-2\">\n                <button class=\"w-7 h-7 rounded border border-dungeon-brown text-dungeon-gold-dim hover:border-dungeon-gold hover:text-dungeon-gold text-sm\" @click=\"textSettings.fontSize = Math.max(12, textSettings.fontSize - 1)\">−</button>\n                <span class=\"text-dungeon-paper font-ui text-sm w-10 text-center\">{{ textSettings.fontSize }}px</span>\n                <button class=\"w-7 h-7 rounded border border-dungeon-brown text-dungeon-gold-dim hover:border-dungeon-gold hover:text-dungeon-gold text-sm\" @click=\"textSettings.fontSize = Math.min(28, textSettings.fontSize + 1)\">+</button>\n              </div>\n            </div>\n\n            <!-- Line Height -->\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">行间距</label>\n              <div class=\"flex items-center gap-2\">\n                <button class=\"w-7 h-7 rounded border border-dungeon-brown text-dungeon-gold-dim hover:border-dungeon-gold hover:text-dungeon-gold text-sm\" @click=\"textSettings.lineHeight = Math.max(1.2, +(textSettings.lineHeight - 0.1).toFixed(1))\">−</button>\n                <span class=\"text-dungeon-paper font-ui text-sm w-10 text-center\">{{ textSettings.lineHeight }}</span>\n                <button class=\"w-7 h-7 rounded border border-dungeon-brown text-dungeon-gold-dim hover:border-dungeon-gold hover:text-dungeon-gold text-sm\" @click=\"textSettings.lineHeight = Math.min(3.0, +(textSettings.lineHeight + 0.1).toFixed(1))\">+</button>\n              </div>\n            </div>\n\n            <!-- Font Family -->\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">字体样式</label>\n              <select\n                v-model=\"textSettings.fontFamily\"\n                class=\"bg-[#1a0f08] border border-dungeon-brown text-dungeon-paper text-sm px-3 py-1.5 rounded focus:outline-none focus:border-dungeon-gold font-ui\"\n              >\n                <option value=\"'Cinzel', serif\">Cinzel (默认)</option>\n                <option value=\"'Inter', sans-serif\">Inter</option>\n                <option value=\"'MedievalSharp', cursive\">MedievalSharp</option>\n                <option value=\"'MaShanZheng', 'KaiTi', serif\">马善政体</option>\n                <option value=\"'MagicBookTitle', 'KaiTi', serif\">江湖琅琊体</option>\n                <option value=\"serif\">Serif</option>\n                <option value=\"sans-serif\">Sans-serif</option>\n                <option value=\"'Microsoft YaHei', sans-serif\">微软雅黑</option>\n                <option value=\"'SimSun', serif\">宋体</option>\n                <option value=\"'KaiTi', serif\">楷体</option>\n              </select>\n            </div>\n\n            <!-- Container Width -->\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">正文框宽度</label>\n              <div class=\"flex items-center gap-2\">\n                <input\n                  v-model.number=\"textSettings.containerWidth\"\n                  type=\"range\"\n                  min=\"600\"\n                  max=\"1600\"\n                  step=\"50\"\n                  class=\"w-28 accent-dungeon-gold\"\n                />\n                <span class=\"text-dungeon-paper font-ui text-sm w-14 text-center\">{{ textSettings.containerWidth }}px</span>\n              </div>\n            </div>\n\n            <!-- Background Clarity -->\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">背景清晰度</label>\n              <div class=\"flex items-center gap-2\">\n                <input\n                  v-model.number=\"bgOverlayOpacity\"\n                  type=\"range\"\n                  min=\"0\"\n                  max=\"0.8\"\n                  step=\"0.05\"\n                  class=\"w-28 accent-dungeon-gold\"\n                />\n                <span class=\"text-dungeon-paper font-ui text-sm w-14 text-center\">{{ Math.round((1 - bgOverlayOpacity) * 100) }}%</span>\n              </div>\n            </div>\n\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">背景音乐</label>\n              <select\n                v-model=\"selectedBgmTrackId\"\n                :disabled=\"bgmTracks.length === 0\"\n                class=\"bg-[#1a0f08] border border-dungeon-brown text-dungeon-paper text-sm px-3 py-1.5 rounded focus:outline-none focus:border-dungeon-gold font-ui disabled:opacity-50 disabled:cursor-not-allowed\"\n              >\n                <option v-if=\"bgmTracks.length === 0\" value=\"\">暂无可用曲目</option>\n                <option v-for=\"track in bgmTracks\" :key=\"track.id\" :value=\"track.id\">\n                  {{ track.name }}\n                </option>\n              </select>\n            </div>\n\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">背景音乐音量</label>\n              <div class=\"flex items-center gap-2\">\n                <input\n                  v-model.number=\"bgmVolumePercent\"\n                  type=\"range\"\n                  min=\"0\"\n                  max=\"100\"\n                  step=\"1\"\n                  class=\"w-28 accent-dungeon-gold\"\n                />\n                <span class=\"text-dungeon-paper font-ui text-sm w-14 text-center\">{{ bgmVolumePercent }}%</span>\n              </div>\n            </div>\n\n            <div class=\"flex items-center justify-between\">\n              <label class=\"text-dungeon-paper/70 text-sm font-ui\">启用流式传输</label>\n              <label class=\"inline-flex items-center gap-2 cursor-pointer select-none\">\n                <input\n                  v-model=\"isStreamingEnabled\"\n                  type=\"checkbox\"\n                  class=\"h-4 w-4 accent-dungeon-gold\"\n                />\n                <span class=\"text-dungeon-paper text-sm font-ui\">{{ isStreamingEnabled ? '开启' : '关闭' }}</span>\n              </label>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"h-[1px] w-full bg-dungeon-gold/20\"></div>\n\n        <!-- System Section -->\n        <div>\n          <h3 class=\"font-heading text-dungeon-gold text-sm tracking-widest mb-4 uppercase\">系统</h3>\n          <div class=\"grid grid-cols-2 gap-4\">\n            <button\n              class=\"p-3 border border-dungeon-gold/30 hover:bg-dungeon-brown text-dungeon-gold text-sm rounded\"\n              @click=\"toggleFullScreen\"\n            >\n              切换全屏模式\n            </button>\n            <button\n              class=\"p-3 border border-red-900/50 hover:bg-red-950/30 text-red-500 text-sm rounded\"\n              @click=\"$emit('backToSplash')\"\n            >\n              退出到标题\n            </button>\n            <button\n              class=\"p-3 border border-amber-600/40 hover:bg-amber-900/20 text-amber-400 text-sm rounded col-span-2\"\n              @click=\"openCombatTestBuilder\"\n            >\n              ⚔ 进入战斗测试\n            </button>\n          </div>\n        </div>\n      </div>\n    </DungeonModal>\n\n    <!-- Combat Test Builder Modal -->\n    <DungeonModal title=\"战斗测试配置\" :is-open=\"activeModal === 'combatTestBuilder'\" @close=\"activeModal = null\">\n      <div class=\"flex flex-col gap-4 w-full max-w-4xl\">\n        <template v-if=\"combatTestStep === 'deck'\">\n          <div class=\"flex items-center justify-between\">\n            <h3 class=\"font-heading text-dungeon-gold text-sm tracking-widest uppercase\">步骤1：组建卡组（9张）</h3>\n            <span class=\"text-xs font-ui text-dungeon-paper/70\">{{ selectedTestDeck.length }}/9</span>\n          </div>\n\n          <div class=\"rounded border border-dungeon-brown/60 bg-dungeon-dark/50 p-3\">\n            <div class=\"mb-2 flex items-center justify-between\">\n              <span class=\"text-[11px] text-dungeon-paper/70\">已选卡牌（点击移除）</span>\n              <span class=\"text-[11px] text-dungeon-gold/80\">{{ selectedTestDeck.length }}/9</span>\n            </div>\n            <div class=\"max-h-52 overflow-y-auto custom-scrollbar pr-1 space-y-1.5\">\n              <button\n                v-for=\"entry in selectedTestDeckCards\"\n                :key=\"`selected-card-${entry.idx}`\"\n                class=\"w-full text-left flex items-stretch gap-2 rounded border border-dungeon-gold/20 bg-[#1a0f08]/70 px-2 py-2 hover:border-dungeon-gold/50 transition-colors\"\n                @click=\"removeCardFromTestDeck(entry.idx)\"\n              >\n                <span class=\"w-1.5 rounded\" :class=\"getCardCategoryStripClass(entry.card.category)\"></span>\n                <div class=\"min-w-0 flex-1\">\n                  <div class=\"flex items-center gap-1.5\">\n                    <span class=\"text-xs font-heading text-dungeon-gold truncate\">{{ entry.card.name }}</span>\n                    <span class=\"text-[10px] px-1 rounded border\" :class=\"getCardTypeBadgeClass(entry.card.type)\">{{ entry.card.type }}</span>\n                    <span class=\"text-[10px] px-1 rounded border border-white/15 text-dungeon-paper/60\">{{ entry.card.category }}</span>\n                  </div>\n                  <div class=\"mt-1 text-[10px] text-dungeon-paper/70 truncate\" :title=\"entry.card.description\">{{ entry.card.description }}</div>\n                </div>\n                <span class=\"text-[10px] text-red-300/85 shrink-0 self-center\">移除</span>\n              </button>\n              <div\n                v-if=\"selectedTestDeckCards.length === 0\"\n                class=\"rounded border border-dungeon-brown/40 bg-black/20 py-6 text-center text-xs text-dungeon-paper/40\"\n              >\n                尚未选择卡牌\n              </div>\n            </div>\n            <div class=\"mt-2 grid grid-cols-9 gap-1\">\n              <div\n                v-for=\"idx in 9\"\n                :key=\"`deck-slot-${idx}`\"\n                class=\"h-2 rounded border\"\n                :class=\"idx <= selectedTestDeck.length\n                  ? 'bg-dungeon-gold/70 border-dungeon-gold/60'\n                  : 'bg-black/20 border-dungeon-brown/40'\"\n              ></div>\n            </div>\n          </div>\n\n          <div class=\"max-h-[42vh] overflow-y-auto rounded border border-dungeon-brown/60 bg-dungeon-dark/40 p-3 custom-scrollbar\">\n            <div class=\"space-y-3\">\n              <div class=\"flex items-center gap-1 overflow-x-auto pb-1 custom-scrollbar\">\n                <button\n                  v-for=\"category in cardCategoryTabsForTest\"\n                  :key=\"`card-tab-${category}`\"\n                  class=\"h-7 px-3 rounded border text-xs shrink-0 transition-colors\"\n                  :class=\"selectedCardCategoryTab === category\n                    ? 'bg-dungeon-gold/20 border-dungeon-gold/70 text-dungeon-gold'\n                    : 'bg-[#1a0f08]/80 border-dungeon-brown/70 text-dungeon-paper/70 hover:border-dungeon-gold/50 hover:text-dungeon-gold/90'\"\n                  @click=\"selectedCardCategoryTab = category\"\n                >\n                  {{ category }}\n                </button>\n              </div>\n              <div\n                v-for=\"group in filteredCardCategoryGroupsForTest\"\n                :key=\"`card-category-${group.category}`\"\n                class=\"rounded border border-dungeon-brown/40 bg-[#110a06]/40 p-2\"\n              >\n                <div class=\"mb-2 flex items-center justify-between\">\n                  <h4 class=\"font-heading text-[11px] tracking-wider uppercase text-dungeon-gold/90\">{{ group.category }}</h4>\n                  <span class=\"text-[10px] text-dungeon-paper/50\">{{ group.cards.length }} 张</span>\n                </div>\n                <div class=\"grid grid-cols-2 md:grid-cols-3 gap-4\">\n                  <button\n                    v-for=\"card in group.cards\"\n                    :key=\"`all-card-${group.category}-${card.id}`\"\n                    class=\"hover:scale-105 transition-transform flex flex-col items-center rounded border border-dungeon-brown/40 bg-[#1a0f08]/50 p-2 disabled:opacity-40 disabled:cursor-not-allowed\"\n                    :disabled=\"selectedTestDeck.length >= 9\"\n                    @click=\"addCardToTestDeck(card.name)\"\n                  >\n                    <DungeonCard :card=\"card\" disabled />\n                    <span class=\"mt-1 text-[10px] text-dungeon-gold/80\">点击加入</span>\n                  </button>\n                </div>\n              </div>\n              <div\n                v-if=\"filteredCardCategoryGroupsForTest.length === 0\"\n                class=\"rounded border border-dungeon-brown/40 bg-black/20 py-6 text-center text-xs text-dungeon-paper/40\"\n              >\n                当前分类暂无可选卡牌\n              </div>\n            </div>\n          </div>\n\n          <div class=\"flex justify-end gap-3\">\n            <button\n              class=\"px-4 py-2 rounded border border-dungeon-brown text-dungeon-paper/70 hover:border-dungeon-gold/50\"\n              @click=\"activeModal = null\"\n            >\n              取消\n            </button>\n            <button\n              class=\"px-4 py-2 rounded border border-dungeon-gold/40 text-dungeon-gold hover:bg-dungeon-brown disabled:opacity-40 disabled:cursor-not-allowed\"\n              :disabled=\"selectedTestDeck.length !== 9\"\n              @click=\"confirmCombatTestDeck\"\n            >\n              下一步：选择魔物\n            </button>\n          </div>\n        </template>\n\n        <template v-else>\n          <div class=\"flex items-center justify-between\">\n            <h3 class=\"font-heading text-dungeon-gold text-sm tracking-widest uppercase\">步骤2：选择魔物</h3>\n            <span class=\"text-xs font-ui text-dungeon-paper/70\">已选卡组: 9张｜圣遗物: {{ selectedRelicTotalCount }} 件</span>\n          </div>\n\n          <div class=\"max-h-[42vh] overflow-y-auto rounded border border-dungeon-brown/60 bg-dungeon-dark/40 p-2 custom-scrollbar\">\n            <div class=\"grid grid-cols-2 md:grid-cols-3 gap-2\">\n              <button\n                v-for=\"enemyName in allEnemyNamesForTest\"\n                :key=\"`enemy-${enemyName}`\"\n                class=\"text-left px-3 py-2 rounded border text-xs transition-colors\"\n                :class=\"selectedTestEnemy === enemyName\n                  ? 'border-dungeon-gold bg-dungeon-brown/60 text-dungeon-gold'\n                  : 'border-dungeon-brown/60 bg-[#1a0f08] text-dungeon-paper hover:border-dungeon-gold/60'\"\n                @click=\"selectedTestEnemy = enemyName\"\n              >\n                {{ enemyName }}\n              </button>\n            </div>\n          </div>\n\n          <div class=\"rounded border border-dungeon-brown/60 bg-dungeon-dark/40 p-3\">\n            <div class=\"mb-2 flex items-center justify-between\">\n              <h4 class=\"font-heading text-dungeon-gold text-xs tracking-wider uppercase\">圣遗物自选</h4>\n              <span class=\"text-[11px] text-dungeon-paper/60\">将同步写入 MVU `_圣遗物`</span>\n            </div>\n            <div class=\"max-h-[28vh] overflow-y-auto custom-scrollbar pr-1\">\n              <div class=\"space-y-2\">\n                <div class=\"flex items-center gap-1 overflow-x-auto pb-1 custom-scrollbar\">\n                  <button\n                    v-for=\"category in relicCategoryTabsForTest\"\n                    :key=\"`relic-tab-${category}`\"\n                    class=\"h-7 px-3 rounded border text-xs shrink-0 transition-colors\"\n                    :class=\"selectedRelicCategoryTab === category\n                      ? 'bg-dungeon-gold/20 border-dungeon-gold/70 text-dungeon-gold'\n                      : 'bg-[#1a0f08]/80 border-dungeon-brown/70 text-dungeon-paper/70 hover:border-dungeon-gold/50 hover:text-dungeon-gold/90'\"\n                    @click=\"selectedRelicCategoryTab = category\"\n                  >\n                    {{ category }}\n                  </button>\n                </div>\n                <div\n                  v-for=\"group in filteredRelicCategoryGroupsForTest\"\n                  :key=\"`relic-category-${group.category}`\"\n                  class=\"rounded border border-dungeon-brown/40 bg-[#110a06]/40 p-2\"\n                >\n                  <div class=\"mb-2 flex items-center justify-between\">\n                    <h5 class=\"font-heading text-[11px] tracking-wider uppercase text-dungeon-gold/90\">{{ group.category }}</h5>\n                    <span class=\"text-[10px] text-dungeon-paper/50\">{{ group.relics.length }} 件</span>\n                  </div>\n                  <div class=\"grid grid-cols-1 md:grid-cols-2 gap-2\">\n                    <div\n                      v-for=\"relic in group.relics\"\n                      :key=\"`test-relic-${group.category}-${relic.id}`\"\n                      class=\"rounded border border-dungeon-brown/50 bg-[#1a0f08]/70 p-2\"\n                    >\n                      <div class=\"flex items-start justify-between gap-2\">\n                        <div class=\"min-w-0\">\n                          <div class=\"text-xs font-heading text-dungeon-gold truncate\">{{ relic.name }}</div>\n                          <div class=\"text-[10px] text-dungeon-paper/60\">{{ relic.rarity }}</div>\n                        </div>\n                        <div class=\"flex items-center gap-1 shrink-0\">\n                          <button\n                            class=\"h-6 w-6 rounded border border-dungeon-brown text-dungeon-paper/70 hover:border-dungeon-gold\"\n                            @click=\"decreaseSelectedRelic(relic.name)\"\n                          >\n                            -\n                          </button>\n                          <span class=\"w-6 text-center text-xs text-dungeon-gold\">{{ getSelectedTestRelicCount(relic.name) }}</span>\n                          <button\n                            class=\"h-6 w-6 rounded border border-dungeon-gold/40 text-dungeon-gold hover:bg-dungeon-brown\"\n                            @click=\"increaseSelectedRelic(relic.name)\"\n                          >\n                            +\n                          </button>\n                        </div>\n                      </div>\n                      <div class=\"mt-1 text-[10px] text-dungeon-paper/70 leading-relaxed\">{{ relic.effect }}</div>\n                    </div>\n                  </div>\n                </div>\n                <div\n                  v-if=\"filteredRelicCategoryGroupsForTest.length === 0\"\n                  class=\"rounded border border-dungeon-brown/40 bg-black/20 py-6 text-center text-xs text-dungeon-paper/40\"\n                >\n                  当前分类暂无可选圣遗物\n                </div>\n              </div>\n            </div>\n          </div>\n\n          <label class=\"flex items-center gap-2 px-3 py-2 rounded border border-dungeon-brown/60 bg-dungeon-dark/40 text-sm text-dungeon-paper/80\">\n            <input v-model=\"combatTestStartAt999\" type=\"checkbox\" class=\"accent-amber-500\" />\n            <span>本场测试启用 999 开局（敌我双方 HP/MP=999）</span>\n          </label>\n\n          <div class=\"flex justify-between gap-3\">\n            <button\n              class=\"px-4 py-2 rounded border border-dungeon-brown text-dungeon-paper/70 hover:border-dungeon-gold/50\"\n              @click=\"combatTestStep = 'deck'\"\n            >\n              返回改卡组\n            </button>\n            <button\n              class=\"px-4 py-2 rounded border border-amber-600/40 text-amber-400 hover:bg-amber-900/20 disabled:opacity-40 disabled:cursor-not-allowed\"\n              :disabled=\"!selectedTestEnemy\"\n              @click=\"confirmCombatTestEnemyAndStart\"\n            >\n              开始战斗测试\n            </button>\n          </div>\n        </template>\n      </div>\n    </DungeonModal>\n\n    <!-- Save/Load Panel -->\n    <SaveLoadPanel\n      :is-open=\"gameStore.isSaveLoadOpen\"\n      :entries=\"gameStore.saveEntries\"\n      @close=\"gameStore.isSaveLoadOpen = false\"\n    />\n\n    <!-- Variable Update Viewer -->\n    <DungeonModal title=\"变量更新\" :is-open=\"isVariableUpdateOpen\" @close=\"isVariableUpdateOpen = false\">\n      <div\n        v-if=\"gameStore.variableUpdateText\"\n        class=\"custom-scrollbar border-dungeon-brown/50 bg-dungeon-dark/60 max-h-[60vh]\n               overflow-y-auto rounded border p-4\"\n      >\n        <pre class=\"text-dungeon-paper/80 font-ui text-sm break-words whitespace-pre-wrap\">{{ gameStore.variableUpdateText }}</pre>\n      </div>\n      <div v-else class=\"text-dungeon-paper/60 font-ui py-8 text-center text-sm\">\n        当前楼层没有检测到变量更新标签（&lt;UpdateVariable&gt; 或 &lt;update&gt;）。\n      </div>\n    </DungeonModal>\n\n    <!-- Shop Overlay -->\n    <Transition name=\"combat-fade\">\n      <div v-if=\"showShopView\" class=\"absolute inset-0 z-[94] bg-black\">\n        <img\n          :src=\"shopBackgroundUrl\"\n          class=\"absolute inset-0 h-full w-full object-cover\"\n          alt=\"商店背景\"\n        />\n        <div class=\"absolute inset-0 bg-black/22\"></div>\n\n        <img\n          v-if=\"!isMerchantDefeated\"\n          :src=\"shopMerchantPortraitUrl\"\n          class=\"pointer-events-none absolute left-0 bottom-0 z-[99] h-[92vh] max-h-[1216px] w-auto object-contain\"\n          alt=\"沐芯兰\"\n        />\n\n        <div class=\"shop-layout absolute inset-y-0 right-0 z-[96] flex items-center px-4 md:px-7\">\n          <div class=\"shop-panel ml-auto w-full max-w-[48rem] h-[84vh] max-h-[860px]\">\n            <div class=\"shop-panel-head\">\n              <div class=\"font-heading text-xl text-amber-100\">沐芯兰的商店</div>\n            </div>\n\n            <div class=\"shop-goods-grid custom-scrollbar\">\n              <button\n                v-for=\"item in shopProducts\"\n                :key=\"item.key\"\n                type=\"button\"\n                class=\"shop-item-card\"\n                :class=\"{ 'is-sold': item.sold }\"\n                :disabled=\"item.sold || shopBuying\"\n                @click=\"buyShopProduct(item)\"\n                @mouseenter=\"showShopProductTooltip($event, item)\"\n                @mouseleave=\"hideRelicTooltip\"\n                @focus=\"showShopProductTooltip($event, item)\"\n                @blur=\"hideRelicTooltip\"\n                @touchstart.passive=\"handleShopProductTouchStart($event, item)\"\n                @touchend=\"handleRelicTouchEnd\"\n                @touchcancel=\"handleRelicTouchEnd\"\n              >\n                <div class=\"shop-item-icon-wrap\">\n                  <Box class=\"shop-item-icon\" />\n                </div>\n                <div class=\"shop-item-price\">\n                  <Coins class=\"size-3.5\" />\n                  <span>{{ item.finalPrice }}</span>\n                </div>\n              </button>\n\n              <div\n                v-if=\"shopProducts.length === 0\"\n                class=\"rounded border border-amber-200/15 bg-black/25 py-10 text-center text-sm text-amber-100/65\"\n              >\n                暂无可售商品\n              </div>\n            </div>\n\n            <div class=\"shop-panel-foot\">\n              <button\n                class=\"shop-rob-btn px-5 py-2 font-ui text-xs tracking-wider text-amber-50\"\n                :disabled=\"shopBuying || gameStore.isGenerating || shopRobbing || isMerchantDefeated\"\n                :style=\"{ opacity: shopRobBtnOpacity }\"\n                @click=\"handleShopRobClick\"\n              >\n                抢夺\n              </button>\n              <button\n                class=\"shop-exit-btn px-7 py-3 font-ui text-sm tracking-wider text-amber-50\"\n                :disabled=\"shopBuying || gameStore.isGenerating || shopRobbing\"\n                @click=\"exitShop\"\n              >\n                退出商店\n              </button>\n            </div>\n          </div>\n        </div>\n      </div>\n    </Transition>\n\n    <!-- Treasure Chest Overlay -->\n    <Transition name=\"combat-fade\">\n      <div\n        v-if=\"showChestView\"\n        class=\"absolute inset-0 z-[95] bg-black\"\n        @contextmenu.prevent=\"handleChestContextMenu\"\n        @touchstart.passive=\"handleChestTouchStart\"\n        @touchend=\"handleChestTouchEnd\"\n        @touchcancel=\"handleChestTouchEnd\"\n      >\n        <img\n          :src=\"chestBackgroundUrl\"\n          class=\"absolute inset-0 h-full w-full object-cover\"\n          alt=\"宝箱界面背景\"\n          @load=\"handleChestBgLoaded\"\n        />\n\n        <div\n          v-if=\"chestStage === 'opened'\"\n          class=\"pointer-events-none absolute inset-0\"\n        >\n          <div\n            v-if=\"chestRewardVisible && chestRewardRelics.length > 0\"\n            class=\"chest-reward-anchor\"\n            :class=\"{ 'is-multi': chestRewardRelics.length > 1 }\"\n          >\n            <button\n              v-for=\"(relic, i) in chestRewardRelics\"\n              :key=\"`chest-reward-${relic.id}-${i}`\"\n              type=\"button\"\n              class=\"pointer-events-auto chest-reward-btn\"\n              :class=\"{ 'is-collected': chestRewardCollectedFlags[i] }\"\n              :disabled=\"chestCollecting || chestRewardCollectedFlags[i]\"\n              @click=\"collectChestReward(i)\"\n              @mouseenter=\"showChestRewardTooltip($event, i)\"\n              @mouseleave=\"hideRelicTooltip\"\n              @focus=\"showChestRewardTooltip($event, i)\"\n              @blur=\"hideRelicTooltip\"\n              @touchstart.passive=\"handleChestRewardTouchStart($event, i)\"\n              @touchend=\"handleRelicTouchEnd\"\n              @touchcancel=\"handleRelicTouchEnd\"\n            >\n              <Box class=\"chest-reward-icon\" />\n            </button>\n          </div>\n\n          <div class=\"pointer-events-auto chest-portals-anchor w-full\">\n            <div class=\"flex justify-center gap-4 flex-wrap\">\n              <button\n                v-for=\"(portal, i) in chestPortalChoices\"\n                :key=\"`chest-portal-${i}`\"\n                class=\"portal-btn group relative flex flex-col items-center justify-center\n                       w-24 h-24 rounded-lg border-2 backdrop-blur-sm\n                       transition-all duration-500 hover:scale-110 active:scale-95 disabled:opacity-40 disabled:cursor-not-allowed\"\n                :style=\"{\n                  backgroundColor: portal.bgColor,\n                  borderColor: portal.borderColor,\n                  boxShadow: `0 0 15px ${portal.glowColor}, 0 0 30px ${portal.glowColor}40`,\n                }\"\n                :disabled=\"chestCollecting\"\n                @click=\"handleChestPortalClick(portal)\"\n              >\n                <div\n                  class=\"absolute inset-0 rounded-lg opacity-50 group-hover:opacity-100 transition-opacity duration-500\"\n                  :style=\"{ boxShadow: `inset 0 0 20px ${portal.glowColor}60` }\"\n                ></div>\n                <span class=\"text-2xl mb-1 relative z-10 drop-shadow-lg\">{{ portal.icon }}</span>\n                <span\n                  class=\"text-[10px] font-ui tracking-wide relative z-10 text-center leading-tight\"\n                  :style=\"{ color: portal.textColor }\"\n                >{{ portal.label }}</span>\n                <div\n                  class=\"absolute inset-1 rounded-md border border-dashed opacity-30 group-hover:opacity-70\n                         animate-[spin_8s_linear_infinite] transition-opacity\"\n                  :style=\"{ borderColor: portal.borderColor }\"\n                ></div>\n              </button>\n            </div>\n          </div>\n        </div>\n\n        <button\n          v-if=\"chestStage === 'closed'\"\n          type=\"button\"\n          aria-label=\"开启宝箱\"\n          class=\"absolute left-1/2 top-1/2 h-[42vh] max-h-[360px] min-h-[220px] w-[36vw] max-w-[540px] min-w-[260px] -translate-x-1/2 -translate-y-1/2 cursor-pointer rounded-2xl border-0 bg-transparent p-0 opacity-0\"\n          :disabled=\"chestRolling\"\n          @click=\"handleChestCenterClick\"\n        ></button>\n      </div>\n    </Transition>\n\n    <!-- Idol Overlay -->\n    <Transition name=\"combat-fade\">\n      <div\n        v-if=\"showIdolView\"\n        class=\"absolute inset-0 z-[96] bg-black overflow-hidden\"\n        @pointermove=\"handleIdolDicePointerMove\"\n        @pointerup=\"handleIdolDicePointerUp\"\n        @pointercancel=\"handleIdolDicePointerUp\"\n      >\n        <img\n          :src=\"idolBackgroundUrl\"\n          class=\"absolute inset-0 h-full w-full object-cover\"\n          alt=\"神像界面背景\"\n        />\n\n        <div class=\"idol-layout absolute inset-0 z-[97]\">\n          <div class=\"idol-slots-row\">\n            <div class=\"idol-slot-wrap\">\n              <div class=\"idol-slot-hint\">增加1倍点数的生命上限</div>\n              <div\n                ref=\"idolSlotMaxHpRef\"\n                class=\"idol-slot\"\n                :class=\"{\n                  'is-preview': idolSnapPreviewTarget === 'maxHp',\n                  'is-selected': idolAssignedTarget === 'maxHp',\n                }\"\n              ></div>\n            </div>\n            <div class=\"idol-slot-wrap\">\n              <div class=\"idol-slot-hint\">增加1倍点数的初始魔力</div>\n              <div\n                ref=\"idolSlotMpRef\"\n                class=\"idol-slot\"\n                :class=\"{\n                  'is-preview': idolSnapPreviewTarget === 'mp',\n                  'is-selected': idolAssignedTarget === 'mp',\n                }\"\n              ></div>\n            </div>\n            <div class=\"idol-slot-wrap\">\n              <div class=\"idol-slot-hint\">增加2倍点数的金币</div>\n              <div\n                ref=\"idolSlotGoldRef\"\n                class=\"idol-slot\"\n                :class=\"{\n                  'is-preview': idolSnapPreviewTarget === 'gold',\n                  'is-selected': idolAssignedTarget === 'gold',\n                }\"\n              ></div>\n            </div>\n          </div>\n\n          <div ref=\"idolDiceStageRef\" class=\"idol-dice-stage\">\n            <div\n              ref=\"idolDiceRef\"\n              class=\"idol-dice-draggable\"\n              :class=\"{ 'is-locked': idolDiceRolling }\"\n              :style=\"{ transform: `translate(${idolDicePosition.x}px, ${idolDicePosition.y}px)` }\"\n              @pointerdown=\"handleIdolDicePointerDown\"\n            >\n              <DungeonDice\n                :value=\"idolDiceValue\"\n                :rolling=\"idolDiceRolling\"\n                color=\"gold\"\n                size=\"lg\"\n                :rolling-min=\"idolDiceMin\"\n                :rolling-max=\"idolDiceMax\"\n              />\n            </div>\n          </div>\n        </div>\n\n        <button\n          class=\"idol-exit-btn absolute right-5 bottom-5 z-[98] px-6 py-3 font-ui text-sm tracking-wider text-amber-50\"\n          :disabled=\"gameStore.isGenerating\"\n          @click=\"exitIdolView\"\n        >\n          退出\n        </button>\n      </div>\n    </Transition>\n\n    <!-- Victory Card Reward Overlay -->\n    <Transition name=\"combat-fade\">\n      <div v-if=\"showVictoryRewardView\" class=\"absolute inset-0 z-[102] bg-black/90\">\n        <div class=\"absolute inset-0 p-6 md:p-10 flex items-center justify-center\">\n          <div class=\"w-full max-w-6xl rounded-xl border border-dungeon-gold/35 bg-[#0f0906]/95 p-5 md:p-7 shadow-[0_0_28px_rgba(212,175,55,0.2)]\">\n            <div class=\"mb-4 flex items-center justify-between gap-3\">\n              <div>\n                <div class=\"font-heading text-xl text-dungeon-gold\">战胜奖励</div>\n                <div class=\"text-xs text-dungeon-paper/65 mt-1\">\n                  {{ victoryRewardStage === 'pick' ? '请选择 1 张奖励卡牌' : '选择要替换的卡组槽位（共9槽）' }}\n                </div>\n              </div>\n              <div class=\"flex items-center gap-2\">\n                <button\n                  v-if=\"canRefreshVictoryReward\"\n                  class=\"px-4 py-2 rounded border border-sky-500/50 text-sky-200 hover:bg-sky-500/10 disabled:opacity-50\"\n                  :disabled=\"rewardApplying\"\n                  @click=\"refreshVictoryRewardOptions\"\n                >\n                  刷新奖励\n                </button>\n                <button\n                  class=\"px-4 py-2 rounded border border-dungeon-brown text-dungeon-paper/75 hover:border-dungeon-gold/50\"\n                  :disabled=\"rewardApplying\"\n                  @click=\"exitVictoryRewardFlow\"\n                >\n                  退出\n                </button>\n              </div>\n            </div>\n\n            <template v-if=\"victoryRewardStage === 'pick'\">\n              <div class=\"grid grid-cols-1 md:grid-cols-3 gap-5\">\n                <button\n                  v-for=\"card in victoryRewardOptions\"\n                  :key=\"`reward-option-${card.id}`\"\n                  type=\"button\"\n                  class=\"rounded-lg border border-dungeon-brown/50 bg-[#160d08]/75 p-3 transition-all hover:border-dungeon-gold/60 hover:scale-[1.01]\"\n                  @click=\"pickVictoryRewardCard(card)\"\n                >\n                  <div class=\"flex justify-center\">\n                    <DungeonCard :card=\"card\" disabled />\n                  </div>\n                  <div class=\"mt-2 text-center text-xs text-dungeon-gold/90\">选择此卡</div>\n                </button>\n              </div>\n            </template>\n\n            <template v-else>\n              <div class=\"mb-4 rounded border border-dungeon-gold/25 bg-black/20 p-3\">\n                <div class=\"text-xs text-dungeon-paper/70 mb-2\">已选择奖励卡：</div>\n                <div class=\"flex justify-center\">\n                  <DungeonCard v-if=\"selectedVictoryRewardCard\" :card=\"selectedVictoryRewardCard\" disabled />\n                </div>\n              </div>\n\n              <div\n                v-if=\"rewardReplaceEntries.length === 0\"\n                class=\"rounded border border-dungeon-brown/50 bg-black/20 p-4 text-center\"\n              >\n                <div class=\"text-sm text-dungeon-paper/70\">当前卡组为空，将奖励卡加入卡组。</div>\n                <button\n                  type=\"button\"\n                  class=\"mt-3 px-4 py-2 rounded border border-dungeon-gold/45 text-dungeon-gold hover:bg-dungeon-gold/10 disabled:opacity-50\"\n                  :disabled=\"rewardApplying\"\n                  @click=\"replaceDeckCardWithReward(0)\"\n                >\n                  加入卡组\n                </button>\n              </div>\n\n              <div\n                v-if=\"rewardReplaceEntries.length > 0\"\n                class=\"grid grid-cols-1 md:grid-cols-3 gap-4 max-h-[52vh] overflow-y-auto custom-scrollbar pr-1\"\n              >\n                <button\n                  v-for=\"entry in rewardReplaceEntries\"\n                  :key=\"`reward-replace-${entry.idx}`\"\n                  type=\"button\"\n                  class=\"rounded border border-dungeon-brown/50 bg-[#160d08]/65 p-3 text-left transition-colors hover:border-dungeon-gold/60 disabled:opacity-50 disabled:cursor-not-allowed\"\n                  :disabled=\"rewardApplying\"\n                  @click=\"replaceDeckCardWithReward(entry.idx)\"\n                >\n                  <div class=\"text-[11px] text-dungeon-paper/65 mb-2\">槽位 {{ entry.idx + 1 }}</div>\n                  <div class=\"flex justify-center\">\n                    <DungeonCard v-if=\"entry.card\" :card=\"entry.card\" disabled />\n                    <div v-else class=\"w-[180px] h-[250px] rounded border border-dungeon-brown/45 flex items-center justify-center text-xs text-dungeon-paper/55\">\n                      {{ entry.name || '空槽位' }}\n                    </div>\n                  </div>\n                </button>\n              </div>\n            </template>\n          </div>\n        </div>\n      </div>\n    </Transition>\n\n    <!-- Combat Overlay -->\n    <Transition name=\"combat-fade\">\n      <div v-if=\"showCombat\" class=\"absolute inset-0 z-[100] bg-black\">\n        <CombatView\n          class=\"w-full h-full\"\n          :enemy-name=\"combatEnemyName\"\n          :player-deck=\"resolvedDeck\"\n          :player-relics=\"combatRelicMap\"\n          :test-start-at-999=\"combatTestStartAt999CurrentBattle\"\n          :track-discovery=\"activeCombatContext !== 'combatTest'\"\n          :ui-font-family=\"textSettings.fontFamily\"\n          :initial-player-stats=\"{\n            hp: displayHp,\n            maxHp: displayMaxHp,\n            mp: displayMp,\n            minDice: displayMinDice || 1,\n            maxDice: displayMaxDice || 6,\n            effects: [{ type: EffectType.MANA_SPRING, stacks: 1, polarity: 'buff' as const }],\n          }\"\n          @end-combat=\"handleCombatEnd\"\n          @open-deck=\"activeModal = 'deck'\"\n          @open-relics=\"activeModal = 'relics'\"\n        />\n        <!-- Exit combat button -->\n        <button\n          class=\"absolute top-4 right-4 z-[110] px-4 py-2 bg-red-950/80 border border-red-700/50 text-red-300 text-sm rounded-lg\n                 hover:bg-red-900/80 hover:border-red-600 transition-all backdrop-blur-sm\"\n          @click=\"showCombat = false\"\n        >\n          ✕ 退出战斗\n        </button>\n      </div>\n    </Transition>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {\n  Activity,\n  Book,\n  BookOpen,\n  Box,\n  ChevronDown,\n  Coins,\n  Dices,\n  FileText,\n  Lock,\n  Map as MapIcon,\n  Maximize,\n  Scroll,\n  Send,\n  Settings as SettingsIcon,\n  Users,\n} from 'lucide-vue-next';\nimport { getAllCards, resolveCardNames } from '../battle/cardRegistry';\nimport { getAllEnemyNames, getEnemyByName } from '../battle/enemyRegistry';\nimport { getAllRelics, getRelicById, getRelicByName, type RelicData } from '../battle/relicRegistry';\nimport { bgmTrackId, bgmTracks, bgmVolume, setBgmTrack, setBgmVolume } from '../bgm';\nimport { recordEncounteredCards, recordEncounteredRelics } from '../codexStore';\nimport { FLOOR_MAP, getFloorForArea, getNextFloor } from '../floor';\nimport { toggleFullScreen } from '../fullscreen';\nimport { useGameStore } from '../gameStore';\nimport { CardType, EffectType, type CardData } from '../types';\nimport CombatView from './CombatView.vue';\nimport DungeonCard from './DungeonCard.vue';\nimport DungeonDice from './DungeonDice.vue';\nimport DungeonModal from './DungeonModal.vue';\nimport SaveLoadPanel from './SaveLoadPanel.vue';\n\ndefineEmits<{\n  backToSplash: [];\n}>();\n\nconst SidebarIcon = defineComponent({\n  props: {\n    icon: { type: Object, required: true },\n    active: { type: Boolean, default: false },\n    label: { type: String, default: '' },\n    tooltipSide: { type: String, default: 'right' },\n    disabled: { type: Boolean, default: false },\n    highlight: { type: Boolean, default: false },\n  },\n  emits: ['click'],\n  setup(props, { emit }) {\n    return () =>\n      h(\n        'button',\n        {\n          disabled: props.disabled,\n          class: [\n            'w-12 h-12 rounded-lg flex items-center justify-center transition-all duration-300 shadow-lg border relative group disabled:cursor-not-allowed',\n            props.disabled\n              ? 'bg-[#120d0a] text-dungeon-paper/35 border-dungeon-brown/70'\n              : props.active\n              ? (props.highlight\n                ? 'bg-dungeon-gold text-black border-dungeon-gold shadow-[0_0_20px_rgba(212,175,55,0.85)]'\n                : 'bg-dungeon-gold text-black border-dungeon-paper shadow-[0_0_15px_#d4af37]')\n              : (props.highlight\n                ? 'bg-[#1a0f08] text-dungeon-gold border-dungeon-gold/75 shadow-[0_0_11px_rgba(212,175,55,0.45)] hover:bg-dungeon-brown hover:text-dungeon-gold hover:border-dungeon-gold'\n                : 'bg-[#1a0f08] text-dungeon-gold-dim border-dungeon-brown hover:bg-dungeon-brown hover:text-dungeon-gold hover:border-dungeon-gold/50'),\n          ],\n          onClick: () => {\n            if (!props.disabled) {\n              emit('click');\n            }\n          },\n        },\n        [\n          h(props.icon as any, { class: 'size-6' }),\n          props.label\n            ? h(\n                'div',\n                {\n                  class: [\n                    'absolute bg-black/90 text-dungeon-paper text-xs px-2 py-1 rounded border border-dungeon-brown opacity-0 group-hover:opacity-100 transition-opacity whitespace-nowrap z-50 pointer-events-none',\n                    props.tooltipSide === 'left' ? 'right-14' : 'left-14',\n                  ],\n                },\n                props.label,\n              )\n            : null,\n        ],\n      );\n  },\n});\n\nconst WizardHatIcon = defineComponent({\n  setup() {\n    return () => h('i', { class: 'fa-solid fa-hat-wizard text-[20px]' });\n  },\n});\n\nconst gameStore = useGameStore();\nconst activeModal = ref<string | null>(null);\nconst inputText = ref('');\nconst isVariableUpdateOpen = ref(false);\nconst isStatusOpen = ref(true);\nconst showCombat = ref(false);\nconst combatEnemyName = ref('');\nconst showShopView = ref(false);\nconst showIdolView = ref(false);\nconst shopProducts = ref<ShopProduct[]>([]);\nconst shopBuying = ref(false);\nconst shopSpentGold = ref(0);\nconst shopPurchasedItems = ref<Array<{ name: string; rarity: string; price: number }>>([]);\nconst shopRobClickCount = ref(0);\nconst shopRobbing = ref(false);\nconst showChestView = ref(false);\nconst chestStage = ref<'closed' | 'opened' | 'mimic'>('closed');\nconst chestRolling = ref(false);\nconst chestRewardRelics = ref<RelicData[]>([]);\nconst chestRewardCollectedFlags = ref<boolean[]>([]);\nconst chestCollecting = ref(false);\nconst chestRewardVisible = ref(false);\nconst chestOpenedBgReady = ref(false);\nconst chestPortalChoices = ref<PortalChoice[]>([]);\nconst chestRewardCountFixed = ref<number | null>(null);\nconst chestCloseCount = ref(0);\nconst chestForceMimicNextOpen = ref(false);\nconst hotSpringCleanseMessage = ref<{ id: number; text: string } | null>(null);\nconst idolDiceValue = ref(1);\nconst idolDiceRolling = ref(false);\nconst idolAssignedTarget = ref<IdolBlessingTarget | null>(null);\nconst idolSnapPreviewTarget = ref<IdolBlessingTarget | null>(null);\nconst idolDicePosition = ref({ x: 0, y: 0 });\nconst idolDiceStageRef = ref<HTMLElement | null>(null);\nconst idolDiceRef = ref<HTMLElement | null>(null);\nconst idolSlotMaxHpRef = ref<HTMLElement | null>(null);\nconst idolSlotMpRef = ref<HTMLElement | null>(null);\nconst idolSlotGoldRef = ref<HTMLElement | null>(null);\nconst idolDragPointerId = ref<number | null>(null);\nconst idolDragStart = ref({ x: 0, y: 0 });\nconst idolDragStartPos = ref({ x: 0, y: 0 });\nconst combatTestStep = ref<'deck' | 'enemy'>('deck');\nconst selectedTestDeck = ref<string[]>([]);\nconst selectedTestEnemy = ref('');\nconst selectedTestRelicCounts = ref<Record<string, number>>({});\nconst selectedCardCategoryTab = ref('全部');\nconst selectedRelicCategoryTab = ref('全部');\nconst activeCombatContext = ref<'normal' | 'shopRobbery' | 'chestMimic' | 'combatTest'>('normal');\nconst pendingCombatNarrative = ref<{\n  id: string;\n  context: 'normal' | 'shopRobbery' | 'chestMimic' | 'combatTest';\n  win: boolean;\n  enemyName: string;\n  text: string;\n} | null>(null);\nconst dispatchedCombatNarrativeIds = new Set<string>();\nconst showVictoryRewardView = ref(false);\nconst victoryRewardStage = ref<'pick' | 'replace'>('pick');\nconst victoryRewardOptions = ref<CardData[]>([]);\nconst selectedVictoryRewardCard = ref<CardData | null>(null);\nconst rewardApplying = ref(false);\nconst rewardRefreshUsed = ref(false);\nconst rewardIsNormalEnemy = ref(false);\nconst relicTooltip = ref<{\n  x: number;\n  y: number;\n  name: string;\n  rarity: string;\n  category: string;\n  count: number;\n  effect: string;\n  description: string;\n} | null>(null);\nconst combatTestStartAt999 = ref(false);\nconst combatTestStartAt999CurrentBattle = ref(false);\nlet chestMimicTimer: ReturnType<typeof setTimeout> | null = null;\nlet chestRewardFadeTimer: ReturnType<typeof setTimeout> | null = null;\nlet chestCloseLongPressTimer: ReturnType<typeof setTimeout> | null = null;\nlet shopRobTimer: ReturnType<typeof setTimeout> | null = null;\nlet hotSpringCleanseTimer: ReturnType<typeof setTimeout> | null = null;\nlet idolRollTimer: ReturnType<typeof setTimeout> | null = null;\nlet relicTooltipLongPressTimer: ReturnType<typeof setTimeout> | null = null;\nlet relicTooltipAutoHideTimer: ReturnType<typeof setTimeout> | null = null;\nlet hotSpringCleanseMessageId = 0;\n\ninterface ShopProduct {\n  key: string;\n  relic: RelicData;\n  basePrice: number;\n  finalPrice: number;\n  sold: boolean;\n}\n\ntype CombatContext = 'normal' | 'shopRobbery' | 'chestMimic' | 'combatTest';\ntype IdolBlessingTarget = 'maxHp' | 'mp' | 'gold';\ninterface IdolBlessingConfig {\n  target: IdolBlessingTarget;\n  slotLabel: string;\n  statueName: string;\n  rewardText: (dice: number) => string;\n}\ninterface IdolSnapCandidate {\n  target: IdolBlessingTarget;\n  distance: number;\n  snapX: number;\n  snapY: number;\n}\n\ninterface PersistedShopProduct {\n  key: string;\n  relicId: string;\n  basePrice: number;\n  finalPrice: number;\n  sold: boolean;\n}\n\ninterface PersistedChestState {\n  stage: 'closed' | 'opened' | 'mimic';\n  rolling: boolean;\n  rewardRelicIds: string[];\n  rewardCollectedFlags: boolean[];\n  collecting: boolean;\n  rewardVisible: boolean;\n  openedBgReady: boolean;\n  portalChoices: PortalChoice[];\n  rewardCountFixed: number | null;\n  closeCount: number;\n  forceMimicNextOpen: boolean;\n}\n\ninterface PersistedShopState {\n  products: PersistedShopProduct[];\n  spentGold: number;\n  purchasedItems: Array<{ name: string; rarity: string; price: number }>;\n  robClickCount: number;\n  robbing: boolean;\n}\n\ninterface PersistedIdolState {\n  diceValue: number;\n  diceRolling: boolean;\n  assignedTarget: IdolBlessingTarget | null;\n  snapPreviewTarget: IdolBlessingTarget | null;\n  dicePosition: { x: number; y: number };\n}\n\ninterface PersistedVictoryState {\n  stage: 'pick' | 'replace';\n  optionCardIds: string[];\n  selectedCardId: string | null;\n  refreshUsed: boolean;\n  isNormalEnemy: boolean;\n}\n\ninterface PersistedOverlaySnapshot {\n  version: 1;\n  active: 'none' | 'shop' | 'chest' | 'idol' | 'victoryReward';\n  shop?: PersistedShopState;\n  chest?: PersistedChestState;\n  idol?: PersistedIdolState;\n  victory?: PersistedVictoryState;\n}\n\nconst OVERLAY_STATE_KEY = 'dungeon.ui.overlay_state.v1';\nconst isRestoringOverlayState = ref(false);\n\ntype HfTreeEntry = {\n  type?: string;\n  path?: string;\n};\n\nconst HF_DATASET_REPO = 'Vin05/AI-Gallery';\nconst HF_RESOLVE_ROOT = `https://huggingface.co/datasets/${HF_DATASET_REPO}/resolve/main`;\nconst HF_TREE_API_ROOT = `https://huggingface.co/api/datasets/${HF_DATASET_REPO}/tree/main`;\nconst HF_USER_DIR = '地牢/user';\nconst HF_MONSTER_DIR = '地牢/魔物';\nconst IMAGE_EXT_RE = /\\.(png|jpe?g|webp|gif|avif|bmp|svg)$/i;\nconst BOSS_FOLDER_NAMES = new Set([\n  '普莉姆', '宁芙', '温蒂尼', '玛塔', '罗丝', '厄休拉',\n  '希尔薇', '因克', '阿卡夏', '多萝西', '维罗妮卡',\n  '伊丽莎白', '尤斯蒂娅', '克拉肯', '布偶',\n  '赛琳娜', '米拉', '梦魔双子', '贝希摩斯',\n  '佩恩', '西格尔', '摩尔', '利维坦', '奥赛罗', '盖亚',\n]);\nconst bondFolderImageCache = new Map<string, string[]>();\nconst bondFolderImagePromiseCache = new Map<string, Promise<string[]>>();\nconst bondPortraitUrls = ref<Record<string, string>>({});\nconst bondPortraitErrors = ref<Record<string, boolean>>({});\nconst bondPortraitLoadTasks = new Map<string, Promise<void>>();\nconst bondPortraitPreview = ref<{ name: string; url: string } | null>(null);\nlet bondPortraitLoaderDisposed = false;\n\nconst normalizeRepoPath = (path: string) => path.replace(/\\\\/g, '/').replace(/^\\/+|\\/+$/g, '');\nconst encodeRepoPath = (path: string) => normalizeRepoPath(path).split('/').map((seg) => encodeURIComponent(seg)).join('/');\nconst toResolveUrl = (repoPath: string) => `${HF_RESOLVE_ROOT}/${encodeRepoPath(repoPath)}`;\nconst pickRandom = <T,>(items: T[]): T | null => (items.length > 0 ? items[Math.floor(Math.random() * items.length)]! : null);\nconst parseNextLink = (linkHeader: string | null): string | null => {\n  if (!linkHeader) return null;\n  const match = linkHeader.match(/<([^>]+)>\\s*;\\s*rel=\"next\"/i);\n  return match?.[1] ?? null;\n};\n\nconst fetchFolderImages = async (repoFolderPath: string): Promise<string[]> => {\n  const folder = normalizeRepoPath(repoFolderPath);\n  const cached = bondFolderImageCache.get(folder);\n  if (cached) return cached;\n  const pending = bondFolderImagePromiseCache.get(folder);\n  if (pending) return pending;\n\n  const task = (async () => {\n    const images: string[] = [];\n    let nextUrl: string | null = `${HF_TREE_API_ROOT}/${encodeRepoPath(folder)}?recursive=true&limit=1000`;\n\n    while (nextUrl) {\n      let response: Response;\n      try {\n        response = await fetch(nextUrl);\n      } catch {\n        break;\n      }\n      if (!response.ok) break;\n\n      let entries: HfTreeEntry[] = [];\n      try {\n        entries = await response.json() as HfTreeEntry[];\n      } catch {\n        break;\n      }\n\n      for (const entry of entries) {\n        if (entry.type !== 'file' || !entry.path) continue;\n        if (!IMAGE_EXT_RE.test(entry.path)) continue;\n        images.push(entry.path);\n      }\n\n      nextUrl = parseNextLink(response.headers.get('link'));\n    }\n\n    bondFolderImageCache.set(folder, images);\n    return images;\n  })();\n\n  bondFolderImagePromiseCache.set(folder, task);\n  try {\n    return await task;\n  } finally {\n    bondFolderImagePromiseCache.delete(folder);\n  }\n};\n\nconst resolveRandomPortrait = async (\n  folderPath: string,\n  fallbackFilePath: string,\n): Promise<string> => {\n  const images = await fetchFolderImages(folderPath);\n  const randomPath = pickRandom(images);\n  return randomPath ? toResolveUrl(randomPath) : toResolveUrl(fallbackFilePath);\n};\n\nconst resolveCharacterPortraitUrl = async (characterName: string): Promise<string> => {\n  const trimmedName = characterName.trim();\n  if (trimmedName === '苏菲' || trimmedName === '玩家') {\n    return resolveRandomPortrait(HF_USER_DIR, `${HF_USER_DIR}/立绘.png`);\n  }\n  const folderPath = `${HF_MONSTER_DIR}/${trimmedName}`;\n  const fallbackPath = `${HF_MONSTER_DIR}/${trimmedName}.png`;\n  if (BOSS_FOLDER_NAMES.has(trimmedName)) {\n    return resolveRandomPortrait(folderPath, fallbackPath);\n  }\n  const folderImages = await fetchFolderImages(folderPath);\n  const randomEnemy = pickRandom(folderImages);\n  return randomEnemy ? toResolveUrl(randomEnemy) : toResolveUrl(fallbackPath);\n};\n\nconst clampBondAffection = (value: unknown): number => {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return 0;\n  return Math.max(-1000, Math.min(1000, Math.floor(n)));\n};\n\nconst bondRoleEntries = computed<Array<{ name: string; affection: number }>>(() => {\n  const rolesRaw = gameStore.statData.角色;\n  if (!rolesRaw || typeof rolesRaw !== 'object') return [];\n  return Object.entries(rolesRaw as Record<string, any>)\n    .filter(([name]) => typeof name === 'string' && name.trim().length > 0)\n    .map(([name, payload]) => ({\n      name: name.trim(),\n      affection: clampBondAffection((payload as Record<string, unknown>)?.好感度),\n    }))\n    .sort((a, b) => {\n      if (a.affection !== b.affection) return b.affection - a.affection;\n      return a.name.localeCompare(b.name, 'zh-Hans-CN');\n    });\n});\n\nconst getBondPortraitUrl = (characterName: string) => (\n  bondPortraitUrls.value[characterName] ?? toResolveUrl(`${HF_MONSTER_DIR}/${characterName}.png`)\n);\n\nconst bondEntries = computed(() => (\n  bondRoleEntries.value.map((entry) => ({\n    ...entry,\n    portraitUrl: getBondPortraitUrl(entry.name),\n    affectionAbsRatio: Math.min(1, Math.abs(entry.affection) / 1000),\n  }))\n));\n\nconst ensureBondPortraitLoaded = async (characterName: string) => {\n  if (bondPortraitUrls.value[characterName]) return;\n  const pending = bondPortraitLoadTasks.get(characterName);\n  if (pending) {\n    await pending;\n    return;\n  }\n  const task = (async () => {\n    const url = await resolveCharacterPortraitUrl(characterName);\n    if (bondPortraitLoaderDisposed) return;\n    bondPortraitUrls.value = {\n      ...bondPortraitUrls.value,\n      [characterName]: url,\n    };\n    bondPortraitErrors.value = {\n      ...bondPortraitErrors.value,\n      [characterName]: false,\n    };\n  })();\n  bondPortraitLoadTasks.set(characterName, task);\n  try {\n    await task;\n  } finally {\n    bondPortraitLoadTasks.delete(characterName);\n  }\n};\n\nconst handleBondPortraitError = (characterName: string) => {\n  bondPortraitErrors.value = {\n    ...bondPortraitErrors.value,\n    [characterName]: true,\n  };\n};\n\nconst formatBondAffection = (affection: number) => (affection > 0 ? `+${affection}` : String(affection));\nconst openBondPortraitPreview = (entry: { name: string; portraitUrl: string }) => {\n  if (bondPortraitErrors.value[entry.name]) return;\n  bondPortraitPreview.value = {\n    name: entry.name,\n    url: entry.portraitUrl,\n  };\n};\nconst closeBondPortraitPreview = () => {\n  bondPortraitPreview.value = null;\n};\n\n// --- Dynamic Background ---\nconst bgIsLordFallback = ref(false);\nconst bgImageError = ref(false);\nconst HF_BG_BASE = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E8%83%8C%E6%99%AF';\nconst bgArea = computed(() => (gameStore.statData._当前区域 as string) || '');\nconst bgRoomType = computed(() => (gameStore.statData._当前房间类型 as string) || '');\nconst bgImageUrl = computed(() => {\n  if (!bgArea.value || bgImageError.value) return '';\n  const isLord = bgRoomType.value === '领主' && !bgIsLordFallback.value;\n  const suffix = isLord ? `${bgArea.value}_领主` : bgArea.value;\n  return `${HF_BG_BASE}/${encodeURIComponent(suffix)}.png`;\n});\nfunction onBgError() {\n  if (bgRoomType.value === '领主' && !bgIsLordFallback.value) {\n    bgIsLordFallback.value = true;\n  } else {\n    bgImageError.value = true;\n  }\n}\n\nconst BG_OPACITY_KEY = 'dungeon.bg_overlay_opacity';\nconst bgOverlayOpacity = ref(parseFloat(localStorage.getItem(BG_OPACITY_KEY) ?? '0.5'));\nwatch(bgOverlayOpacity, (v) => localStorage.setItem(BG_OPACITY_KEY, String(v)));\n\nconst CHEST_BG_CLOSED = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E8%83%8C%E6%99%AF/%E5%AE%9D%E7%AE%B11.png';\nconst CHEST_BG_OPENED = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E8%83%8C%E6%99%AF/%E5%AE%9D%E7%AE%B12.png';\nconst CHEST_BG_MIMIC = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E8%83%8C%E6%99%AF/%E5%AE%9D%E7%AE%B13.png';\nconst SHOP_BG_URL = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E8%83%8C%E6%99%AF/%E5%95%86%E5%BA%97.png';\nconst SHOP_MERCHANT_PORTRAIT_URL = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E9%AD%94%E7%89%A9/%E6%B2%90%E8%8A%AF%E5%85%B0/%E6%B2%90%E8%8A%AF%E5%85%B04.png';\nconst IDOL_BG_URL = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E8%83%8C%E6%99%AF/%E7%A5%9E%E5%83%8F.png';\nconst idolBackgroundUrl = IDOL_BG_URL;\nconst shopBackgroundUrl = SHOP_BG_URL;\nconst shopMerchantPortraitUrl = SHOP_MERCHANT_PORTRAIT_URL;\nconst chestBackgroundUrl = computed(() => {\n  if (chestStage.value === 'opened') return CHEST_BG_OPENED;\n  if (chestStage.value === 'mimic') return CHEST_BG_MIMIC;\n  return CHEST_BG_CLOSED;\n});\nconst IDOL_BLESSING_CONFIG: Record<IdolBlessingTarget, IdolBlessingConfig> = {\n  maxHp: {\n    target: 'maxHp',\n    slotLabel: '生命上限',\n    statueName: '生命神像',\n    rewardText: (dice) => `生命上限+${dice}`,\n  },\n  mp: {\n    target: 'mp',\n    slotLabel: '初始魔力',\n    statueName: '魔力神像',\n    rewardText: (dice) => `魔量+${dice}`,\n  },\n  gold: {\n    target: 'gold',\n    slotLabel: '金币',\n    statueName: '财富神像',\n    rewardText: (dice) => `金币+${dice * 2}`,\n  },\n};\nconst IDOL_SNAP_DISTANCE = 112;\n\nconst allCardsForTest = computed(() => getAllCards().filter(card => card.category !== '敌人'));\nconst cardByIdMap = computed(() => {\n  const map = new Map<string, CardData>();\n  for (const card of getAllCards()) {\n    map.set(card.id, card);\n  }\n  return map;\n});\nconst relicByIdMap = computed(() => {\n  const map = new Map<string, RelicData>();\n  for (const relic of getAllRelics()) {\n    map.set(relic.id, relic);\n  }\n  return map;\n});\nconst CATEGORY_ORDER: Record<string, number> = {\n  基础: 0,\n  魔导: 1,\n  燃烧: 2,\n  严寒: 3,\n  血池: 4,\n};\nconst compareCategory = (a: string, b: string) => {\n  const orderA = CATEGORY_ORDER[a] ?? 999;\n  const orderB = CATEGORY_ORDER[b] ?? 999;\n  if (orderA !== orderB) return orderA - orderB;\n  return a.localeCompare(b, 'zh-Hans-CN');\n};\nconst CARD_TYPE_ORDER_FOR_TEST: Record<CardType, number> = {\n  [CardType.PHYSICAL]: 0,\n  [CardType.MAGIC]: 1,\n  [CardType.FUNCTION]: 2,\n  [CardType.DODGE]: 3,\n  [CardType.CURSE]: 4,\n};\nconst cardCategoryGroupsForTest = computed<Array<{ category: string; cards: CardData[] }>>(() => {\n  const grouped = new Map<string, CardData[]>();\n  for (const card of allCardsForTest.value) {\n    if (!grouped.has(card.category)) {\n      grouped.set(card.category, []);\n    }\n    grouped.get(card.category)!.push(card);\n  }\n  return Array.from(grouped.entries())\n    .sort(([a], [b]) => compareCategory(a, b))\n    .map(([category, cards]) => ({\n      category,\n      cards: [...cards].sort((a, b) => {\n        const typeOrderA = CARD_TYPE_ORDER_FOR_TEST[a.type] ?? 999;\n        const typeOrderB = CARD_TYPE_ORDER_FOR_TEST[b.type] ?? 999;\n        if (typeOrderA !== typeOrderB) return typeOrderA - typeOrderB;\n        return a.name.localeCompare(b.name, 'zh-Hans-CN');\n      }),\n    }));\n});\nconst cardCategoryTabsForTest = computed<string[]>(() => [\n  '全部',\n  ...cardCategoryGroupsForTest.value.map((group) => group.category),\n]);\nconst filteredCardCategoryGroupsForTest = computed<Array<{ category: string; cards: CardData[] }>>(() => {\n  if (selectedCardCategoryTab.value === '全部') return cardCategoryGroupsForTest.value;\n  return cardCategoryGroupsForTest.value.filter((group) => group.category === selectedCardCategoryTab.value);\n});\nconst MAGIC_BOOK_COVER_BASE = 'https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E9%AD%94%E6%B3%95%E4%B9%A6%E5%B0%81%E9%9D%A2';\nconst getMagicBookCoverUrl = (bookName: string) => `${MAGIC_BOOK_COVER_BASE}/${encodeURIComponent(bookName)}.png`;\nconst carryableMagicBookNames = computed<string[]>(() => (\n  cardCategoryGroupsForTest.value\n    .map((group) => group.category)\n    .filter((category) => category !== '基础')\n));\nconst rawCarriedMagicBooks = computed<string[]>(() => {\n  const raw = gameStore.statData._携带的魔法书;\n  if (!Array.isArray(raw)) return [];\n  return raw.filter((name): name is string => typeof name === 'string' && name.trim().length > 0);\n});\nconst carriedMagicBooks = computed<string[]>(() => {\n  const available = new Set(carryableMagicBookNames.value);\n  return rawCarriedMagicBooks.value.filter((name) => available.has(name));\n});\nconst carriedMagicBookSet = computed(() => new Set(carriedMagicBooks.value));\nconst selectableRelicPool = computed<RelicData[]>(() => {\n  const categorySet = new Set<string>(['基础', ...carriedMagicBooks.value]);\n  let pool = getAllRelics().filter((relic) => categorySet.has(relic.category));\n  if (pool.length === 0) {\n    pool = getAllRelics().filter((relic) => relic.category === '基础');\n  }\n  return [...pool];\n});\nconst muxinlanFavor = computed<number>(() => {\n  const roles = (gameStore.statData.角色 ?? {}) as Record<string, any>;\n  const raw = Number(roles?.['沐芯兰']?.['好感度'] ?? 0);\n  const safe = Number.isFinite(raw) ? raw : 0;\n  return Math.max(-1000, Math.min(1000, safe));\n});\nconst shopDiscountRate = computed(() => Math.max(0, Math.min(1000, muxinlanFavor.value)) * 0.0002);\nconst shopRobBtnOpacity = computed(() => {\n  const revealed = Math.min(5, shopRobClickCount.value);\n  return (0.32 + revealed * 0.13).toFixed(2);\n});\nconst parseMerchantDefeatedValue = (value: unknown): boolean => {\n  if (value === true || value === 1) return true;\n  if (typeof value === 'string') {\n    const normalized = value.trim().toLowerCase();\n    return normalized === 'true' || normalized === '1';\n  }\n  return false;\n};\nconst isMerchantDefeated = computed(() => parseMerchantDefeatedValue(gameStore.statData._是否已击败商人));\nconst canEditMagicBooks = computed(() => (\n  ((gameStore.statData._当前区域 as string) || '') === '魔女的小窝'\n));\nconst magicBookSidebarIcon = computed(() => (canEditMagicBooks.value ? Book : Lock));\nconst magicHatSidebarIcon = computed(() => (canEditMagicBooks.value ? WizardHatIcon : Lock));\nconst isUpdatingMagicBooks = ref(false);\nconst isUpgradingMagicHat = ref(false);\ntype MagicHatUpgradeType = 'hp' | 'mp' | 'gold';\ntype MagicHatTrackView = {\n  id: MagicHatUpgradeType;\n  label: string;\n  currentValue: number;\n  currentLevel: number;\n  maxLevel: number;\n  nextValue: number;\n  nextCost: number;\n  isMax: boolean;\n  progressPercent: number;\n  barClass: string;\n};\nconst getSafeInt = (value: unknown, fallback: number) => {\n  const parsed = Number(value);\n  if (!Number.isFinite(parsed)) return fallback;\n  return Math.max(0, Math.floor(parsed));\n};\nconst readInitialMaxHpForUpgrade = () => {\n  return Math.max(1, getSafeInt(gameStore.statData.$初始血量上限, 10));\n};\nconst calcUpgradeLevel = (value: number, base: number, step: number, maxLevel: number) => {\n  const level = Math.floor((value - base) / step);\n  return Math.max(0, Math.min(maxLevel, level));\n};\nconst magicHatSkillPoints = computed(() => getSafeInt(gameStore.statData.$技能点, 0));\nconst magicHatTracks = computed<MagicHatTrackView[]>(() => {\n  const hpValue = readInitialMaxHpForUpgrade();\n  const mpValue = Math.max(1, getSafeInt(gameStore.statData.$初始魔量, 1));\n  const goldValue = getSafeInt(gameStore.statData.$初始金币, 0);\n\n  const hpLevel = calcUpgradeLevel(hpValue, 10, 2, 5);\n  const mpLevel = calcUpgradeLevel(mpValue, 1, 1, 3);\n  const goldLevel = calcUpgradeLevel(goldValue, 0, 2, 5);\n\n  const hpIsMax = hpLevel >= 5;\n  const mpIsMax = mpLevel >= 3;\n  const goldIsMax = goldLevel >= 5;\n\n  return [\n    {\n      id: 'hp',\n      label: '初始生命上限',\n      currentValue: hpValue,\n      currentLevel: hpLevel,\n      maxLevel: 5,\n      nextValue: hpIsMax ? hpValue : 10 + (hpLevel + 1) * 2,\n      nextCost: hpIsMax ? 0 : [1, 3, 6, 10, 15][hpLevel]!,\n      isMax: hpIsMax,\n      progressPercent: (hpLevel / 5) * 100,\n      barClass: 'bg-gradient-to-r from-rose-500/85 to-red-400/85',\n    },\n    {\n      id: 'mp',\n      label: '初始魔量',\n      currentValue: mpValue,\n      currentLevel: mpLevel,\n      maxLevel: 3,\n      nextValue: mpIsMax ? mpValue : 1 + (mpLevel + 1),\n      nextCost: mpIsMax ? 0 : [5, 10, 15][mpLevel]!,\n      isMax: mpIsMax,\n      progressPercent: (mpLevel / 3) * 100,\n      barClass: 'bg-gradient-to-r from-sky-500/85 to-blue-400/85',\n    },\n    {\n      id: 'gold',\n      label: '初始金币',\n      currentValue: goldValue,\n      currentLevel: goldLevel,\n      maxLevel: 5,\n      nextValue: goldIsMax ? goldValue : (goldLevel + 1) * 2,\n      nextCost: goldIsMax ? 0 : [2, 4, 6, 8, 10][goldLevel]!,\n      isMax: goldIsMax,\n      progressPercent: (goldLevel / 5) * 100,\n      barClass: 'bg-gradient-to-r from-amber-500/85 to-yellow-300/85',\n    },\n  ];\n});\nconst openMagicBookModal = () => {\n  if (!canEditMagicBooks.value) return;\n  activeModal.value = 'magicBooks';\n};\nconst openMagicHatModal = () => {\n  if (!canEditMagicBooks.value) return;\n  activeModal.value = 'magicHat';\n};\nconst toggleMagicBook = async (bookName: string) => {\n  if (isUpdatingMagicBooks.value) return;\n  const current = rawCarriedMagicBooks.value;\n  const nextBooks = current.includes(bookName)\n    ? current.filter((name) => name !== bookName)\n    : [...current, bookName];\n  isUpdatingMagicBooks.value = true;\n  await gameStore.updateStatDataFields({\n    _携带的魔法书: Array.from(new Set(nextBooks)),\n  });\n  isUpdatingMagicBooks.value = false;\n};\nconst upgradeMagicHatStat = async (id: MagicHatUpgradeType) => {\n  if (!canEditMagicBooks.value) return;\n  if (isUpgradingMagicHat.value) return;\n\n  const track = magicHatTracks.value.find((item) => item.id === id);\n  if (!track || track.isMax) return;\n\n  if (magicHatSkillPoints.value < track.nextCost) {\n    toastr.warning('技能点不足，无法升级。');\n    return;\n  }\n\n  const updates: Record<string, any> = {\n    $技能点: magicHatSkillPoints.value - track.nextCost,\n  };\n\n  if (id === 'hp') {\n    updates['$初始血量上限'] = track.nextValue;\n    updates._血量上限 = track.nextValue;\n    updates._血量 = track.nextValue;\n  } else if (id === 'mp') {\n    updates['$初始魔量'] = track.nextValue;\n    updates._魔量 = Math.max(getSafeInt(gameStore.statData._魔量, 0), track.nextValue);\n  } else {\n    updates['$初始金币'] = track.nextValue;\n    updates._金币 = Math.max(getSafeInt(gameStore.statData._金币, 0), track.nextValue);\n  }\n\n  isUpgradingMagicHat.value = true;\n  const ok = await gameStore.updateStatDataFields(updates);\n  isUpgradingMagicHat.value = false;\n  if (!ok) {\n    toastr.warning('升级失败，请稍后重试。');\n    return;\n  }\n\n  toastr.info(`${track.label} 已升级至 ${track.nextValue}。`);\n};\nconst cardByNameForTest = computed(() => {\n  const map = new Map<string, CardData>();\n  for (const card of allCardsForTest.value) {\n    map.set(card.name, card);\n  }\n  return map;\n});\nconst rewardCardPool = computed<CardData[]>(() => {\n  const categorySet = new Set<string>(['基础', ...carriedMagicBooks.value]);\n  const filtered = allCardsForTest.value.filter((card) => categorySet.has(card.category));\n  if (filtered.length > 0) return filtered;\n  return [...allCardsForTest.value];\n});\nconst rewardReplaceEntries = computed<Array<{ idx: number; name: string; card: CardData | null }>>(() => {\n  const raw = Array.isArray(gameStore.statData._技能) ? (gameStore.statData._技能 as string[]) : [];\n  return raw.slice(0, 9).map((name, idx) => ({\n    idx,\n    name,\n    card: cardByNameForTest.value.get(name) ?? null,\n  }));\n});\nconst selectedTestDeckCards = computed(() =>\n  selectedTestDeck.value\n    .map((cardName, idx) => ({ idx, card: cardByNameForTest.value.get(cardName) }))\n    .filter((entry): entry is { idx: number; card: CardData } => entry.card !== undefined),\n);\nconst allEnemyNamesForTest = computed(() => getAllEnemyNames());\nconst baseRelicsForTest = computed<readonly RelicData[]>(() => (\n  [...getAllRelics()].sort((a, b) => {\n    const categoryDiff = compareCategory(a.category, b.category);\n    if (categoryDiff !== 0) return categoryDiff;\n    return a.name.localeCompare(b.name, 'zh-Hans-CN');\n  })\n));\nconst relicCategoryGroupsForTest = computed<Array<{ category: string; relics: RelicData[] }>>(() => {\n  const grouped = new Map<string, RelicData[]>();\n  for (const relic of baseRelicsForTest.value) {\n    if (!grouped.has(relic.category)) {\n      grouped.set(relic.category, []);\n    }\n    grouped.get(relic.category)!.push(relic);\n  }\n  return Array.from(grouped.entries()).map(([category, relics]) => ({\n    category,\n    relics,\n  }));\n});\nconst relicCategoryTabsForTest = computed<string[]>(() => [\n  '全部',\n  ...relicCategoryGroupsForTest.value.map((group) => group.category),\n]);\nconst filteredRelicCategoryGroupsForTest = computed<Array<{ category: string; relics: RelicData[] }>>(() => {\n  if (selectedRelicCategoryTab.value === '全部') return relicCategoryGroupsForTest.value;\n  return relicCategoryGroupsForTest.value.filter((group) => group.category === selectedRelicCategoryTab.value);\n});\n\nwatch(cardCategoryTabsForTest, (tabs) => {\n  if (!tabs.includes(selectedCardCategoryTab.value)) {\n    selectedCardCategoryTab.value = '全部';\n  }\n}, { immediate: true });\nwatch(relicCategoryTabsForTest, (tabs) => {\n  if (!tabs.includes(selectedRelicCategoryTab.value)) {\n    selectedRelicCategoryTab.value = '全部';\n  }\n}, { immediate: true });\nwatch(bondRoleEntries, (entries) => {\n  const names = entries.map((entry) => entry.name);\n  const keepSet = new Set(names);\n\n  const nextUrls: Record<string, string> = {};\n  for (const [name, url] of Object.entries(bondPortraitUrls.value)) {\n    if (keepSet.has(name)) {\n      nextUrls[name] = url;\n    }\n  }\n  if (Object.keys(nextUrls).length !== Object.keys(bondPortraitUrls.value).length) {\n    bondPortraitUrls.value = nextUrls;\n  }\n\n  const nextErrors: Record<string, boolean> = {};\n  for (const [name, hasError] of Object.entries(bondPortraitErrors.value)) {\n    if (keepSet.has(name)) {\n      nextErrors[name] = hasError;\n    }\n  }\n  if (Object.keys(nextErrors).length !== Object.keys(bondPortraitErrors.value).length) {\n    bondPortraitErrors.value = nextErrors;\n  }\n\n  for (const name of names) {\n    if (!bondPortraitUrls.value[name]) {\n      void ensureBondPortraitLoaded(name);\n    }\n  }\n}, { immediate: true, deep: true });\n\nconst getCardTypeBadgeClass = (type: CardType) => {\n  switch (type) {\n    case CardType.PHYSICAL:\n      return 'border-red-500/50 text-red-300 bg-red-900/20';\n    case CardType.MAGIC:\n      return 'border-blue-500/50 text-blue-300 bg-blue-900/20';\n    case CardType.FUNCTION:\n      return 'border-yellow-500/50 text-yellow-300 bg-yellow-900/20';\n    case CardType.DODGE:\n      return 'border-emerald-500/50 text-emerald-300 bg-emerald-900/20';\n    case CardType.CURSE:\n      return 'border-violet-500/50 text-violet-300 bg-violet-900/20';\n    default:\n      return 'border-white/30 text-dungeon-paper/80 bg-white/5';\n  }\n};\n\nconst getCardCategoryStripClass = (category: string) => {\n  switch (category) {\n    case '基础':\n      return 'bg-dungeon-gold/80';\n    case '魔导':\n      return 'bg-violet-400/85';\n    case '燃烧':\n      return 'bg-orange-500/85';\n    case '严寒':\n      return 'bg-sky-400/85';\n    case '血池':\n      return 'bg-rose-500/85';\n    default:\n      return 'bg-indigo-400/80';\n  }\n};\n\n// ── Resolved deck from MVU _技能 via card registry ──\nconst resolvedDeck = computed<CardData[]>(() => {\n  const skills: string[] = gameStore.statData._技能 ?? [];\n  return resolveCardNames(skills.filter((s) => s !== ''));\n});\n\n// ── Resolved relics from MVU _圣遗物 ──\n// Format: { relicName: count } e.g. { \"圣杯\": 2, \"毒药\": 3 }\nconst relicEntries = computed(() => {\n  const raw: Record<string, number> = gameStore.statData._圣遗物 ?? {};\n  return Object.entries(raw)\n    .filter(([name, count]) => name && count > 0)\n    .map(([name, count]) => {\n      const relic = getRelicByName(name);\n      return {\n        name,\n        count,\n        rarity: relic?.rarity ?? '普通',\n        category: relic?.category ?? '基础',\n        effect: relic?.effect ?? '',\n        description: relic?.description ?? relic?.effect ?? '',\n      };\n    })\n    .sort((a, b) => a.name.localeCompare(b.name, 'zh-Hans-CN'));\n});\n\ntype RelicEntryView = (typeof relicEntries.value)[number];\nconst getOwnedRelicCountById = (id: string): number => {\n  const relic = getAllRelics().find((entry) => entry.id === id);\n  if (!relic) return 0;\n  const raw = gameStore.statData._圣遗物 ?? {};\n  const byName = Number((raw as Record<string, number>)[relic.name] ?? 0);\n  const byId = Number((raw as Record<string, number>)[id] ?? 0);\n  const safeByName = Number.isFinite(byName) ? byName : 0;\n  const safeById = Number.isFinite(byId) ? byId : 0;\n  return Math.max(0, Math.floor(Math.max(safeByName, safeById)));\n};\nconst BLOODPOOL_PASSIVE_MAX_HP_RELICS: Array<{ id: string; bonus: number }> = [\n  { id: 'bloodpool_strawberry', bonus: 5 },\n  { id: 'bloodpool_pear', bonus: 10 },\n  { id: 'bloodpool_mango', bonus: 15 },\n];\nconst bloodpoolPassiveMaxHpBonus = computed(() => (\n  BLOODPOOL_PASSIVE_MAX_HP_RELICS.reduce((sum, item) => {\n    return sum + (getOwnedRelicCountById(item.id) * item.bonus);\n  }, 0)\n));\nconst canRefreshVictoryReward = computed(() => (\n  showVictoryRewardView.value\n  && victoryRewardStage.value === 'pick'\n  && rewardIsNormalEnemy.value\n  && !rewardRefreshUsed.value\n  && getOwnedRelicCountById('base_silver_card') > 0\n));\nconst chestRewardEntries = computed<RelicEntryView[]>(() => (\n  chestRewardRelics.value.map((relic) => ({\n    name: relic.name,\n    count: 1,\n    rarity: relic.rarity,\n    category: relic.category,\n    effect: relic.effect,\n    description: relic.description ?? relic.effect ?? '',\n  }))\n));\n\nconst clearRelicTooltipTimers = () => {\n  if (relicTooltipLongPressTimer) {\n    clearTimeout(relicTooltipLongPressTimer);\n    relicTooltipLongPressTimer = null;\n  }\n  if (relicTooltipAutoHideTimer) {\n    clearTimeout(relicTooltipAutoHideTimer);\n    relicTooltipAutoHideTimer = null;\n  }\n};\n\nconst showRelicTooltipForTarget = (target: HTMLElement, relic: RelicEntryView) => {\n  const rect = target.getBoundingClientRect();\n  const tooltipWidth = 240;\n  const margin = 8;\n  const x = Math.max(margin, Math.min(rect.left + rect.width / 2, window.innerWidth - tooltipWidth - margin));\n  const y = Math.max(margin, rect.top - margin);\n  relicTooltip.value = {\n    x,\n    y,\n    name: relic.name,\n    rarity: relic.rarity,\n    category: relic.category,\n    count: relic.count,\n    effect: relic.effect,\n    description: relic.description,\n  };\n};\n\nconst showRelicTooltip = (event: MouseEvent | FocusEvent, relic: RelicEntryView) => {\n  const target = event.currentTarget as HTMLElement | null;\n  if (!target) return;\n  clearRelicTooltipTimers();\n  showRelicTooltipForTarget(target, relic);\n};\n\nconst hideRelicTooltip = () => {\n  clearRelicTooltipTimers();\n  relicTooltip.value = null;\n};\n\nconst handleRelicTouchStart = (event: TouchEvent, relic: RelicEntryView) => {\n  const target = event.currentTarget as HTMLElement | null;\n  if (!target) return;\n  clearRelicTooltipTimers();\n  relicTooltipLongPressTimer = setTimeout(() => {\n    showRelicTooltipForTarget(target, relic);\n    relicTooltipAutoHideTimer = setTimeout(() => {\n      relicTooltip.value = null;\n      relicTooltipAutoHideTimer = null;\n    }, 1800);\n  }, 320);\n};\n\nconst handleRelicTouchEnd = () => {\n  if (relicTooltipLongPressTimer) {\n    clearTimeout(relicTooltipLongPressTimer);\n    relicTooltipLongPressTimer = null;\n  }\n};\n\nconst showChestRewardTooltip = (event: MouseEvent | FocusEvent, index: number) => {\n  const entry = chestRewardEntries.value[index];\n  if (!entry) return;\n  showRelicTooltip(event, entry);\n};\n\nconst handleChestRewardTouchStart = (event: TouchEvent, index: number) => {\n  const entry = chestRewardEntries.value[index];\n  if (!entry) return;\n  handleRelicTouchStart(event, entry);\n};\n\nconst combatRelicMap = computed<Record<string, number>>(() => {\n  const raw: Record<string, number> = gameStore.statData._圣遗物 ?? {};\n  const normalized: Record<string, number> = {};\n  for (const [name, value] of Object.entries(raw)) {\n    const count = Math.max(0, Math.floor(Number(value ?? 0)));\n    if (!name || count <= 0) continue;\n    normalized[name] = count;\n  }\n  return normalized;\n});\n\nwatch(\n  resolvedDeck,\n  (cards) => {\n    if (!Array.isArray(cards) || cards.length === 0) return;\n    recordEncounteredCards(cards.map((card) => card.id));\n  },\n  { immediate: true },\n);\n\nwatch(\n  relicEntries,\n  (entries) => {\n    if (!Array.isArray(entries) || entries.length === 0) return;\n    const ids = entries\n      .map((entry) => getRelicByName(entry.name)?.id ?? '')\n      .filter((id): id is string => Boolean(id));\n    if (ids.length === 0) return;\n    recordEncounteredRelics(ids);\n  },\n  { immediate: true },\n);\n\nwatch(\n  () => chestRewardRelics.value,\n  (relics) => {\n    if (!Array.isArray(relics) || relics.length === 0) return;\n    recordEncounteredRelics(relics.map((relic) => relic.id));\n  },\n  { deep: false },\n);\n\nwatch(\n  () => shopProducts.value,\n  (products) => {\n    if (!Array.isArray(products) || products.length === 0) return;\n    recordEncounteredRelics(products.map((item) => item.relic.id));\n  },\n  { deep: false },\n);\n\nwatch(\n  () => victoryRewardOptions.value,\n  (cards) => {\n    if (!Array.isArray(cards) || cards.length === 0) return;\n    recordEncounteredCards(cards.map((card) => card.id));\n  },\n  { deep: false },\n);\n\nwatch(activeModal, (modal) => {\n  if (modal === 'magicBooks' || modal === 'magicHat') {\n    gameStore.loadStatData();\n  }\n  if (modal === 'map') {\n    nextTick(() => centerMapOnLatestNode(true));\n  }\n  if (modal !== 'bonds') {\n    closeBondPortraitPreview();\n  }\n  if (modal !== 'relics') {\n    hideRelicTooltip();\n  }\n});\nwatch(canEditMagicBooks, (editable) => {\n  if (!editable && (activeModal.value === 'magicBooks' || activeModal.value === 'magicHat')) {\n    activeModal.value = null;\n  }\n});\n\nconst selectedRelicTotalCount = computed(() => (\n  Object.values(selectedTestRelicCounts.value).reduce((sum, value) => sum + Math.max(0, Math.floor(value)), 0)\n));\n\n// ── Text display settings (reactive, persisted) ──\nconst textSettings = reactive({\n  fontSize: 21,\n  lineHeight: 2.0,\n  fontFamily: \"'Cinzel', serif\",\n  containerWidth: 1300,\n});\n\nconst isStreamingEnabled = computed<boolean>({\n  get: () => gameStore.useStreaming,\n  set: (value) => gameStore.setUseStreaming(value),\n});\n\nconst selectedBgmTrackId = computed<string>({\n  get: () => bgmTrackId.value,\n  set: (value) => setBgmTrack(value),\n});\n\nconst bgmVolumePercent = computed<number>({\n  get: () => Math.round(bgmVolume.value * 100),\n  set: (value) => setBgmVolume(value / 100),\n});\n\n// ── Computed display values from MVU stat_data ──\nconst displayText = computed(() =>\n  gameStore.mainText || '未能检测到正文标签，推测为空回/截断，请查看控制台输出',\n);\n\ntype MapRoomVisual = {\n  icon: string;\n  fill: string;\n  border: string;\n  text: string;\n};\ntype MapPathNodeView = {\n  key: string;\n  index: number;\n  x: number;\n  y: number;\n  centerX: number;\n  centerY: number;\n  icon: string;\n  style: Record<string, string>;\n};\ntype MapPathLineView = {\n  key: string;\n  x1: number;\n  y1: number;\n  x2: number;\n  y2: number;\n};\n\nconst MAP_PATH_COLUMNS = 6;\nconst MAP_CELL_SIZE = 62;\nconst MAP_CELL_GAP = 32;\nconst MAP_MIN_SCALE = 0.6;\nconst MAP_MAX_SCALE = 2.6;\nconst MAP_SCALE_STEP = 0.14;\nconst MAP_ROOM_VISUAL_BY_LABEL: Record<string, MapRoomVisual> = {\n  战斗: { icon: '⚔️', fill: 'rgba(153,27,27,0.78)', border: '#ef4444', text: '#fecaca' },\n  领主: { icon: '👑', fill: 'rgba(127,29,29,0.84)', border: '#f87171', text: '#ffe4e6' },\n  宝箱: { icon: '💎', fill: 'rgba(133,77,14,0.78)', border: '#f59e0b', text: '#fef3c7' },\n  商店: { icon: '🏪', fill: 'rgba(20,83,45,0.78)', border: '#34d399', text: '#dcfce7' },\n  温泉: { icon: '♨️', fill: 'rgba(12,74,110,0.78)', border: '#38bdf8', text: '#e0f2fe' },\n  神像: { icon: '🗿', fill: 'rgba(88,28,135,0.78)', border: '#c084fc', text: '#f3e8ff' },\n  事件: { icon: '❓', fill: 'rgba(63,63,70,0.78)', border: '#a1a1aa', text: '#f4f4f5' },\n  陷阱: { icon: '⚠️', fill: 'rgba(124,45,18,0.78)', border: '#fb923c', text: '#ffedd5' },\n};\n\nconst currentFloorPath = computed<string[]>(() => {\n  const rawPath = (\n    Array.isArray(gameStore.statData.$路径)\n      ? gameStore.statData.$路径\n      : ((gameStore.statData.$统计 as any)?.$路径 ?? null)\n  );\n  if (!Array.isArray(rawPath)) return [];\n  return rawPath\n    .filter((item): item is string => typeof item === 'string')\n    .map((item) => item.trim())\n    .filter((item) => item.length > 0);\n});\nconst currentLayerRoomCount = computed<number>(() => {\n  const rawCount = Number(((gameStore.statData.$统计 as any)?.当前层已过房间 ?? 0));\n  if (!Number.isFinite(rawCount)) return 0;\n  return Math.max(0, Math.floor(rawCount));\n});\nconst mapViewportRef = ref<HTMLElement | null>(null);\nconst mapScale = ref(1);\nconst mapOffsetX = ref(0);\nconst mapOffsetY = ref(0);\nconst mapDragPointerId = ref<number | null>(null);\nconst mapDragStartClient = ref({ x: 0, y: 0 });\nconst mapDragStartOffset = ref({ x: 0, y: 0 });\n\nconst mapPathNodes = computed<MapPathNodeView[]>(() => {\n  const step = MAP_CELL_SIZE + MAP_CELL_GAP;\n  return currentFloorPath.value.map((label, index) => {\n    const row = Math.floor(index / MAP_PATH_COLUMNS);\n    const positionInRow = index % MAP_PATH_COLUMNS;\n    const col = row % 2 === 0 ? positionInRow : (MAP_PATH_COLUMNS - 1 - positionInRow);\n    const x = col * step;\n    const y = row * step;\n    const visual = MAP_ROOM_VISUAL_BY_LABEL[label] ?? {\n      icon: '◻',\n      fill: 'rgba(39,39,42,0.78)',\n      border: '#a1a1aa',\n      text: '#f4f4f5',\n    };\n    return {\n      key: `node-${index}-${label}`,\n      index,\n      x,\n      y,\n      centerX: x + (MAP_CELL_SIZE / 2),\n      centerY: y + (MAP_CELL_SIZE / 2),\n      icon: visual.icon,\n      style: {\n        left: `${x}px`,\n        top: `${y}px`,\n        background: visual.fill,\n        borderColor: visual.border,\n        color: visual.text,\n      },\n    };\n  });\n});\nconst mapContentWidth = computed<number>(() => (\n  (MAP_PATH_COLUMNS - 1) * (MAP_CELL_SIZE + MAP_CELL_GAP) + MAP_CELL_SIZE\n));\nconst mapContentHeight = computed<number>(() => {\n  const total = mapPathNodes.value.length;\n  const rowCount = total > 0 ? Math.floor((total - 1) / MAP_PATH_COLUMNS) + 1 : 1;\n  return (rowCount - 1) * (MAP_CELL_SIZE + MAP_CELL_GAP) + MAP_CELL_SIZE;\n});\nconst mapPathLines = computed<MapPathLineView[]>(() => {\n  const nodes = mapPathNodes.value;\n  if (nodes.length <= 1) return [];\n  const lines: MapPathLineView[] = [];\n  for (let i = 1; i < nodes.length; i += 1) {\n    const prev = nodes[i - 1]!;\n    const curr = nodes[i]!;\n    lines.push({\n      key: `line-${i - 1}-${i}`,\n      x1: prev.centerX,\n      y1: prev.centerY,\n      x2: curr.centerX,\n      y2: curr.centerY,\n    });\n  }\n  return lines;\n});\nconst mapCanvasStyle = computed<Record<string, string>>(() => ({\n  width: `${mapContentWidth.value}px`,\n  height: `${mapContentHeight.value}px`,\n  transform: `translate(${mapOffsetX.value}px, ${mapOffsetY.value}px) scale(${mapScale.value})`,\n  transformOrigin: '0 0',\n}));\n\nconst clampMapScale = (value: number) => Math.max(MAP_MIN_SCALE, Math.min(MAP_MAX_SCALE, value));\nconst centerMapOnLatestNode = (resetScale: boolean = false) => {\n  const viewport = mapViewportRef.value;\n  if (!viewport) return;\n  if (resetScale) {\n    mapScale.value = 1;\n  }\n  const latest = mapPathNodes.value[mapPathNodes.value.length - 1];\n  const focusX = latest ? latest.centerX : (mapContentWidth.value / 2);\n  const focusY = latest ? latest.centerY : (mapContentHeight.value / 2);\n  mapOffsetX.value = (viewport.clientWidth / 2) - (focusX * mapScale.value);\n  mapOffsetY.value = (viewport.clientHeight / 2) - (focusY * mapScale.value);\n};\nconst zoomMap = (delta: number) => {\n  const viewport = mapViewportRef.value;\n  const nextScale = clampMapScale(mapScale.value + delta);\n  if (nextScale === mapScale.value) return;\n  if (!viewport) {\n    mapScale.value = nextScale;\n    return;\n  }\n  const centerX = viewport.clientWidth / 2;\n  const centerY = viewport.clientHeight / 2;\n  const worldX = (centerX - mapOffsetX.value) / mapScale.value;\n  const worldY = (centerY - mapOffsetY.value) / mapScale.value;\n  mapScale.value = nextScale;\n  mapOffsetX.value = centerX - (worldX * nextScale);\n  mapOffsetY.value = centerY - (worldY * nextScale);\n};\nconst handleMapZoomIn = () => zoomMap(MAP_SCALE_STEP);\nconst handleMapZoomOut = () => zoomMap(-MAP_SCALE_STEP);\nconst handleMapResetView = () => centerMapOnLatestNode(true);\nconst handleMapWheel = (event: WheelEvent) => {\n  zoomMap(event.deltaY < 0 ? MAP_SCALE_STEP : -MAP_SCALE_STEP);\n};\nconst handleMapPointerDown = (event: PointerEvent) => {\n  if (event.pointerType === 'mouse' && event.button !== 0) return;\n  const target = event.currentTarget as HTMLElement | null;\n  if (!target) return;\n  mapDragPointerId.value = event.pointerId;\n  mapDragStartClient.value = { x: event.clientX, y: event.clientY };\n  mapDragStartOffset.value = { x: mapOffsetX.value, y: mapOffsetY.value };\n  target.setPointerCapture(event.pointerId);\n};\nconst handleMapPointerMove = (event: PointerEvent) => {\n  if (mapDragPointerId.value !== event.pointerId) return;\n  const dx = event.clientX - mapDragStartClient.value.x;\n  const dy = event.clientY - mapDragStartClient.value.y;\n  mapOffsetX.value = mapDragStartOffset.value.x + dx;\n  mapOffsetY.value = mapDragStartOffset.value.y + dy;\n};\nconst handleMapPointerUp = (event: PointerEvent) => {\n  if (mapDragPointerId.value !== event.pointerId) return;\n  const target = event.currentTarget as HTMLElement | null;\n  if (target) {\n    target.releasePointerCapture(event.pointerId);\n  }\n  mapDragPointerId.value = null;\n};\nwatch(() => currentFloorPath.value.length, () => {\n  if (activeModal.value === 'map') {\n    nextTick(() => centerMapOnLatestNode(false));\n  }\n});\n\ntype StoryInlineSegmentType = 'text' | 'muted' | 'quote';\n\ninterface StoryInlineSegment {\n  key: string;\n  type: StoryInlineSegmentType;\n  text: string;\n}\n\ninterface StoryLineBlock {\n  type: 'line';\n  key: string;\n  level: 0 | 1 | 2 | 3 | 4;\n  segments: StoryInlineSegment[];\n}\n\ninterface StoryTucaoSection {\n  key: string;\n  lines: StoryLineBlock[];\n}\n\ninterface StoryContentState {\n  lines: StoryLineBlock[];\n  tucaoSections: StoryTucaoSection[];\n}\n\nconst inlineMarkRegex = /(\\*[^*\\r\\n]+\\*|“[^”\\r\\n]+”|「[^」\\r\\n]+」|\"[^\"\\r\\n]+\"|'[^'\\r\\n]+')/g;\nconst headerMarkRegex = /^(#{1,4})\\s*(.*)$/;\nconst tucaoOpenTagRegex = /<\\s*tucao(?:\\s+[^>]*)?>/gi;\nconst tucaoCloseTagRegex = /<\\s*\\/\\s*tucao\\s*>/gi;\nconst tucaoExpandedState = ref<Record<string, boolean>>({});\n\nfunction isQuotedText(text: string): boolean {\n  const value = text.trim();\n  if (value.length < 2) return false;\n  return (\n    /^“[^”\\r\\n]+”$/.test(value)\n    || /^「[^」\\r\\n]+」$/.test(value)\n    || /^\"[^\"\\r\\n]+\"$/.test(value)\n    || /^'[^'\\r\\n]+'$/.test(value)\n  );\n}\n\nfunction normalizeTucaoMarkers(text: string): string {\n  return text\n    // HTML entity forms: &lt;tucao&gt;...&lt;/tucao&gt;\n    .replace(/&lt;\\s*tucao(?:\\s+[^&]*?)?&gt;/gi, '<tucao>')\n    .replace(/&lt;\\s*\\/\\s*tucao\\s*&gt;/gi, '</tucao>')\n    // Alternate bracket forms: [tucao]...[/tucao]\n    .replace(/\\[\\s*tucao\\s*]/gi, '<tucao>')\n    .replace(/\\[\\s*\\/\\s*tucao\\s*]/gi, '</tucao>')\n    // Chinese tag alias: <吐槽>...</吐槽>\n    .replace(/<\\s*吐槽(?:\\s+[^>]*)?>/gi, '<tucao>')\n    .replace(/<\\s*\\/\\s*吐槽\\s*>/gi, '</tucao>');\n}\n\nfunction parseInlineSegments(line: string, keyPrefix: string): StoryInlineSegment[] {\n  if (!line) return [];\n  const segments: StoryInlineSegment[] = [];\n  let lastIndex = 0;\n  let segmentIndex = 0;\n  let match: RegExpExecArray | null;\n\n  inlineMarkRegex.lastIndex = 0;\n  while ((match = inlineMarkRegex.exec(line)) !== null) {\n    if (match.index > lastIndex) {\n      segments.push({\n        key: `${keyPrefix}-seg-${segmentIndex}`,\n        type: 'text',\n        text: line.slice(lastIndex, match.index),\n      });\n      segmentIndex += 1;\n    }\n\n    const markedText = match[0];\n    if (markedText.startsWith('*') && markedText.endsWith('*')) {\n      const innerText = markedText.slice(1, -1);\n      if (isQuotedText(innerText)) {\n        segments.push({\n          key: `${keyPrefix}-seg-${segmentIndex}`,\n          type: 'quote',\n          text: innerText,\n        });\n      } else {\n        segments.push({\n          key: `${keyPrefix}-seg-${segmentIndex}`,\n          type: 'muted',\n          text: innerText,\n        });\n      }\n    } else if (isQuotedText(markedText)) {\n      segments.push({\n        key: `${keyPrefix}-seg-${segmentIndex}`,\n        type: 'quote',\n        text: markedText,\n      });\n    } else {\n      segments.push({\n        key: `${keyPrefix}-seg-${segmentIndex}`,\n        type: 'quote',\n        text: markedText,\n      });\n    }\n    segmentIndex += 1;\n    lastIndex = inlineMarkRegex.lastIndex;\n  }\n\n  if (lastIndex < line.length) {\n    segments.push({\n      key: `${keyPrefix}-seg-${segmentIndex}`,\n      type: 'text',\n      text: line.slice(lastIndex),\n    });\n  }\n\n  return segments;\n}\n\nfunction parseStoryLine(line: string, key: string): StoryLineBlock {\n  const match = headerMarkRegex.exec(line);\n  let level: 0 | 1 | 2 | 3 | 4 = 0;\n  let content = line;\n\n  if (match) {\n    level = match[1].length as 1 | 2 | 3 | 4;\n    content = match[2];\n  }\n\n  return {\n    type: 'line',\n    key,\n    level,\n    segments: parseInlineSegments(content, key),\n  };\n}\n\nfunction parseTextLines(text: string, keyPrefix: string): StoryLineBlock[] {\n  if (text.length === 0) return [];\n  return text.split('\\n').map((line, index) => parseStoryLine(line, `${keyPrefix}-line-${index}`));\n}\n\nfunction parseStoryContent(text: string): StoryContentState {\n  const normalized = normalizeTucaoMarkers(text).replace(/\\r\\n/g, '\\n');\n  const lines: StoryLineBlock[] = [];\n  const tucaoSections: StoryTucaoSection[] = [];\n  let cursor = 0;\n  let sectionIndex = 0;\n  let openMatch: RegExpExecArray | null;\n\n  tucaoOpenTagRegex.lastIndex = 0;\n  while ((openMatch = tucaoOpenTagRegex.exec(normalized)) !== null) {\n    const openStart = openMatch.index;\n    const openEnd = tucaoOpenTagRegex.lastIndex;\n\n    const plainPart = normalized.slice(cursor, openStart);\n    lines.push(...parseTextLines(plainPart, `story-${sectionIndex}-plain-${cursor}`));\n\n    tucaoCloseTagRegex.lastIndex = openEnd;\n    const closeMatch = tucaoCloseTagRegex.exec(normalized);\n    const contentEnd = closeMatch ? closeMatch.index : normalized.length;\n    const nextCursor = closeMatch ? tucaoCloseTagRegex.lastIndex : normalized.length;\n\n    const tucaoContent = normalized.slice(openEnd, contentEnd).replace(/^\\n+/, '').replace(/\\n+$/, '');\n    const tucaoKey = `story-tucao-${sectionIndex}-${openStart}`;\n    const parsedTucaoLines = parseTextLines(tucaoContent, tucaoKey);\n    if (parsedTucaoLines.length > 0) {\n      tucaoSections.push({\n        key: tucaoKey,\n        lines: parsedTucaoLines,\n      });\n    }\n\n    cursor = nextCursor;\n    tucaoOpenTagRegex.lastIndex = cursor;\n    sectionIndex += 1;\n\n    // Missing closing tag: consume to end once.\n    if (!closeMatch) {\n      break;\n    }\n  }\n\n  const tail = normalized.slice(cursor);\n  lines.push(...parseTextLines(tail, `story-tail-${cursor}`));\n\n  return {\n    lines,\n    tucaoSections,\n  };\n}\n\nconst storyContentState = computed<StoryContentState>(() => parseStoryContent(displayText.value));\nconst storyMainLines = computed<StoryLineBlock[]>(() => storyContentState.value.lines);\nconst storyTucaoSections = computed<StoryTucaoSection[]>(() => storyContentState.value.tucaoSections);\n\nwatch(storyTucaoSections, (sections) => {\n  const validKeys = new Set(\n    sections.map(section => section.key),\n  );\n  const nextState: Record<string, boolean> = {};\n  for (const [key, value] of Object.entries(tucaoExpandedState.value)) {\n    if (validKeys.has(key)) {\n      nextState[key] = value;\n    }\n  }\n  tucaoExpandedState.value = nextState;\n}, { immediate: true });\n\nconst isTucaoExpanded = (key: string) => Boolean(tucaoExpandedState.value[key]);\nconst toggleTucao = (key: string) => {\n  tucaoExpandedState.value[key] = !isTucaoExpanded(key);\n};\n\n// HP: _血量 / _血量上限, HP 不能超过上限\nconst displayHp = computed(() => {\n  const hp = toNonNegativeInt(gameStore.statData._血量, 10);\n  const maxHp = displayMaxHp.value;\n  return Math.min(hp, maxHp);\n});\nconst displayMaxHp = computed(() => {\n  const baseMaxHp = toNonNegativeInt(gameStore.statData._血量上限, 10);\n  return Math.max(1, baseMaxHp + bloodpoolPassiveMaxHpBonus.value);\n});\n\n// MP: _魔量 only, no max variable. Visual cap at 20.\nconst displayMp = computed(() => gameStore.statData._魔量 ?? 1);\n\n// Gold\nconst displayGold = computed(() => gameStore.statData._金币 ?? 0);\n\n// Dice range\nconst displayMinDice = computed(() => gameStore.statData.$最小点数 ?? 0);\nconst displayMaxDice = computed(() => gameStore.statData.$最大点数 ?? 0);\nconst idolDiceMin = computed(() => Math.max(1, toNonNegativeInt(displayMinDice.value, 1)));\nconst idolDiceMax = computed(() => Math.max(idolDiceMin.value, toNonNegativeInt(displayMaxDice.value, 6)));\n\nconst hpPercent = computed(() => {\n  const max = displayMaxHp.value;\n  return max > 0 ? Math.min((displayHp.value / max) * 100, 100) : 100;\n});\n\n// MP visual fill: cap at 20 for display\nconst mpPercent = computed(() => {\n  const mp = displayMp.value;\n  const visualMax = 20;\n  return Math.min((mp / visualMax) * 100, 100);\n});\nconst idolRewardSummary = computed(() => {\n  const target = idolAssignedTarget.value;\n  if (!target) return null;\n  const config = IDOL_BLESSING_CONFIG[target];\n  const dice = idolDiceValue.value;\n  const amount = target === 'gold' ? dice * 2 : dice;\n  return {\n    target,\n    statueName: config.statueName,\n    amount,\n    rewardText: config.rewardText(dice),\n  };\n});\n\n// ── Actions ──\nconst handleSendInput = () => {\n  if (!inputText.value.trim() || gameStore.isGenerating) return;\n  gameStore.sendAction(inputText.value);\n  inputText.value = '';\n};\n\nconst handleOptionClick = (option: string) => {\n  if (gameStore.isGenerating) return;\n  // Strip the \"A. \" / \"B. \" / etc. prefix, paste content into input box\n  const stripped = option.replace(/^[A-D]\\.\\s*/i, '');\n  inputText.value = stripped;\n};\n\nconst REBIRTH_STARTER_DECK = [\n  '普通物理攻击', '普通物理攻击', '普通物理攻击',\n  '普通魔法攻击', '普通魔法攻击',\n  '普通护盾', '普通护盾',\n  '普通闪避', '普通闪避',\n];\nconst HOT_SPRING_CLEANSE_ACTION_TEXT = '<user>浸泡在暖泉中，污秽正悄然消融。（负面效果已全部消除）';\nconst HOT_SPRING_CLEANSE_LINES = [\n  '泉水洗去了你身上的污秽，灵魂重获纯净。',\n  '温热的泉水带走了不详的气息，你感到前所未有的轻松。',\n  '诅咒已随水波逝去，你的身心焕然一新。',\n  '尘垢尽落，灵台清明。',\n];\n\nconst toNonNegativeInt = (value: unknown, fallback: number) => {\n  const n = Number(value);\n  if (!Number.isFinite(n)) return fallback;\n  return Math.max(0, Math.floor(n));\n};\n\nconst buildRebirthResetFields = (): Record<string, any> => {\n  const initialMaxHp = Math.max(1, toNonNegativeInt(gameStore.statData.$初始血量上限, 10));\n  const initialMp = toNonNegativeInt(gameStore.statData.$初始魔量, 1);\n  const initialGold = toNonNegativeInt(gameStore.statData.$初始金币, 0);\n  const currentSkillPoints = toNonNegativeInt(gameStore.statData.$技能点, 0);\n  const currentFloor = Math.max(1, toNonNegativeInt(gameStore.statData._楼层数, 1));\n  const rebirthSkillPointGain = Math.floor((currentFloor * (currentFloor + 1)) / 2);\n  return {\n    _血量: initialMaxHp,\n    _血量上限: initialMaxHp,\n    _魔量: initialMp,\n    _金币: initialGold,\n    $技能点: currentSkillPoints + rebirthSkillPointGain,\n    _技能: [...REBIRTH_STARTER_DECK],\n    _负面状态: [],\n    $被动: '',\n    $主动: ['', ''],\n    _圣遗物: {},\n    $最大点数: 6,\n    $最小点数: 1,\n    _楼层数: 1,\n    _当前区域: '魔女的小窝',\n    _当前房间类型: '',\n    _当前事件: '',\n    _对手名称: '',\n    _是否已击败商人: false,\n    $统计: {\n      当前层已过房间: 0,\n      累计已过房间: 0,\n      累计经过战斗: 0,\n      累计经过温泉: 0,\n      累计经过宝箱: 0,\n      累计经过商店: 0,\n      累计经过神像: 0,\n      累计经过事件: 0,\n      累计经过陷阱: 0,\n    },\n    $路径: [],\n  };\n};\n\nconst handleRebirthClick = () => {\n  if (gameStore.isGenerating) return;\n  showCombat.value = false;\n  showVictoryRewardView.value = false;\n  closeShopView();\n  closeChestView();\n  closeIdolView();\n  pendingCombatNarrative.value = null;\n  gameStore.setPendingCombatMvuChanges(null);\n  gameStore.setPendingStatDataChanges(buildRebirthResetFields());\n  gameStore.sendAction('<user>在死亡边缘触发了回溯，回到了魔女的小窝。当前状态已重置为初始值，请基于回溯后的状态继续剧情。');\n};\n\n// ── Room type config for E option ──\ninterface RoomConfig {\n  label: string;\n  icon: string;\n  bgColor: string;\n  borderColor: string;\n  textColor: string;\n  glowColor: string;\n}\n\nconst ROOM_TYPE_CONFIG: Record<string, RoomConfig> = {\n  '战斗房': { label: '战斗', icon: '⚔', bgColor: 'rgba(185,28,28,0.25)', borderColor: '#dc2626', textColor: '#fca5a5', glowColor: '#dc262680' },\n  '领主房': { label: '战斗', icon: '⚔', bgColor: 'rgba(185,28,28,0.3)',  borderColor: '#ef4444', textColor: '#fca5a5', glowColor: '#ef444480' },\n  '宝箱房': { label: '打开宝箱', icon: '📦', bgColor: 'rgba(161,98,7,0.25)',  borderColor: '#eab308', textColor: '#fde68a', glowColor: '#eab30880' },\n  '商店房': { label: '打开商店', icon: '🛒', bgColor: 'rgba(21,128,61,0.25)', borderColor: '#22c55e', textColor: '#bbf7d0', glowColor: '#22c55e80' },\n  '温泉房': { label: '清除诅咒', icon: '💧', bgColor: 'rgba(8,145,178,0.25)',  borderColor: '#06b6d4', textColor: '#a5f3fc', glowColor: '#06b6d480' },\n  '神像房': { label: '膜拜', icon: '🙏', bgColor: 'rgba(126,34,206,0.25)', borderColor: '#a855f7', textColor: '#e9d5ff', glowColor: '#a855f780' },\n};\n\n// E option: no button for 事件房 / 陷阱房\nconst specialOptionConfig = computed<RoomConfig | null>(() => {\n  if (!gameStore.hasOptionE) return null;\n  if (isTreasureRoomContext.value) return ROOM_TYPE_CONFIG['宝箱房'];\n  if (isShopContext.value) return ROOM_TYPE_CONFIG['商店房'];\n  const roomType = gameStore.statData._当前房间类型 as string;\n  if (!roomType) return null;\n  if (roomType === '事件房' || roomType === '陷阱房') return null;\n  return ROOM_TYPE_CONFIG[roomType] ?? null;\n});\n\nconst isTreasureRoomContext = computed(() => {\n  const roomType = ((gameStore.statData._当前房间类型 as string) || '').trim();\n  const area = ((gameStore.statData._当前区域 as string) || '').trim();\n  return roomType === '宝箱房' || area === '宝箱' || area === '宝箱房';\n});\nconst isShopContext = computed(() => {\n  const roomType = ((gameStore.statData._当前房间类型 as string) || '').trim();\n  const area = ((gameStore.statData._当前区域 as string) || '').trim();\n  return roomType === '商店房' || area === '商店';\n});\nconst isHotSpringRoomContext = computed(() => {\n  const roomType = ((gameStore.statData._当前房间类型 as string) || '').trim();\n  return roomType === '温泉房';\n});\nconst isIdolRoomContext = computed(() => {\n  const roomType = ((gameStore.statData._当前房间类型 as string) || '').trim();\n  return roomType === '神像房';\n});\nconst isCombatRoomContext = computed(() => {\n  const roomType = ((gameStore.statData._当前房间类型 as string) || '').trim();\n  return roomType === '战斗房' || roomType === '领主房';\n});\n\nconst sanitizeCombatLogLine = (line: string) => {\n  return line\n    .replace(/<[^>]*>/g, '')\n    .replace(/&nbsp;/g, ' ')\n    .replace(/\\s+/g, ' ')\n    .trim();\n};\n\nconst formatCombatLogs = (logs: string[]) => {\n  const ordered = [...logs]\n    .reverse()\n    .map(sanitizeCombatLogLine)\n    .filter((line) => line.length > 0);\n  if (ordered.length === 0) return '（战斗日志为空）';\n  return ordered.join('\\n');\n};\n\nconst buildCombatNarrative = (win: boolean, enemyName: string, context: CombatContext, logs: string[]) => {\n  const outcomeLine = win\n    ? `<user>战斗结果：[胜利]，<user>战胜了${enemyName}。`\n    : `<user>战斗结果：[败北]，<user>被${enemyName}击败。`;\n  const contextLine = context === 'shopRobbery'\n    ? '<user>本次战斗发生在抢夺商店的冲突中。'\n    : context === 'chestMimic'\n    ? '<user>本次战斗发生在宝箱怪伏击中。'\n    : context === 'combatTest'\n    ? '<user>本次战斗来自战斗测试。'\n    : '<user>本次战斗发生在地牢探索途中。';\n  const followupLine = win\n    ? '<user>请根据以下完整战斗日志继续剧情，并体现胜利后的后续发展。'\n    : '<user>请根据以下完整战斗日志继续剧情，并体现战败后的后续发展。';\n  return `${outcomeLine}\\n${contextLine}\\n${followupLine}\\n<user>战斗日志（时间顺序）：\\n${formatCombatLogs(logs)}`;\n};\n\nconst VICTORY_REWARD_SKIP_ACTION_TEXT = '<user>未选择奖励直接离开。';\n\nconst sendCombatNarrativeOnce = (narrative: { id: string }, text: string) => {\n  if (dispatchedCombatNarrativeIds.has(narrative.id)) return;\n  if (gameStore.isGenerating) return;\n  dispatchedCombatNarrativeIds.add(narrative.id);\n  gameStore.sendAction(text);\n};\n\nconst queueCombatMvuSync = (win: boolean, finalStats: unknown, negativeEffects: string[]) => {\n  const hpRaw = Number((finalStats as { hp?: unknown } | null | undefined)?.hp);\n  const hasHp = Number.isFinite(hpRaw);\n  const finalMaxHpRaw = Number((finalStats as { maxHp?: unknown } | null | undefined)?.maxHp);\n  const hasFinalMaxHp = Number.isFinite(finalMaxHpRaw);\n  const floorRaw = Number(gameStore.statData._楼层数 ?? 1);\n  const floor = Number.isFinite(floorRaw) ? Math.max(1, Math.floor(floorRaw)) : 1;\n  const goldReward = 3 + (2 * floor);\n  const bloodPoolCount = getOwnedRelicCountById('bloodpool_blood_pool');\n  const stomachMarkCount = getOwnedRelicCountById('bloodpool_stomach_mark');\n  const baseMaxHp = toNonNegativeInt(gameStore.statData._血量上限, 10);\n  const stomachBonus = Math.max(0, 2 * stomachMarkCount);\n  const passiveMaxHpBonus = bloodpoolPassiveMaxHpBonus.value;\n  const normalizedNegativeEffects = negativeEffects\n    .filter((item): item is string => typeof item === 'string')\n    .map((item) => item.trim())\n    .filter((item) => item.length > 0);\n  let nextHp = hasHp ? Math.max(0, Math.floor(hpRaw)) : undefined;\n\n  if (nextHp !== undefined && bloodPoolCount > 0) {\n    const combatMaxHp = hasFinalMaxHp\n      ? Math.max(1, Math.floor(finalMaxHpRaw))\n      : Math.max(1, baseMaxHp + passiveMaxHpBonus);\n    if (nextHp <= Math.floor(combatMaxHp * 0.5)) {\n      const maxHpAfterBattle = Math.max(1, baseMaxHp + stomachBonus + passiveMaxHpBonus);\n      nextHp = Math.min(maxHpAfterBattle, nextHp + (12 * bloodPoolCount));\n    }\n  }\n\n  if (stomachBonus > 0) {\n    gameStore.mergePendingStatDataChanges({\n      _血量上限: Math.max(1, baseMaxHp + stomachBonus),\n    });\n  }\n\n  gameStore.setPendingCombatMvuChanges({\n    hp: nextHp,\n    addDefeatMark: !win,\n    goldDelta: win ? goldReward : undefined,\n    negativeStatusesAdd: normalizedNegativeEffects,\n  });\n};\n\nconst applyMerchantDefeatedShopState = () => {\n  for (const item of shopProducts.value) {\n    item.finalPrice = 0;\n  }\n};\n\nconst pickUniqueRewardCard = (\n  pool: CardData[],\n  usedIds: Set<string>,\n): CardData | null => {\n  const candidates = pool.filter((card) => !usedIds.has(card.id));\n  if (candidates.length === 0) return null;\n  return candidates[Math.floor(Math.random() * candidates.length)] ?? null;\n};\n\nconst buildVictoryRewardOptions = (): CardData[] => {\n  const pool = rewardCardPool.value;\n  const roomType = ((gameStore.statData._当前房间类型 as string) || '').trim();\n  const isLordRoom = roomType === '领主房';\n  const isNormalEnemy = roomType === '战斗房';\n  rewardIsNormalEnemy.value = isNormalEnemy;\n\n  const hasRainbowCard = isNormalEnemy && getOwnedRelicCountById('base_rainbow_card') > 0;\n  const hasGoldenCard = isNormalEnemy && getOwnedRelicCountById('base_golden_card') > 0;\n  const optionCount = 3 + (hasRainbowCard ? 1 : 0);\n  const rareChance = isLordRoom ? 1 : (hasGoldenCard ? 0.1 : 0.05);\n\n  const normalPool = pool.filter((card) => card.rarity === '普通');\n  const rarePool = pool.filter((card) => card.rarity === '稀有');\n  const options: CardData[] = [];\n  const usedIds = new Set<string>();\n\n  for (let i = 0; i < optionCount; i++) {\n    const pickRare = isLordRoom || Math.random() < rareChance;\n    const primaryPool = pickRare ? rarePool : normalPool;\n    let picked = pickUniqueRewardCard(primaryPool, usedIds);\n    if (!picked) {\n      picked = pickUniqueRewardCard(pool, usedIds);\n    }\n    if (!picked) continue;\n    options.push(picked);\n    usedIds.add(picked.id);\n  }\n\n  return options;\n};\n\nconst startVictoryRewardFlow = () => {\n  const options = buildVictoryRewardOptions();\n\n  if (options.length === 0) return false;\n  rewardRefreshUsed.value = false;\n  victoryRewardOptions.value = options;\n  selectedVictoryRewardCard.value = null;\n  victoryRewardStage.value = 'pick';\n  showVictoryRewardView.value = true;\n  return true;\n};\n\nconst refreshVictoryRewardOptions = () => {\n  if (!canRefreshVictoryReward.value || rewardApplying.value) return;\n  const options = buildVictoryRewardOptions();\n  if (options.length === 0) return;\n  rewardRefreshUsed.value = true;\n  victoryRewardOptions.value = options;\n  selectedVictoryRewardCard.value = null;\n  victoryRewardStage.value = 'pick';\n};\n\nconst finalizeVictoryRewardFlow = (options?: { skipReward?: boolean }) => {\n  const skipReward = Boolean(options?.skipReward);\n  showVictoryRewardView.value = false;\n  victoryRewardStage.value = 'pick';\n  victoryRewardOptions.value = [];\n  selectedVictoryRewardCard.value = null;\n  rewardApplying.value = false;\n  rewardRefreshUsed.value = false;\n  rewardIsNormalEnemy.value = false;\n  const narrative = pendingCombatNarrative.value;\n  pendingCombatNarrative.value = null;\n  if (skipReward) {\n    if (narrative) {\n      sendCombatNarrativeOnce(narrative, VICTORY_REWARD_SKIP_ACTION_TEXT);\n    } else if (!gameStore.isGenerating) {\n      gameStore.sendAction(VICTORY_REWARD_SKIP_ACTION_TEXT);\n    }\n    return;\n  }\n  if (!narrative) return;\n  if (narrative.context === 'shopRobbery') return;\n  sendCombatNarrativeOnce(narrative, narrative.text);\n};\n\nconst exitVictoryRewardFlow = () => {\n  finalizeVictoryRewardFlow({ skipReward: true });\n};\n\nconst pickVictoryRewardCard = (card: CardData) => {\n  selectedVictoryRewardCard.value = card;\n  victoryRewardStage.value = 'replace';\n};\n\nconst replaceDeckCardWithReward = (idx: number) => {\n  if (!selectedVictoryRewardCard.value || rewardApplying.value) return;\n  const raw = Array.isArray(gameStore.statData._技能)\n    ? [...(gameStore.statData._技能 as string[])].slice(0, 9)\n    : [];\n  if (raw.length === 0) {\n    raw.push(selectedVictoryRewardCard.value.name);\n  } else if (idx >= 0 && idx < raw.length) {\n    raw[idx] = selectedVictoryRewardCard.value.name;\n  } else {\n    return;\n  }\n  rewardApplying.value = true;\n  gameStore.mergePendingStatDataChanges({ _技能: raw });\n  finalizeVictoryRewardFlow();\n};\n\nconst getRarityBasePrice = (rarity: RelicData['rarity']) => {\n  if (rarity === '传奇') return 15;\n  if (rarity === '稀有') return 10;\n  return 5;\n};\n\nconst formatRarityLabel = (rarity: RelicData['rarity']) => (rarity === '传奇' ? '传说' : rarity);\n\nconst rollShopRarity = (): RelicData['rarity'] => {\n  const r = Math.random();\n  if (r < 0.8) return '普通';\n  if (r < 0.95) return '稀有';\n  return '传奇';\n};\n\nconst toRelicTooltipEntry = (relic: RelicData): RelicEntryView => ({\n  name: relic.name,\n  count: 1,\n  rarity: relic.rarity,\n  category: relic.category,\n  effect: relic.effect,\n  description: relic.description ?? relic.effect ?? '',\n});\n\nconst showShopProductTooltip = (event: MouseEvent | FocusEvent, item: ShopProduct) => {\n  showRelicTooltip(event, toRelicTooltipEntry(item.relic));\n};\n\nconst handleShopProductTouchStart = (event: TouchEvent, item: ShopProduct) => {\n  handleRelicTouchStart(event, toRelicTooltipEntry(item.relic));\n};\n\nconst generateShopProducts = () => {\n  const pool = [...selectableRelicPool.value];\n  const favorForCount = Math.max(0, muxinlanFavor.value);\n  const targetCount = Math.max(0, 3 + Math.floor(favorForCount / 200));\n  const count = Math.min(targetCount, pool.length);\n  const usedNames = new Set<string>();\n  const discountRate = shopDiscountRate.value;\n  const next: ShopProduct[] = [];\n\n  for (let i = 0; i < count; i++) {\n    const targetRarity = rollShopRarity();\n    let candidates = pool.filter((relic) => !usedNames.has(relic.name) && relic.rarity === targetRarity);\n    if (candidates.length === 0) {\n      candidates = pool.filter((relic) => !usedNames.has(relic.name));\n    }\n    if (candidates.length === 0) break;\n    const relic = pickOne(candidates);\n    if (!relic) break;\n    usedNames.add(relic.name);\n\n    const basePrice = getRarityBasePrice(relic.rarity);\n    const finalPrice = isMerchantDefeated.value ? 0 : Math.max(1, Math.ceil(basePrice * (1 - discountRate)));\n    next.push({\n      key: `${relic.id}-${i}`,\n      relic,\n      basePrice,\n      finalPrice,\n      sold: false,\n    });\n  }\n\n  shopProducts.value = next;\n};\n\nconst openShopView = () => {\n  hideRelicTooltip();\n  clearShopRobTimer();\n  shopBuying.value = false;\n  shopSpentGold.value = 0;\n  shopPurchasedItems.value = [];\n  shopRobClickCount.value = 0;\n  shopRobbing.value = false;\n  generateShopProducts();\n  if (isMerchantDefeated.value) {\n    applyMerchantDefeatedShopState();\n  }\n  showShopView.value = true;\n};\n\nconst closeShopView = () => {\n  hideRelicTooltip();\n  clearShopRobTimer();\n  shopBuying.value = false;\n  shopRobbing.value = false;\n  showShopView.value = false;\n};\n\nconst buildNextRelicInventory = (\n  pickedRelic: RelicData,\n  baseInventory?: Record<string, number>,\n): Record<string, number> => {\n  const rawRelics = baseInventory ?? (gameStore.statData._圣遗物 ?? {});\n  const nextRelics: Record<string, number> = {};\n  for (const [name, value] of Object.entries(rawRelics as Record<string, number>)) {\n    const count = Math.max(0, Math.floor(Number(value ?? 0)));\n    if (!name || count <= 0) continue;\n    nextRelics[name] = count;\n  }\n  nextRelics[pickedRelic.name] = (nextRelics[pickedRelic.name] ?? 0) + 1;\n  return nextRelics;\n};\n\nconst buyShopProduct = async (item: ShopProduct) => {\n  if (shopBuying.value || item.sold) return;\n  const currentGold = Math.max(0, Math.floor(Number(gameStore.statData._金币 ?? 0)));\n  if (currentGold < item.finalPrice) {\n    return;\n  }\n\n  shopBuying.value = true;\n  const nextGold = currentGold - item.finalPrice;\n  const nextRelics = buildNextRelicInventory(item.relic);\n  const ok = await gameStore.updateStatDataFields({\n    _金币: nextGold,\n    _圣遗物: nextRelics,\n  });\n  shopBuying.value = false;\n  if (!ok) return;\n\n  item.sold = true;\n  shopSpentGold.value += item.finalPrice;\n  shopPurchasedItems.value.push({\n    name: item.relic.name,\n    rarity: formatRarityLabel(item.relic.rarity),\n    price: item.finalPrice,\n  });\n  hideRelicTooltip();\n};\n\nconst exitShop = () => {\n  if (shopBuying.value || gameStore.isGenerating || shopRobbing.value) return;\n  const purchased = [...shopPurchasedItems.value];\n  const total = shopSpentGold.value;\n  const narrative = pendingCombatNarrative.value;\n  closeShopView();\n  if (narrative && narrative.context === 'shopRobbery' && narrative.win) {\n    const lootedText = purchased.length > 0\n      ? `<user>我在失守的货架上拿走了${purchased.map((item) => `${item.name}（${item.rarity}）`).join('，')}。`\n      : '<user>我没有额外拿走商店货架上的物品。';\n    const report = `${narrative.text}\\n${lootedText}\\n<user>我离开了商店，请基于战斗结果、战斗日志与离店行为继续后续剧情。`;\n    pendingCombatNarrative.value = null;\n    sendCombatNarrativeOnce(narrative, report);\n    return;\n  }\n\n  if (purchased.length === 0) return;\n  const purchasedText = purchased.map((item) => `${item.name}（${item.rarity}）`).join('，');\n  gameStore.sendAction(`<user>从沐芯兰处购买了${purchasedText}，总共花费${total}枚金币。`);\n};\n\nconst handleShopRobClick = async () => {\n  if (shopBuying.value || gameStore.isGenerating || shopRobbing.value || isMerchantDefeated.value) return;\n  if (shopRobClickCount.value < 5) {\n    shopRobClickCount.value += 1;\n    return;\n  }\n\n  shopRobbing.value = true;\n  const ok = await gameStore.updateStatDataFields({ _对手名称: '沐芯兰' });\n  if (!ok) {\n    shopRobbing.value = false;\n    return;\n  }\n\n  clearShopRobTimer();\n  shopRobTimer = setTimeout(() => {\n    closeShopView();\n    combatEnemyName.value = '沐芯兰';\n    activeCombatContext.value = 'shopRobbery';\n    showCombat.value = true;\n    shopRobTimer = null;\n  }, 1000);\n};\n\nconst clearShopRobTimer = () => {\n  if (!shopRobTimer) return;\n  clearTimeout(shopRobTimer);\n  shopRobTimer = null;\n};\n\nconst clearChestMimicTimer = () => {\n  if (!chestMimicTimer) return;\n  clearTimeout(chestMimicTimer);\n  chestMimicTimer = null;\n};\n\nconst clearChestRewardFadeTimer = () => {\n  if (!chestRewardFadeTimer) return;\n  clearTimeout(chestRewardFadeTimer);\n  chestRewardFadeTimer = null;\n};\n\nconst clearChestCloseLongPressTimer = () => {\n  if (!chestCloseLongPressTimer) return;\n  clearTimeout(chestCloseLongPressTimer);\n  chestCloseLongPressTimer = null;\n};\n\nconst clearHotSpringCleanseTimer = () => {\n  if (!hotSpringCleanseTimer) return;\n  clearTimeout(hotSpringCleanseTimer);\n  hotSpringCleanseTimer = null;\n};\n\nconst showHotSpringCleanseText = () => {\n  const text = pickOne(HOT_SPRING_CLEANSE_LINES) ?? HOT_SPRING_CLEANSE_LINES[0]!;\n  const messageId = ++hotSpringCleanseMessageId;\n  hotSpringCleanseMessage.value = { id: messageId, text };\n  clearHotSpringCleanseTimer();\n  hotSpringCleanseTimer = setTimeout(() => {\n    if (hotSpringCleanseMessage.value?.id === messageId) {\n      hotSpringCleanseMessage.value = null;\n    }\n    hotSpringCleanseTimer = null;\n  }, 2600);\n};\n\nconst useHotSpringCleanse = () => {\n  showHotSpringCleanseText();\n  gameStore.setPendingStatDataChanges({ _负面状态: [] });\n  gameStore.sendAction(HOT_SPRING_CLEANSE_ACTION_TEXT);\n};\n\nonUnmounted(() => {\n  clearShopRobTimer();\n  clearChestMimicTimer();\n  clearChestRewardFadeTimer();\n  clearChestCloseLongPressTimer();\n  clearHotSpringCleanseTimer();\n  clearIdolRollTimer();\n});\n\nconst handleChestBgLoaded = () => {\n  if (!showChestView.value) return;\n  if (chestStage.value !== 'opened') return;\n  if (chestBackgroundUrl.value !== CHEST_BG_OPENED) return;\n  chestOpenedBgReady.value = true;\n  const hasUncollectedReward = chestRewardRelics.value.some((_, idx) => !chestRewardCollectedFlags.value[idx]);\n  if (hasUncollectedReward) {\n    chestRewardVisible.value = true;\n  }\n};\n\nconst openChestView = () => {\n  clearChestMimicTimer();\n  clearChestRewardFadeTimer();\n  clearChestCloseLongPressTimer();\n  chestStage.value = 'closed';\n  chestRolling.value = false;\n  chestRewardRelics.value = [];\n  chestRewardCollectedFlags.value = [];\n  chestCollecting.value = false;\n  chestRewardVisible.value = false;\n  chestOpenedBgReady.value = false;\n  chestPortalChoices.value = [];\n  chestRewardCountFixed.value = null;\n  chestCloseCount.value = 0;\n  chestForceMimicNextOpen.value = false;\n  showChestView.value = true;\n};\n\nconst closeChestView = () => {\n  clearChestMimicTimer();\n  clearChestRewardFadeTimer();\n  clearChestCloseLongPressTimer();\n  hideRelicTooltip();\n  showChestView.value = false;\n  chestRolling.value = false;\n  chestRewardVisible.value = false;\n  chestOpenedBgReady.value = false;\n};\n\nconst clearIdolRollTimer = () => {\n  if (!idolRollTimer) return;\n  clearTimeout(idolRollTimer);\n  idolRollTimer = null;\n};\n\nconst clampNumber = (value: number, min: number, max: number) => {\n  if (max <= min) return min;\n  return Math.max(min, Math.min(max, value));\n};\n\nconst rollIdolDiceValue = () => {\n  const min = idolDiceMin.value;\n  const max = idolDiceMax.value;\n  if (max <= min) return min;\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\n\nconst getIdolSlotElement = (target: IdolBlessingTarget) => {\n  if (target === 'maxHp') return idolSlotMaxHpRef.value;\n  if (target === 'mp') return idolSlotMpRef.value;\n  return idolSlotGoldRef.value;\n};\n\nconst getIdolSnapCandidate = (x: number, y: number): IdolSnapCandidate | null => {\n  const stageEl = idolDiceStageRef.value;\n  const diceEl = idolDiceRef.value;\n  if (!stageEl || !diceEl) return null;\n\n  const stageRect = stageEl.getBoundingClientRect();\n  const diceRect = diceEl.getBoundingClientRect();\n  const maxX = Math.max(0, stageRect.width - diceRect.width);\n  const maxY = Math.max(0, stageRect.height - diceRect.height);\n  const diceCenterX = x + (diceRect.width / 2);\n  const diceCenterY = y + (diceRect.height / 2);\n\n  let best: IdolSnapCandidate | null = null;\n  const targets: IdolBlessingTarget[] = ['maxHp', 'mp', 'gold'];\n  for (const target of targets) {\n    const slotEl = getIdolSlotElement(target);\n    if (!slotEl) continue;\n    const slotRect = slotEl.getBoundingClientRect();\n    const slotCenterX = (slotRect.left - stageRect.left) + (slotRect.width / 2);\n    const slotCenterY = (slotRect.top - stageRect.top) + (slotRect.height / 2);\n    const distance = Math.hypot(slotCenterX - diceCenterX, slotCenterY - diceCenterY);\n    const snapX = clampNumber(slotCenterX - (diceRect.width / 2), 0, maxX);\n    const snapY = clampNumber(slotCenterY - (diceRect.height / 2), 0, maxY);\n    if (!best || distance < best.distance) {\n      best = { target, distance, snapX, snapY };\n    }\n  }\n\n  if (!best || best.distance > IDOL_SNAP_DISTANCE) return null;\n  return best;\n};\n\nconst placeIdolDiceAtStart = () => {\n  const stageEl = idolDiceStageRef.value;\n  const diceEl = idolDiceRef.value;\n  if (!stageEl || !diceEl) return;\n  const stageRect = stageEl.getBoundingClientRect();\n  const diceRect = diceEl.getBoundingClientRect();\n  const maxX = Math.max(0, stageRect.width - diceRect.width);\n  const maxY = Math.max(0, stageRect.height - diceRect.height);\n  const x = Math.max(0, (stageRect.width - diceRect.width) / 2);\n  const y = clampNumber(stageRect.height * 0.72, 0, maxY);\n  idolDicePosition.value = { x: clampNumber(x, 0, maxX), y };\n  idolSnapPreviewTarget.value = null;\n};\n\nconst openIdolView = () => {\n  if (gameStore.isGenerating) return;\n  clearIdolRollTimer();\n  idolAssignedTarget.value = null;\n  idolSnapPreviewTarget.value = null;\n  idolDragPointerId.value = null;\n  idolDiceValue.value = idolDiceMin.value;\n  idolDiceRolling.value = true;\n  showIdolView.value = true;\n  idolRollTimer = setTimeout(() => {\n    idolDiceValue.value = rollIdolDiceValue();\n    idolDiceRolling.value = false;\n    idolRollTimer = null;\n    requestAnimationFrame(() => {\n      placeIdolDiceAtStart();\n    });\n  }, 520);\n};\n\nconst closeIdolView = () => {\n  clearIdolRollTimer();\n  idolDragPointerId.value = null;\n  showIdolView.value = false;\n};\n\nconst handleIdolDicePointerDown = (event: PointerEvent) => {\n  if (!showIdolView.value || idolDiceRolling.value) return;\n  const diceEl = idolDiceRef.value;\n  if (!diceEl) return;\n  idolAssignedTarget.value = null;\n  idolDragPointerId.value = event.pointerId;\n  idolDragStart.value = { x: event.clientX, y: event.clientY };\n  idolDragStartPos.value = { ...idolDicePosition.value };\n  diceEl.setPointerCapture(event.pointerId);\n};\n\nconst handleIdolDicePointerMove = (event: PointerEvent) => {\n  if (!showIdolView.value) return;\n  if (idolDragPointerId.value !== event.pointerId) return;\n  const stageEl = idolDiceStageRef.value;\n  const diceEl = idolDiceRef.value;\n  if (!stageEl || !diceEl) return;\n\n  const stageRect = stageEl.getBoundingClientRect();\n  const diceRect = diceEl.getBoundingClientRect();\n  const maxX = Math.max(0, stageRect.width - diceRect.width);\n  const maxY = Math.max(0, stageRect.height - diceRect.height);\n  const dx = event.clientX - idolDragStart.value.x;\n  const dy = event.clientY - idolDragStart.value.y;\n  const nextX = clampNumber(idolDragStartPos.value.x + dx, 0, maxX);\n  const nextY = clampNumber(idolDragStartPos.value.y + dy, 0, maxY);\n  idolDicePosition.value = { x: nextX, y: nextY };\n  const candidate = getIdolSnapCandidate(nextX, nextY);\n  idolSnapPreviewTarget.value = candidate?.target ?? null;\n};\n\nconst handleIdolDicePointerUp = (event: PointerEvent) => {\n  if (!showIdolView.value) return;\n  if (idolDragPointerId.value !== event.pointerId) return;\n  const diceEl = idolDiceRef.value;\n  if (diceEl) {\n    diceEl.releasePointerCapture(event.pointerId);\n  }\n  const candidate = getIdolSnapCandidate(idolDicePosition.value.x, idolDicePosition.value.y);\n  if (candidate) {\n    idolAssignedTarget.value = candidate.target;\n    idolSnapPreviewTarget.value = candidate.target;\n    idolDicePosition.value = { x: candidate.snapX, y: candidate.snapY };\n  } else {\n    idolAssignedTarget.value = null;\n    idolSnapPreviewTarget.value = null;\n  }\n  idolDragPointerId.value = null;\n};\n\nconst buildIdolPendingFields = () => {\n  const reward = idolRewardSummary.value;\n  if (!reward) return null;\n\n  const currentMaxHp = toNonNegativeInt(gameStore.statData._血量上限, 10);\n  const currentMp = toNonNegativeInt(gameStore.statData._魔量, 1);\n  const currentGold = toNonNegativeInt(gameStore.statData._金币, 0);\n  if (reward.target === 'maxHp') {\n    return { _血量上限: currentMaxHp + reward.amount };\n  }\n  if (reward.target === 'mp') {\n    return { _魔量: currentMp + reward.amount };\n  }\n  return { _金币: currentGold + reward.amount };\n};\n\nconst exitIdolView = () => {\n  if (gameStore.isGenerating) return;\n  const reward = idolRewardSummary.value;\n  closeIdolView();\n  if (!reward) {\n    gameStore.sendAction('<user>没有膜拜任何一座神像，选择了直接离开。');\n    return;\n  }\n  const fields = buildIdolPendingFields();\n  if (fields) {\n    gameStore.setPendingStatDataChanges(fields);\n  }\n  gameStore.sendAction(`<user>选择膜拜了${reward.statueName}并获得了${reward.rewardText}。`);\n};\n\nconst rollChestRewardRarity = (): RelicData['rarity'] => {\n  const rarityRoll = Math.random();\n  if (rarityRoll < 0.8) return '普通';\n  if (rarityRoll < 0.95) return '稀有';\n  return '传奇';\n};\n\nconst rollChestRewardCount = (): number => (Math.random() < 0.8 ? 1 : 2);\n\nconst pickChestRewardRelics = (count: number): RelicData[] => {\n  const candidatePool = [...selectableRelicPool.value];\n  if (candidatePool.length === 0 || count <= 0) return [];\n\n  const picked: RelicData[] = [];\n  const usedIds = new Set<string>();\n\n  for (let i = 0; i < count; i += 1) {\n    const targetRarity = rollChestRewardRarity();\n    let candidates = candidatePool.filter((relic) => relic.rarity === targetRarity && !usedIds.has(relic.id));\n    if (candidates.length === 0) {\n      candidates = candidatePool.filter((relic) => !usedIds.has(relic.id));\n    }\n    if (candidates.length === 0) {\n      candidates = candidatePool.filter((relic) => relic.rarity === targetRarity);\n    }\n    if (candidates.length === 0) {\n      candidates = candidatePool;\n    }\n    const relic = pickOne(candidates);\n    if (!relic) break;\n    usedIds.add(relic.id);\n    picked.push(relic);\n  }\n\n  return picked;\n};\n\nconst queueChestMimicCombatTransition = () => {\n  clearChestMimicTimer();\n  chestMimicTimer = setTimeout(() => {\n    showChestView.value = false;\n    chestRolling.value = false;\n    chestRewardVisible.value = false;\n    combatEnemyName.value = '宝箱怪';\n    activeCombatContext.value = 'chestMimic';\n    showCombat.value = true;\n    chestMimicTimer = null;\n  }, 1000);\n};\n\nconst closeOpenedChestForRefresh = () => {\n  if (chestStage.value !== 'opened' || chestRolling.value || chestCollecting.value) return;\n  const hasCollectedAnyReward = chestRewardCollectedFlags.value.some((flag) => flag);\n  if (hasCollectedAnyReward) {\n    toastr.info('已领取过圣遗物，当前宝箱不能关闭刷新。');\n    return;\n  }\n  chestCloseCount.value += 1;\n  if (chestCloseCount.value >= 2) {\n    chestForceMimicNextOpen.value = true;\n  }\n  clearChestRewardFadeTimer();\n  hideRelicTooltip();\n  chestStage.value = 'closed';\n  chestRolling.value = false;\n  chestCollecting.value = false;\n  chestRewardVisible.value = false;\n  chestOpenedBgReady.value = false;\n  chestRewardRelics.value = [];\n  chestRewardCollectedFlags.value = [];\n  chestPortalChoices.value = [];\n};\n\nconst handleChestContextMenu = () => {\n  closeOpenedChestForRefresh();\n};\n\nconst handleChestTouchStart = () => {\n  if (chestStage.value !== 'opened') return;\n  clearChestCloseLongPressTimer();\n  chestCloseLongPressTimer = setTimeout(() => {\n    closeOpenedChestForRefresh();\n    chestCloseLongPressTimer = null;\n  }, 2000);\n};\n\nconst handleChestTouchEnd = () => {\n  clearChestCloseLongPressTimer();\n};\n\nconst collectChestReward = (index: number) => {\n  if (chestCollecting.value) return;\n  if (index < 0 || index >= chestRewardRelics.value.length) return;\n  if (chestRewardCollectedFlags.value[index]) return;\n  chestCollecting.value = true;\n  chestRewardCollectedFlags.value[index] = true;\n  chestCollecting.value = false;\n\n  const allCollected = chestRewardCollectedFlags.value.length > 0\n    && chestRewardCollectedFlags.value.every((flag) => flag);\n  if (!allCollected) return;\n\n  clearChestRewardFadeTimer();\n  chestRewardFadeTimer = setTimeout(() => {\n    chestRewardVisible.value = false;\n    hideRelicTooltip();\n    chestRewardFadeTimer = null;\n  }, 260);\n};\n\nconst handleChestCenterClick = async () => {\n  if (chestRolling.value || chestStage.value !== 'closed') return;\n  chestRolling.value = true;\n\n  const forcedMimic = chestForceMimicNextOpen.value;\n  const openSuccess = !forcedMimic && Math.random() < 0.9;\n\n  if (openSuccess) {\n    chestStage.value = 'opened';\n    chestOpenedBgReady.value = false;\n    chestRewardVisible.value = false;\n    const rewardCount = chestRewardCountFixed.value ?? rollChestRewardCount();\n    chestRewardCountFixed.value = rewardCount;\n    const rewards = pickChestRewardRelics(rewardCount);\n    if (rewards.length === 0) {\n      chestRolling.value = false;\n      return;\n    }\n    chestRewardRelics.value = rewards;\n    chestRewardCollectedFlags.value = rewards.map(() => false);\n    chestCollecting.value = false;\n    chestPortalChoices.value = generateChestLeavePortals();\n    if (chestOpenedBgReady.value) {\n      chestRewardVisible.value = true;\n    }\n    chestRolling.value = false;\n    return;\n  }\n\n  chestForceMimicNextOpen.value = false;\n  chestStage.value = 'mimic';\n  chestCollecting.value = false;\n  chestRewardVisible.value = false;\n  chestPortalChoices.value = [];\n  await gameStore.updateStatDataFields({ _对手名称: '宝箱怪' });\n  queueChestMimicCombatTransition();\n};\n\nconst startCombatFromSpecialOption = async () => {\n  const roomType = ((gameStore.statData._当前房间类型 as string) || '').trim();\n  const area = ((gameStore.statData._当前区域 as string) || '').trim();\n  const bloodPoolCount = getOwnedRelicCountById('bloodpool_blood_pool');\n  if (roomType === '领主房' && bloodPoolCount > 0) {\n    const fullHp = displayMaxHp.value;\n    const currentHp = toNonNegativeInt(gameStore.statData._血量, fullHp);\n    if (currentHp < fullHp) {\n      const ok = await gameStore.updateStatDataFields({ _血量: fullHp });\n      if (!ok) return;\n    }\n  }\n\n  let enemyName = ((gameStore.statData._对手名称 as string) || '').trim();\n  if (!enemyName) {\n    enemyName = roomType === '领主房'\n      ? (pickLordMonsterByArea(area) ?? '')\n      : (pickBattleMonsterByArea(area) ?? '');\n    if (!enemyName) {\n      toastr.warning('当前未找到可战斗的对手。');\n      return;\n    }\n    const ok = await gameStore.updateStatDataFields({ _对手名称: enemyName });\n    if (!ok) return;\n  }\n  combatEnemyName.value = enemyName;\n  activeCombatContext.value = 'normal';\n  showCombat.value = true;\n};\n\nconst handleSpecialOption = async () => {\n  if (isTreasureRoomContext.value) {\n    openChestView();\n    return;\n  }\n  if (isShopContext.value) {\n    openShopView();\n    return;\n  }\n  if (isHotSpringRoomContext.value) {\n    useHotSpringCleanse();\n    return;\n  }\n  if (isIdolRoomContext.value) {\n    openIdolView();\n    return;\n  }\n  if (isCombatRoomContext.value) {\n    await startCombatFromSpecialOption();\n    return;\n  }\n  toastr.info('功能开发中...');\n};\n\nconst buildOverlaySnapshot = (): PersistedOverlaySnapshot | null => {\n  if (showChestView.value) {\n    return {\n      version: 1,\n      active: 'chest',\n      chest: {\n        stage: chestStage.value,\n        rolling: chestRolling.value,\n        rewardRelicIds: chestRewardRelics.value.map((relic) => relic.id),\n        rewardCollectedFlags: chestRewardRelics.value.map((_, idx) => Boolean(chestRewardCollectedFlags.value[idx])),\n        collecting: chestCollecting.value,\n        rewardVisible: chestRewardVisible.value,\n        openedBgReady: chestOpenedBgReady.value,\n        portalChoices: chestPortalChoices.value.map((portal) => ({ ...portal })),\n        rewardCountFixed: chestRewardCountFixed.value,\n        closeCount: chestCloseCount.value,\n        forceMimicNextOpen: chestForceMimicNextOpen.value,\n      },\n    };\n  }\n  if (showShopView.value) {\n    return {\n      version: 1,\n      active: 'shop',\n      shop: {\n        products: shopProducts.value.map((item) => ({\n          key: item.key,\n          relicId: item.relic.id,\n          basePrice: item.basePrice,\n          finalPrice: item.finalPrice,\n          sold: item.sold,\n        })),\n        spentGold: shopSpentGold.value,\n        purchasedItems: shopPurchasedItems.value.map((item) => ({ ...item })),\n        robClickCount: shopRobClickCount.value,\n        robbing: shopRobbing.value,\n      },\n    };\n  }\n  if (showIdolView.value) {\n    return {\n      version: 1,\n      active: 'idol',\n      idol: {\n        diceValue: idolDiceValue.value,\n        diceRolling: idolDiceRolling.value,\n        assignedTarget: idolAssignedTarget.value,\n        snapPreviewTarget: idolSnapPreviewTarget.value,\n        dicePosition: { ...idolDicePosition.value },\n      },\n    };\n  }\n  if (showVictoryRewardView.value) {\n    return {\n      version: 1,\n      active: 'victoryReward',\n      victory: {\n        stage: victoryRewardStage.value,\n        optionCardIds: victoryRewardOptions.value.map((card) => card.id),\n        selectedCardId: selectedVictoryRewardCard.value?.id ?? null,\n        refreshUsed: rewardRefreshUsed.value,\n        isNormalEnemy: rewardIsNormalEnemy.value,\n      },\n    };\n  }\n  return null;\n};\n\nconst persistOverlaySnapshot = () => {\n  if (isRestoringOverlayState.value) return;\n  const snapshot = buildOverlaySnapshot();\n  if (!snapshot) {\n    localStorage.removeItem(OVERLAY_STATE_KEY);\n    return;\n  }\n  try {\n    localStorage.setItem(OVERLAY_STATE_KEY, JSON.stringify(snapshot));\n  } catch {\n    // ignore storage write failure\n  }\n};\n\nconst resolvePersistedPortalChoices = (choices: unknown): PortalChoice[] => {\n  if (!Array.isArray(choices)) return [];\n  const resolved: PortalChoice[] = [];\n  for (const entry of choices) {\n    if (!entry || typeof entry !== 'object') continue;\n    const portal = entry as Partial<PortalChoice>;\n    if (\n      typeof portal.label !== 'string'\n      || typeof portal.roomType !== 'string'\n      || typeof portal.icon !== 'string'\n      || typeof portal.bgColor !== 'string'\n      || typeof portal.borderColor !== 'string'\n      || typeof portal.textColor !== 'string'\n      || typeof portal.glowColor !== 'string'\n    ) {\n      continue;\n    }\n    resolved.push({\n      label: portal.label,\n      roomType: portal.roomType,\n      areaName: typeof portal.areaName === 'string' ? portal.areaName : undefined,\n      floorName: typeof portal.floorName === 'string' ? portal.floorName : undefined,\n      isFloorTransition: Boolean(portal.isFloorTransition),\n      icon: portal.icon,\n      bgColor: portal.bgColor,\n      borderColor: portal.borderColor,\n      textColor: portal.textColor,\n      glowColor: portal.glowColor,\n    });\n  }\n  return resolved;\n};\n\nconst restoreOverlaySnapshot = () => {\n  const raw = localStorage.getItem(OVERLAY_STATE_KEY);\n  if (!raw) return;\n\n  let parsed: PersistedOverlaySnapshot | null = null;\n  try {\n    parsed = JSON.parse(raw) as PersistedOverlaySnapshot;\n  } catch {\n    localStorage.removeItem(OVERLAY_STATE_KEY);\n    return;\n  }\n  if (!parsed || parsed.version !== 1) {\n    localStorage.removeItem(OVERLAY_STATE_KEY);\n    return;\n  }\n\n  isRestoringOverlayState.value = true;\n  try {\n    if (parsed.active === 'chest' && parsed.chest) {\n      const relics = parsed.chest.rewardRelicIds\n        .map((id) => relicByIdMap.value.get(id) ?? getRelicById(id))\n        .filter((relic): relic is RelicData => Boolean(relic));\n      showChestView.value = true;\n      chestStage.value = parsed.chest.stage;\n      chestRolling.value = Boolean(parsed.chest.rolling);\n      chestRewardRelics.value = relics;\n      chestRewardCollectedFlags.value = relics.map((_, idx) => Boolean(parsed.chest?.rewardCollectedFlags[idx]));\n      chestCollecting.value = false;\n      chestRewardVisible.value = Boolean(parsed.chest.rewardVisible);\n      chestOpenedBgReady.value = Boolean(parsed.chest.openedBgReady);\n      chestPortalChoices.value = resolvePersistedPortalChoices(parsed.chest.portalChoices);\n      chestRewardCountFixed.value = parsed.chest.rewardCountFixed === null\n        ? null\n        : Math.max(1, Math.min(2, toNonNegativeInt(parsed.chest.rewardCountFixed, 1)));\n      chestCloseCount.value = toNonNegativeInt(parsed.chest.closeCount, 0);\n      chestForceMimicNextOpen.value = Boolean(parsed.chest.forceMimicNextOpen);\n      if (chestStage.value === 'mimic') {\n        queueChestMimicCombatTransition();\n      }\n      return;\n    }\n\n    if (parsed.active === 'shop' && parsed.shop) {\n      const products: ShopProduct[] = [];\n      for (const [idx, product] of parsed.shop.products.entries()) {\n        const relic = relicByIdMap.value.get(product.relicId) ?? getRelicById(product.relicId);\n        if (!relic) continue;\n        products.push({\n          key: product.key || `${relic.id}-${idx}`,\n          relic,\n          basePrice: Math.max(0, toNonNegativeInt(product.basePrice, 0)),\n          finalPrice: Math.max(0, toNonNegativeInt(product.finalPrice, 0)),\n          sold: Boolean(product.sold),\n        });\n      }\n      showShopView.value = true;\n      shopProducts.value = products;\n      shopSpentGold.value = Math.max(0, toNonNegativeInt(parsed.shop.spentGold, 0));\n      shopPurchasedItems.value = Array.isArray(parsed.shop.purchasedItems)\n        ? parsed.shop.purchasedItems\n          .filter((item) => item && typeof item.name === 'string')\n          .map((item) => ({\n            name: item.name,\n            rarity: typeof item.rarity === 'string' ? item.rarity : '普通',\n            price: Math.max(0, toNonNegativeInt(item.price, 0)),\n          }))\n        : [];\n      shopRobClickCount.value = Math.max(0, toNonNegativeInt(parsed.shop.robClickCount, 0));\n      shopRobbing.value = Boolean(parsed.shop.robbing);\n      shopBuying.value = false;\n      return;\n    }\n\n    if (parsed.active === 'idol' && parsed.idol) {\n      showIdolView.value = true;\n      idolDiceValue.value = clampNumber(toNonNegativeInt(parsed.idol.diceValue, idolDiceMin.value), idolDiceMin.value, idolDiceMax.value);\n      idolDiceRolling.value = false;\n      idolAssignedTarget.value = parsed.idol.assignedTarget;\n      idolSnapPreviewTarget.value = parsed.idol.snapPreviewTarget;\n      idolDicePosition.value = {\n        x: Number.isFinite(parsed.idol.dicePosition?.x) ? parsed.idol.dicePosition.x : 0,\n        y: Number.isFinite(parsed.idol.dicePosition?.y) ? parsed.idol.dicePosition.y : 0,\n      };\n      idolDragPointerId.value = null;\n      return;\n    }\n\n    if (parsed.active === 'victoryReward' && parsed.victory) {\n      const options = parsed.victory.optionCardIds\n        .map((id) => cardByIdMap.value.get(id))\n        .filter((card): card is CardData => Boolean(card));\n      if (options.length === 0) {\n        localStorage.removeItem(OVERLAY_STATE_KEY);\n        return;\n      }\n      showVictoryRewardView.value = true;\n      victoryRewardStage.value = parsed.victory.stage === 'replace' ? 'replace' : 'pick';\n      victoryRewardOptions.value = options;\n      selectedVictoryRewardCard.value = parsed.victory.selectedCardId\n        ? (cardByIdMap.value.get(parsed.victory.selectedCardId) ?? null)\n        : null;\n      rewardApplying.value = false;\n      rewardRefreshUsed.value = Boolean(parsed.victory.refreshUsed);\n      rewardIsNormalEnemy.value = Boolean(parsed.victory.isNormalEnemy);\n      return;\n    }\n\n    localStorage.removeItem(OVERLAY_STATE_KEY);\n  } finally {\n    isRestoringOverlayState.value = false;\n  }\n};\n\nwatch(\n  [\n    showChestView,\n    showShopView,\n    showIdolView,\n    showVictoryRewardView,\n    chestStage,\n    chestRolling,\n    chestRewardRelics,\n    chestRewardCollectedFlags,\n    chestCollecting,\n    chestRewardVisible,\n    chestOpenedBgReady,\n    chestPortalChoices,\n    chestRewardCountFixed,\n    chestCloseCount,\n    chestForceMimicNextOpen,\n    shopProducts,\n    shopSpentGold,\n    shopPurchasedItems,\n    shopRobClickCount,\n    shopRobbing,\n    idolDiceValue,\n    idolDiceRolling,\n    idolAssignedTarget,\n    idolSnapPreviewTarget,\n    idolDicePosition,\n    victoryRewardStage,\n    victoryRewardOptions,\n    selectedVictoryRewardCard,\n    rewardRefreshUsed,\n    rewardIsNormalEnemy,\n  ],\n  () => {\n    persistOverlaySnapshot();\n  },\n  { deep: true },\n);\n\nonMounted(() => {\n  restoreOverlaySnapshot();\n});\n\n// ══════════════════════════════════════════════════════════════\n//  [Leave] Portal System — Floor/Area Logic\n// ══════════════════════════════════════════════════════════════\n\ninterface FloorMonsterConfig {\n  common: string[];\n  uniqueByArea: Record<string, string[]>;\n}\n\n// 基于 EJS魔物.txt 的楼层怪物池；结合区域条目标注的“特有魔物”建立区域限制\nconst FLOOR_MONSTER_CONFIG: Record<string, FloorMonsterConfig> = {\n  '第一层': {\n    common: ['游荡粘液球', '荧光蛾', '根须潜行者'],\n    uniqueByArea: {\n      '粘液之沼': ['沼泽潜伏者', '拟态气泡怪'],\n      '发情迷雾森林': ['迷雾精怪', '藤蔓行者'],\n      '喷精泉眼': ['泉水精魄', '潜伏触手怪'],\n      '触手菌窟': ['穴居触手'],\n      '肉欲食人花圃': ['极乐蜜蜂', '花粉喷射者'],\n    },\n  },\n  '第二层': {\n    common: ['浮游书页', '墨痕鼠', '低语幽灵'],\n    uniqueByArea: {\n      '禁忌图书馆': ['书魔', '墨水史莱姆'],\n      '呻吟阅览室': ['椅子拟态怪', '桌面触手'],\n      '催情墨染湖': ['墨团怪', '触手羽毛笔'],\n      '性癖记录馆': ['窥视之眼', '羞耻阴影'],\n      '淫乱教职工宿舍': ['堕落学者', '宿舍幽灵'],\n    },\n  },\n  '第三层': {\n    common: ['巡逻铁蝠', '荆棘匍匐者', '影牢使魔'],\n    uniqueByArea: {\n      '欲望监狱': ['刺链蛇', '惩戒傀儡', '羞耻蛭'],\n      '吸血鬼古堡': ['血蝙蝠', '血仆', '梦魇驹'],\n      '调教审判庭': ['审判蛛', '证词虫', '刽子手偶'],\n      '触手水牢': ['深渊水母', '寄生水蛭'],\n      '人偶工坊': ['缝合蜘蛛', '丝线傀儡', '测试者'],\n    },\n  },\n  '第四层': {\n    common: ['虚空游光', '面具侍从', '空间裂隙虫'],\n    uniqueByArea: {\n      '虚空宫殿': ['肉壁蠕虫'],\n      '镜之舞厅': ['镜像分身', '碎镜蝠'],\n      '双子寝宫': ['梦魇蛾', '枕头精'],\n      '春梦回廊': ['画框捕食者'],\n      '极乐宴会厅': ['侍宴者'],\n    },\n  },\n  '第五层': {\n    common: ['祈祷烛灵', '圣痕蝶', '忏悔天使'],\n    uniqueByArea: {\n      '交媾祭坛': ['祭司傀儡', '神恩触手'],\n      '圣水之海': ['圣水水母', '深渊鱼群', '圣水精灵'],\n      '苦修之路': ['晶体刺猬', '苦修幽灵'],\n      '神谕淫纹室': ['符文精灵', '光球守卫'],\n      '女神的产房': ['胎儿魔物', '脐带触手'],\n    },\n  },\n};\n\n// 领主顺序严格按 FLOOR_MONSTER_CONFIG 的区域顺序映射。\nconst LORD_MONSTER_ORDER: string[] = [\n  '普莉姆', '宁芙', '温蒂尼', '玛塔', '罗丝', '厄休拉',\n  '希尔薇', '因克', '阿卡夏', '多萝西', '维罗妮卡',\n  '伊丽莎白', '尤斯蒂娅', '克拉肯', '布偶',\n  '赛琳娜', '米拉', '梦魔双子', '贝希摩斯',\n  '佩恩', '西格尔', '摩尔', '利维坦', '奥赛罗', '盖亚',\n];\n\nconst LORD_MONSTER_BY_AREA: Record<string, string> = (() => {\n  const areaOrder: string[] = [];\n  for (const floorConfig of Object.values(FLOOR_MONSTER_CONFIG)) {\n    areaOrder.push(...Object.keys(floorConfig.uniqueByArea));\n  }\n\n  const mapping: Record<string, string> = {};\n  for (let i = 0; i < areaOrder.length; i += 1) {\n    const area = areaOrder[i]!;\n    const lordName = LORD_MONSTER_ORDER[i];\n    if (lordName) {\n      mapping[area] = lordName;\n    }\n  }\n  return mapping;\n})();\n\n// 当前规则：70% 抽普通魔物，30% 抽区域特有魔物（若存在）\nconst COMMON_MONSTER_RATE_BY_FLOOR: Record<string, number> = {\n  '第一层': 0.7,\n  '第二层': 0.7,\n  '第三层': 0.7,\n  '第四层': 0.7,\n  '第五层': 0.7,\n};\n\nfunction pickOne<T>(arr: T[]): T | null {\n  if (!arr.length) return null;\n  return arr[Math.floor(Math.random() * arr.length)]!;\n}\n\nfunction pickBattleMonsterByArea(area: string): string | null {\n  const floor = getFloorForArea(area) ?? '第一层';\n  const config = FLOOR_MONSTER_CONFIG[floor];\n  if (!config) return null;\n\n  const commonPool = config.common;\n  const uniquePool = config.uniqueByArea[area] ?? [];\n  const commonRate = COMMON_MONSTER_RATE_BY_FLOOR[floor] ?? 0.7;\n\n  let pool: string[] = [];\n  if (commonPool.length === 0 && uniquePool.length === 0) return null;\n  if (commonPool.length === 0) {\n    pool = uniquePool;\n  } else if (uniquePool.length === 0) {\n    pool = commonPool;\n  } else {\n    pool = Math.random() < commonRate ? commonPool : uniquePool;\n  }\n\n  return pickOne(pool);\n}\n\nfunction pickLordMonsterByArea(area: string): string | null {\n  const lordName = LORD_MONSTER_BY_AREA[area];\n  if (!lordName) return null;\n  return lordName;\n}\n\n// ── Portal visuals ──\nconst PORTAL_ROOM_TYPES = ['战斗房', '宝箱房', '商店房', '温泉房', '神像房', '事件房', '陷阱房'];\nconst PORTAL_ROOM_WEIGHTS: Record<string, number> = {\n  '战斗房': 50,\n  '宝箱房': 20,\n  '商店房': 5,\n  '温泉房': 10,\n  '神像房': 10,\n  '事件房': 0,\n  '陷阱房': 5,\n};\nconst TRAP_POOL_BY_AREA: Record<string, string[]> = {\n  '粘液之沼': ['粘液深坑', '史莱姆的温床'],\n  '发情迷雾森林': ['迷雾漩涡', '活体树洞', '树精的共生茧'],\n  '喷精泉眼': ['间歇性喷泉', '深水陷阱', '圣泉倒灌'],\n  '肉欲食人花圃': ['诱惑陷阱', '粘性花蜜池'],\n  '触手菌窟': ['孢子爆炸', '活体陷阱'],\n\n  '禁忌图书馆': ['幻境之书', '禁言束缚'],\n  // 呻吟阅览室：无陷阱（传送门中会移除陷阱房）\n  '催情墨染湖': ['强制纹身', '墨汁洗礼', '沉溺之爱'],\n  '性癖记录馆': ['公开处刑'],\n  '淫乱教职工宿舍': ['催眠广播', '强制派对'],\n\n  '欲望监狱': ['自动拘束床', '审讯室陷阱', '矫正项圈'],\n  '吸血鬼古堡': ['魅惑血雾', '血契房间'],\n  '调教审判庭': ['真言之椅', '雷霆忏悔席'],\n  '触手水牢': ['伪装平台', '嵌墙活体标本'],\n  '人偶工坊': ['丝线操控', '强制装配台'],\n\n  '虚空宫殿': ['重力反转', '维度分割展台'],\n  '镜之舞厅': ['镜像置换', '自我对峙', '无尽回廊'],\n  '双子寝宫': ['永恒春梦', '梦境具现', '双子的探访'],\n  '春梦回廊': ['记忆囚笼', '梦魇骑行'],\n  '极乐宴会厅': ['欲望之酒', '暴食者的终宴'],\n\n  '交媾祭坛': ['神圣跪拜', '献祭仪式'],\n  '圣水之海': ['圣水灌注', '溺亡的极乐', '依赖成瘾'],\n  '苦修之路': ['感官过载', '镜中诱惑', '跌倒的代价'],\n  '神谕淫纹室': ['强制烙印', '欲望显现', '连锁反应'],\n  '女神的产房': ['强制受孕', '母性陷阱', '子宫回归'],\n};\n\nconst ALL_TRAPS = Object.values(TRAP_POOL_BY_AREA).flat();\n\nconst pickTrapByArea = (area: string): string | null => {\n  const pool = TRAP_POOL_BY_AREA[area] ?? [];\n  if (pool.length > 0) return pickOne(pool);\n  if (ALL_TRAPS.length > 0) return pickOne(ALL_TRAPS);\n  return null;\n};\n\nconst getAvailablePortalRoomTypes = (currentArea: string) => {\n  if (parseMerchantDefeatedValue(gameStore.statData._是否已击败商人)) {\n    const withoutShop = PORTAL_ROOM_TYPES.filter((type) => type !== '商店房');\n    if (currentArea === '呻吟阅览室') {\n      return withoutShop.filter((type) => type !== '陷阱房');\n    }\n    return withoutShop;\n  }\n  if (currentArea === '呻吟阅览室') {\n    return PORTAL_ROOM_TYPES.filter((type) => type !== '陷阱房');\n  }\n  return [...PORTAL_ROOM_TYPES];\n};\n\ninterface PortalVisual { icon: string; bgColor: string; borderColor: string; textColor: string; glowColor: string; }\n\nconst PORTAL_ROOM_VISUALS: Record<string, PortalVisual> = {\n  '战斗房': { icon: '⚔️', bgColor: 'rgba(127,29,29,0.5)',  borderColor: '#991b1b', textColor: '#fca5a5', glowColor: '#dc2626' },\n  '宝箱房': { icon: '💎', bgColor: 'rgba(113,63,18,0.5)',  borderColor: '#a16207', textColor: '#fde68a', glowColor: '#eab308' },\n  '商店房': { icon: '🏪', bgColor: 'rgba(20,83,45,0.5)',   borderColor: '#166534', textColor: '#bbf7d0', glowColor: '#22c55e' },\n  '温泉房': { icon: '♨️', bgColor: 'rgba(22,78,99,0.5)',   borderColor: '#155e75', textColor: '#a5f3fc', glowColor: '#06b6d4' },\n  '神像房': { icon: '🗿', bgColor: 'rgba(88,28,135,0.5)',  borderColor: '#7e22ce', textColor: '#e9d5ff', glowColor: '#a855f7' },\n  '事件房': { icon: '❓', bgColor: 'rgba(63,63,70,0.5)',   borderColor: '#52525b', textColor: '#d4d4d8', glowColor: '#71717a' },\n  '陷阱房': { icon: '⚠️', bgColor: 'rgba(124,45,18,0.5)',  borderColor: '#9a3412', textColor: '#fed7aa', glowColor: '#ea580c' },\n  '领主房': { icon: '👑', bgColor: 'rgba(127,29,29,0.6)',  borderColor: '#dc2626', textColor: '#fca5a5', glowColor: '#ef4444' },\n};\nconst AREA_PORTAL_VISUAL: PortalVisual = {\n  icon: '🌀', bgColor: 'rgba(79,70,229,0.5)', borderColor: '#6366f1', textColor: '#c7d2fe', glowColor: '#818cf8',\n};\n\ninterface PortalChoice {\n  label: string;\n  roomType: string;\n  areaName?: string;\n  floorName?: string;\n  isFloorTransition: boolean;\n  icon: string;\n  bgColor: string;\n  borderColor: string;\n  textColor: string;\n  glowColor: string;\n}\n\nlet cachedPortals: PortalChoice[] = [];\nlet cachedPortalFingerprint = '';\n\nfunction shuffle<T>(arr: T[]): T[] {\n  const a = [...arr];\n  for (let i = a.length - 1; i > 0; i--) {\n    const j = Math.floor(Math.random() * (i + 1));\n    [a[i], a[j]] = [a[j], a[i]];\n  }\n  return a;\n}\n\nfunction rollPortalCount(): number {\n  const roll = Math.random();\n  // 传送门数量概率：1/2/3 = 30% / 50% / 20%\n  return roll < 0.3 ? 1 : roll < 0.8 ? 2 : 3;\n}\n\nfunction pickWeightedRoomTypes(roomTypes: string[], count: number): string[] {\n  const picked: string[] = [];\n  if (roomTypes.length === 0 || count <= 0) return picked;\n\n  // 允许可重复抽取：每次都从同一候选池按权重抽取，不移除已抽中的房间类型\n  const weightedPool = roomTypes.map((type) => ({\n    type,\n    weight: Math.max(0, PORTAL_ROOM_WEIGHTS[type] ?? 0),\n  }));\n  const totalWeight = weightedPool.reduce((sum, item) => sum + item.weight, 0);\n\n  while (picked.length < count) {\n    let selected: string;\n    if (totalWeight <= 0) {\n      selected = pickOne(roomTypes) ?? roomTypes[0]!;\n    } else {\n      let roll = Math.random() * totalWeight;\n      selected = weightedPool[weightedPool.length - 1]!.type;\n      for (const item of weightedPool) {\n        roll -= item.weight;\n        if (roll <= 0) {\n          selected = item.type;\n          break;\n        }\n      }\n    }\n\n    picked.push(selected);\n  }\n\n  return picked;\n}\n\nfunction generatePortals(): PortalChoice[] {\n  const currentArea = (gameStore.statData._当前区域 as string) || '';\n  const currentRoomType = (gameStore.statData._当前房间类型 as string) || '';\n  const stats = (gameStore.statData.$统计 as any) || {};\n  const roomsPassed: number = stats.当前层已过房间 ?? 0;\n\n  const isStartArea = currentArea === '魔女的小窝';\n  const isBossRoom = currentRoomType === '领主房';\n\n  // ── Special: 魔女的小窝 or 领主房 → next floor area portals ──\n  if (isStartArea || isBossRoom) {\n    let targetFloor: string | null = null;\n    if (isStartArea) {\n      targetFloor = '第一层';\n    } else {\n      const currentFloor = getFloorForArea(currentArea);\n      if (currentFloor) targetFloor = getNextFloor(currentFloor);\n    }\n    if (targetFloor && FLOOR_MAP[targetFloor]) {\n      const candidates = FLOOR_MAP[targetFloor].filter(a => a !== currentArea);\n      const picked = shuffle(candidates).slice(0, 3);\n      return picked.map(areaName => ({\n        label: areaName,\n        roomType: '',\n        areaName,\n        floorName: targetFloor!,\n        isFloorTransition: true,\n        ...AREA_PORTAL_VISUAL,\n      }));\n    }\n  }\n\n  // ── Boss room probability: rooms >= 7 → (rooms - 6) * 30% ──\n  if (roomsPassed >= 7) {\n    const bossChance = (roomsPassed - 6) * 0.3;\n    if (Math.random() < bossChance) {\n      const vis = PORTAL_ROOM_VISUALS['领主房'];\n      return [{ label: '领主房', roomType: '领主房', isFloorTransition: false, ...vis }];\n    }\n  }\n\n  // ── Normal: 1-3 weighted room portals (30%/50%/20%, with replacement) ──\n  const availableRoomTypes = getAvailablePortalRoomTypes(currentArea);\n  if (availableRoomTypes.length === 0) return [];\n  const count = rollPortalCount();\n  const picked = pickWeightedRoomTypes(availableRoomTypes, count);\n  return picked.map(rt => ({ label: rt, roomType: rt, isFloorTransition: false, ...PORTAL_ROOM_VISUALS[rt] }));\n}\n\n// 使用状态指纹实现响应式更新：当区域/房间类型/hasLeave 变化时重新生成传送门\nconst portalChoices = computed<PortalChoice[]>(() => {\n  if (!gameStore.hasLeave) {\n    cachedPortals = [];\n    cachedPortalFingerprint = '';\n    return [];\n  }\n  // 构建状态指纹：区域 + 房间类型 + 统计，任何变化都重新生成\n  const area = (gameStore.statData._当前区域 as string) || '';\n  const roomType = (gameStore.statData._当前房间类型 as string) || '';\n  const rooms = ((gameStore.statData.$统计 as any)?.当前层已过房间 ?? 0);\n  const merchantDefeated = parseMerchantDefeatedValue(gameStore.statData._是否已击败商人);\n  const fingerprint = `${area}|${roomType}|${rooms}|${merchantDefeated ? 1 : 0}`;\n  if (fingerprint !== cachedPortalFingerprint) {\n    cachedPortalFingerprint = fingerprint;\n    cachedPortals = generatePortals();\n  }\n  return cachedPortals;\n});\n\n// ── Room type → $统计 field mapping ──\nconst ROOM_STAT_KEY: Record<string, string> = {\n  '战斗房': '累计经过战斗', '宝箱房': '累计经过宝箱', '商店房': '累计经过商店',\n  '温泉房': '累计经过温泉', '神像房': '累计经过神像', '事件房': '累计经过事件', '陷阱房': '累计经过陷阱',\n};\nconst getPathLabelByRoomType = (roomType: string): string => (\n  roomType.endsWith('房') ? roomType.slice(0, -1) : roomType\n);\n\ninterface QueuedPortalAction {\n  actionText: string;\n  enterText: string;\n  pendingStatDataFields?: Record<string, any>;\n}\n\nconst buildQueuedPortalAction = (portal: PortalChoice): QueuedPortalAction => {\n  if (portal.isFloorTransition) {\n    // 记录待应用变量：进入新区域，首个房间为宝箱房，重置房间计数\n    gameStore.setPendingPortalChanges({\n      area: portal.areaName!,\n      roomType: '宝箱房',\n      resetRoomCounter: true,\n      resetPath: true,\n      // 新区域首个房间同样计入统计：宝箱房 +1、累计总房间 +1、当层房间 +1\n      incrementKeys: ['当前层已过房间', '累计已过房间', '累计经过宝箱'],\n      appendPathLabel: '宝箱',\n      enemyName: '',\n    });\n    console.info(`[Portal] Floor transition queued → area: ${portal.areaName}, first room: 宝箱房`);\n    const enterText = `进入了${portal.areaName}的宝箱房`;\n    return {\n      enterText,\n      actionText: `<user>选择了继续前进，${enterText}`,\n    };\n  }\n\n  // 记录待应用变量：进入新房间，更新统计\n  const incrementKeys = ['当前层已过房间', '累计已过房间'];\n  const statKey = ROOM_STAT_KEY[portal.roomType];\n  if (statKey) incrementKeys.push(statKey);\n  const currentArea = (gameStore.statData._当前区域 as string) || '';\n  const encounterMonster = portal.roomType === '领主房'\n    ? pickLordMonsterByArea(currentArea)\n    : portal.roomType === '战斗房'\n      ? pickBattleMonsterByArea(currentArea)\n      : null;\n  const trapName = portal.roomType === '陷阱房'\n    ? pickTrapByArea(currentArea)\n    : null;\n  const trapHpAfterDamage = portal.roomType === '陷阱房'\n    ? Math.max(1, toNonNegativeInt(gameStore.statData._血量, 1) - 5)\n    : undefined;\n  let pendingStatDataFields: Record<string, any> | undefined;\n  if (portal.roomType === '陷阱房') {\n    pendingStatDataFields = {\n      _当前事件: trapName ?? '',\n      _血量: trapHpAfterDamage,\n    };\n  } else if (portal.roomType === '温泉房') {\n    const maxHp = Math.max(1, displayMaxHp.value);\n    pendingStatDataFields = {\n      _血量: maxHp,\n    };\n  }\n\n  gameStore.setPendingPortalChanges({\n    roomType: portal.roomType,\n    incrementKeys,\n    appendPathLabel: getPathLabelByRoomType(portal.roomType),\n    enemyName: encounterMonster ?? '',\n  });\n  console.info(`[Portal] Room transition queued → type: ${portal.roomType}`);\n\n  const enterText = (portal.roomType === '战斗房' || portal.roomType === '领主房') && encounterMonster\n    ? `进入了${portal.roomType}并遭遇了${encounterMonster}`\n    : portal.roomType === '陷阱房' && trapName\n      ? `进入了${portal.roomType}的房间，当前陷阱房为${trapName}`\n      : `进入了${portal.roomType}的房间`;\n\n  return {\n    enterText,\n    actionText: `<user>选择了继续前进，${enterText}`,\n    pendingStatDataFields,\n  };\n};\n\nfunction generateChestLeavePortals(): PortalChoice[] {\n  const generated = generatePortals();\n  if (generated.length > 0) return generated;\n\n  const currentArea = (gameStore.statData._当前区域 as string) || '';\n  const availableRoomTypes = getAvailablePortalRoomTypes(currentArea);\n  if (availableRoomTypes.length === 0) return [];\n  const count = rollPortalCount();\n  const picked = pickWeightedRoomTypes(availableRoomTypes, count);\n  return picked.map(rt => ({ label: rt, roomType: rt, isFloorTransition: false, ...PORTAL_ROOM_VISUALS[rt] }));\n}\n\nconst handlePortalClick = async (portal: PortalChoice) => {\n  if (gameStore.isGenerating) return;\n  const { actionText, pendingStatDataFields } = buildQueuedPortalAction(portal);\n  gameStore.setPendingStatDataChanges(pendingStatDataFields ?? null);\n  gameStore.sendAction(actionText);\n};\n\nconst handleChestPortalClick = async (portal: PortalChoice) => {\n  if (gameStore.isGenerating || chestCollecting.value || chestStage.value !== 'opened') return;\n  const { actionText, enterText, pendingStatDataFields } = buildQueuedPortalAction(portal);\n  const collectedRelics = chestRewardRelics.value.filter((_, idx) => chestRewardCollectedFlags.value[idx]);\n  const mergedPendingStatDataFields: Record<string, any> = {\n    ...(pendingStatDataFields ?? {}),\n  };\n  if (collectedRelics.length > 0) {\n    // 宝箱奖励遵循与传送门一致的“延迟写入”策略：仅在点击传送门时排队到下一层 user 楼层\n    let nextRelics: Record<string, number> = gameStore.statData._圣遗物 ?? {};\n    for (const relic of collectedRelics) {\n      nextRelics = buildNextRelicInventory(relic, nextRelics);\n    }\n    mergedPendingStatDataFields._圣遗物 = nextRelics;\n  }\n  gameStore.setPendingStatDataChanges(Object.keys(mergedPendingStatDataFields).length > 0 ? mergedPendingStatDataFields : null);\n\n  const relicNameText = collectedRelics.map((relic) => relic.name).join('、');\n  closeChestView();\n  if (relicNameText) {\n    gameStore.sendAction(`<user>打开了箱子并从中获取了圣遗物${relicNameText}，随后离开了当前房间并进入了下一个房间，<user>${enterText}`);\n    return;\n  }\n  gameStore.sendAction(actionText);\n};\n\n\nconst openSaveLoad = () => {\n  gameStore.loadSaveEntries();\n  gameStore.isSaveLoadOpen = !gameStore.isSaveLoadOpen;\n};\n\nconst openVariableUpdate = () => {\n  isVariableUpdateOpen.value = !isVariableUpdateOpen.value;\n};\n\n// toggleFullScreen imported from '../fullscreen'\n\n// ── Combat Test ──\nconst getSelectedTestRelicCount = (name: string) => {\n  return Math.max(0, Math.floor(selectedTestRelicCounts.value[name] ?? 0));\n};\n\nconst setSelectedTestRelicCount = (name: string, next: number) => {\n  const value = Math.max(0, Math.floor(next));\n  if (value <= 0) {\n    delete selectedTestRelicCounts.value[name];\n    return;\n  }\n  selectedTestRelicCounts.value[name] = value;\n};\n\nconst increaseSelectedRelic = (name: string) => {\n  setSelectedTestRelicCount(name, getSelectedTestRelicCount(name) + 1);\n};\n\nconst decreaseSelectedRelic = (name: string) => {\n  setSelectedTestRelicCount(name, getSelectedTestRelicCount(name) - 1);\n};\n\nconst buildSelectedRelicPayload = (): Record<string, number> => {\n  const next: Record<string, number> = {};\n  for (const relic of baseRelicsForTest.value) {\n    const count = getSelectedTestRelicCount(relic.name);\n    if (count > 0) {\n      next[relic.name] = count;\n    }\n  }\n  return next;\n};\n\nconst openCombatTestBuilder = () => {\n  gameStore.loadStatData();\n  const availableCardNames = new Set(allCardsForTest.value.map(c => c.name));\n  const availableRelicNames = new Set(baseRelicsForTest.value.map((relic) => relic.name));\n  const presetDeck = Array.isArray(gameStore.statData._技能)\n    ? (gameStore.statData._技能 as string[]).filter((name) => availableCardNames.has(name)).slice(0, 9)\n    : [];\n  const presetRelicsRaw: Record<string, number> = gameStore.statData._圣遗物 ?? {};\n  const presetRelics: Record<string, number> = {};\n  for (const [name, value] of Object.entries(presetRelicsRaw)) {\n    if (!availableRelicNames.has(name)) continue;\n    const count = Math.max(0, Math.floor(Number(value ?? 0)));\n    if (count <= 0) continue;\n    presetRelics[name] = count;\n  }\n\n  selectedTestDeck.value = [...presetDeck];\n  selectedTestEnemy.value = '';\n  selectedTestRelicCounts.value = presetRelics;\n  selectedCardCategoryTab.value = '全部';\n  selectedRelicCategoryTab.value = '全部';\n  combatTestStartAt999.value = false;\n  combatTestStep.value = 'deck';\n  activeModal.value = 'combatTestBuilder';\n};\n\nconst addCardToTestDeck = (cardName: string) => {\n  if (selectedTestDeck.value.length >= 9) return;\n  selectedTestDeck.value.push(cardName);\n};\n\nconst removeCardFromTestDeck = (index: number) => {\n  if (index < 0 || index >= selectedTestDeck.value.length) return;\n  selectedTestDeck.value.splice(index, 1);\n};\n\nconst confirmCombatTestDeck = async () => {\n  if (selectedTestDeck.value.length !== 9) {\n    gameStore.error = '请先组满9张测试卡组。';\n    return;\n  }\n  const ok = await gameStore.updateStatDataFields({\n    _技能: [...selectedTestDeck.value],\n  });\n  if (!ok) return;\n\n  if (allEnemyNamesForTest.value.length === 0) {\n    gameStore.error = '当前没有可用魔物，请先在 enemyRegistry 注册敌人。';\n    return;\n  }\n  combatTestStep.value = 'enemy';\n};\n\nconst confirmCombatTestEnemyAndStart = async () => {\n  if (!selectedTestEnemy.value) {\n    gameStore.error = '请先选择一个魔物。';\n    return;\n  }\n  const enemyDef = getEnemyByName(selectedTestEnemy.value);\n  if (!enemyDef) {\n    gameStore.error = `未在敌人库中找到「${selectedTestEnemy.value}」`;\n    return;\n  }\n  const ok = await gameStore.updateStatDataFields({\n    _对手名称: selectedTestEnemy.value,\n    _圣遗物: buildSelectedRelicPayload(),\n  });\n  if (!ok) return;\n\n  activeModal.value = null;\n  combatEnemyName.value = selectedTestEnemy.value;\n  activeCombatContext.value = 'combatTest';\n  combatTestStartAt999CurrentBattle.value = combatTestStartAt999.value;\n  showCombat.value = true;\n};\n\nconst handleCombatEnd = async (win: boolean, finalStats: unknown, logs: string[], negativeEffects: string[]) => {\n  const context = activeCombatContext.value;\n  const enemyName = combatEnemyName.value || ((gameStore.statData._对手名称 as string) || '未知敌人');\n  pendingCombatNarrative.value = {\n    id: `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`,\n    context,\n    win,\n    enemyName,\n    text: buildCombatNarrative(win, enemyName, context, logs ?? []),\n  };\n\n  queueCombatMvuSync(win, finalStats, negativeEffects ?? []);\n\n  showCombat.value = false;\n  showVictoryRewardView.value = false;\n  combatTestStartAt999CurrentBattle.value = false;\n  activeCombatContext.value = 'normal';\n\n  if (!win) {\n    closeShopView();\n    const narrative = pendingCombatNarrative.value;\n    pendingCombatNarrative.value = null;\n    if (narrative) {\n      sendCombatNarrativeOnce(narrative, narrative.text);\n    }\n    console.log('[Combat] Result:', 'LOSE');\n    return;\n  }\n\n  if (context === 'shopRobbery' && enemyName === '沐芯兰') {\n    const ok = await gameStore.updateStatDataFields({ _是否已击败商人: true });\n    if (ok) {\n      shopRobbing.value = false;\n      showShopView.value = true;\n      applyMerchantDefeatedShopState();\n    } else if (pendingCombatNarrative.value) {\n      pendingCombatNarrative.value.context = 'normal';\n    }\n  }\n\n  const hasRewardOptions = startVictoryRewardFlow();\n  if (!hasRewardOptions) {\n    finalizeVictoryRewardFlow();\n  }\n  console.log('[Combat] Result:', 'WIN');\n};\n\nonBeforeUnmount(() => {\n  bondPortraitLoaderDisposed = true;\n  clearShopRobTimer();\n  clearChestMimicTimer();\n  clearChestRewardFadeTimer();\n  clearChestCloseLongPressTimer();\n  clearHotSpringCleanseTimer();\n  clearIdolRollTimer();\n});\n</script>\n\n<style scoped>\n@font-face {\n  font-family: 'MaShanZheng';\n  src: url('../font/MaShanZheng-Regular.ttf') format('truetype');\n  font-display: swap;\n}\n\n@font-face {\n  font-family: 'MagicBookTitle';\n  src: url('../font/平方赖江湖琅琊体.ttf') format('truetype');\n  font-display: swap;\n}\n\n.magic-book-title {\n  font-family: 'MaShanZheng', 'KaiTi', serif;\n  color: rgba(253, 230, 138, 0.95);\n  letter-spacing: 0.04em;\n  text-shadow:\n    0 1px 1px rgba(0, 0, 0, 0.9),\n    0 0 10px rgba(212, 175, 55, 0.35);\n}\n\n.story-rich-text {\n  display: flex;\n  flex-direction: column;\n  gap: 0.34em;\n}\n\n.story-line {\n  margin: 0;\n  white-space: pre-wrap;\n}\n\n.story-line-empty {\n  display: inline-block;\n  min-height: 1em;\n}\n\n.story-line-level-1 {\n  font-size: 1.55em;\n  line-height: 1.45;\n  font-weight: 700;\n  color: rgba(245, 222, 179, 0.96);\n}\n\n.story-line-level-2 {\n  font-size: 1.34em;\n  line-height: 1.5;\n  font-weight: 700;\n  color: rgba(245, 222, 179, 0.9);\n}\n\n.story-line-level-3 {\n  font-size: 1.2em;\n  line-height: 1.58;\n  font-weight: 600;\n  color: rgba(245, 222, 179, 0.86);\n}\n\n.story-line-level-4 {\n  font-size: 1.12em;\n  line-height: 1.64;\n  font-weight: 600;\n  color: rgba(245, 222, 179, 0.8);\n}\n\n.story-segment-muted {\n  color: rgba(156, 163, 175, 0.95);\n}\n\n.story-segment-quote {\n  color: #1d4ed8;\n}\n\n.story-tucao-section-list {\n  margin-top: 0.66rem;\n}\n\n.story-tucao-wrap {\n  margin: 0.26rem 0 0.34rem;\n}\n\n.story-tucao-toggle {\n  display: inline-flex;\n  align-items: center;\n  gap: 0.4rem;\n  border-radius: 9999px;\n  border: 1px solid rgba(251, 191, 36, 0.45);\n  background: rgba(48, 31, 20, 0.84);\n  color: rgba(252, 211, 77, 0.96);\n  font-size: 0.72em;\n  letter-spacing: 0.02em;\n  padding: 0.22rem 0.64rem;\n  transition: all 0.2s ease;\n}\n\n.story-tucao-toggle:hover {\n  color: rgba(254, 240, 138, 0.98);\n  border-color: rgba(252, 211, 77, 0.78);\n  box-shadow: 0 0 10px rgba(251, 191, 36, 0.32);\n}\n\n.story-tucao-panel {\n  margin-top: 0.6rem;\n  border-radius: 0.92rem;\n  border: 1px solid rgba(244, 114, 182, 0.42);\n  background:\n    linear-gradient(160deg, rgba(255, 249, 252, 0.9), rgba(255, 243, 250, 0.82)),\n    radial-gradient(circle at 6% 3%, rgba(244, 114, 182, 0.24), transparent 52%);\n  color: rgba(126, 60, 138, 0.95);\n  padding: 0.95rem 1.05rem;\n  box-shadow:\n    0 0 14px rgba(244, 114, 182, 0.18),\n    inset 0 1px 0 rgba(255, 255, 255, 0.5);\n}\n\n.story-tucao-panel .story-line {\n  color: rgba(126, 60, 138, 0.95);\n}\n\n.story-tucao-panel .story-segment-muted {\n  color: rgba(154, 126, 168, 0.9);\n}\n\n.story-tucao-panel .story-segment-quote {\n  color: rgba(30, 58, 138, 0.92);\n}\n\n.tucao-expand-enter-active,\n.tucao-expand-leave-active {\n  transition: all 0.22s ease;\n}\n\n.tucao-expand-enter-from,\n.tucao-expand-leave-to {\n  opacity: 0;\n  transform: translateY(-6px);\n}\n\n.status-slide-enter-active,\n.status-slide-leave-active {\n  transition: all 0.3s ease;\n}\n.status-slide-enter-from,\n.status-slide-leave-to {\n  opacity: 0;\n  transform: translateY(10px);\n}\n\n/* Heart container glow effect */\n.stat-container-heart {\n  filter: drop-shadow(0 0 6px rgba(180, 20, 20, 0.4));\n  transition: filter 0.3s ease;\n}\n.stat-container-heart:hover {\n  filter: drop-shadow(0 0 12px rgba(200, 30, 30, 0.7));\n}\n\n/* Mana container glow effect */\n.stat-container-mana {\n  filter: drop-shadow(0 0 6px rgba(50, 50, 200, 0.4));\n  transition: filter 0.3s ease;\n}\n.stat-container-mana:hover {\n  filter: drop-shadow(0 0 12px rgba(60, 60, 230, 0.7));\n}\n\n/* Combat overlay transition */\n.combat-fade-enter-active,\n.combat-fade-leave-active {\n  transition: opacity 0.4s ease;\n}\n.combat-fade-enter-from,\n.combat-fade-leave-to {\n  opacity: 0;\n}\n\n.relic-tooltip {\n  width: 15rem;\n  transform: translate(-50%, calc(-100% - 8px));\n  background: rgba(8, 10, 16, 0.96);\n  border: 1px solid rgba(255, 255, 255, 0.16);\n  border-radius: 0.5rem;\n  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.42);\n  padding: 0.5rem 0.6rem;\n}\n\n.relic-tooltip-name {\n  color: rgba(255, 255, 255, 0.95);\n  font-size: 11px;\n  font-weight: 700;\n  line-height: 1.2;\n}\n\n.relic-tooltip-desc {\n  margin-top: 0.28rem;\n  color: rgba(209, 213, 219, 0.9);\n  font-size: 10px;\n  line-height: 1.35;\n}\n\n.map-modal {\n  display: flex;\n  flex-direction: column;\n  gap: 0.65rem;\n}\n\n.map-toolbar {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: 0.8rem;\n}\n\n.map-summary {\n  color: rgba(245, 222, 179, 0.78);\n  font-size: 12px;\n  letter-spacing: 0.04em;\n}\n\n.map-summary-highlight {\n  color: rgba(251, 191, 36, 0.95);\n  font-weight: 700;\n}\n\n.map-summary-divider {\n  margin: 0 0.4rem;\n  color: rgba(245, 222, 179, 0.4);\n}\n\n.map-controls {\n  display: flex;\n  align-items: center;\n  gap: 0.45rem;\n}\n\n.map-control-btn {\n  height: 1.9rem;\n  min-width: 1.9rem;\n  border-radius: 0.45rem;\n  border: 1px solid rgba(217, 119, 6, 0.42);\n  background: rgba(24, 13, 8, 0.82);\n  color: rgba(253, 230, 138, 0.92);\n  font-size: 12px;\n  padding: 0 0.55rem;\n  transition: all 0.18s ease;\n}\n\n.map-control-btn:hover {\n  border-color: rgba(251, 191, 36, 0.72);\n  color: rgba(254, 243, 199, 0.98);\n  background: rgba(58, 32, 18, 0.82);\n}\n\n.map-control-btn--wide {\n  min-width: 4.4rem;\n}\n\n.map-empty {\n  height: 17rem;\n  border-radius: 0.6rem;\n  border: 1px dashed rgba(217, 119, 6, 0.4);\n  background: rgba(18, 10, 7, 0.7);\n  color: rgba(245, 222, 179, 0.55);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  font-size: 13px;\n}\n\n.map-viewport {\n  position: relative;\n  height: 17rem;\n  border-radius: 0.65rem;\n  border: 1px solid rgba(217, 119, 6, 0.35);\n  background:\n    radial-gradient(circle at 18% 16%, rgba(120, 53, 15, 0.24), transparent 54%),\n    radial-gradient(circle at 86% 84%, rgba(30, 41, 59, 0.34), transparent 58%),\n    rgba(16, 10, 8, 0.86);\n  overflow: hidden;\n  touch-action: none;\n  cursor: grab;\n}\n\n.map-viewport:active {\n  cursor: grabbing;\n}\n\n.map-canvas {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n\n.map-links {\n  position: absolute;\n  left: 0;\n  top: 0;\n  pointer-events: none;\n}\n\n.map-room-cell {\n  position: absolute;\n  width: 62px;\n  height: 62px;\n  border-radius: 0.55rem;\n  border: 2px solid rgba(255, 255, 255, 0.25);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  box-shadow:\n    inset 0 0 0 1px rgba(255, 255, 255, 0.12),\n    0 6px 16px rgba(0, 0, 0, 0.35);\n}\n\n.map-room-icon {\n  font-size: 1.3rem;\n  line-height: 1;\n  filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.55));\n}\n\n.map-room-step {\n  position: absolute;\n  right: 4px;\n  bottom: 3px;\n  font-size: 10px;\n  line-height: 1;\n  font-weight: 700;\n  color: rgba(255, 255, 255, 0.9);\n  text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);\n}\n\n.bond-list {\n  display: flex;\n  flex-direction: column;\n  gap: 0.85rem;\n}\n\n.bond-row {\n  display: flex;\n  align-items: stretch;\n  gap: 0.9rem;\n  border-radius: 0.9rem;\n  border: 1px solid rgba(212, 175, 55, 0.22);\n  background:\n    linear-gradient(140deg, rgba(20, 12, 8, 0.95), rgba(30, 19, 12, 0.9)),\n    radial-gradient(circle at 85% 0%, rgba(212, 175, 55, 0.12), transparent 48%);\n  padding: 0.72rem;\n  box-shadow:\n    inset 0 1px 0 rgba(255, 255, 255, 0.05),\n    0 10px 22px rgba(0, 0, 0, 0.34);\n}\n\n.bond-portrait-frame {\n  width: clamp(4.9rem, 16vw, 6.3rem);\n  min-width: clamp(4.9rem, 16vw, 6.3rem);\n  height: clamp(4.9rem, 15vw, 6.3rem);\n  border-radius: 0.7rem;\n  overflow: hidden;\n  border: 1px solid rgba(212, 175, 55, 0.45);\n  background: rgba(11, 8, 6, 0.9);\n  box-shadow:\n    0 0 0 1px rgba(255, 255, 255, 0.06),\n    0 10px 20px rgba(0, 0, 0, 0.45);\n}\n\n.bond-portrait-frame--clickable {\n  cursor: zoom-in;\n  transition: transform 0.2s ease, box-shadow 0.2s ease, border-color 0.2s ease;\n}\n\n.bond-portrait-frame--clickable:hover {\n  transform: translateY(-1px) scale(1.02);\n  border-color: rgba(251, 191, 36, 0.66);\n  box-shadow:\n    0 0 0 1px rgba(255, 255, 255, 0.1),\n    0 14px 24px rgba(0, 0, 0, 0.5),\n    0 0 20px rgba(251, 191, 36, 0.28);\n}\n\n.bond-portrait-image {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n}\n\n.bond-portrait-fallback {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: rgba(212, 175, 55, 0.88);\n  font-size: 1.3rem;\n  font-family: 'MagicBookTitle', 'KaiTi', serif;\n  background: radial-gradient(circle at 50% 35%, rgba(212, 175, 55, 0.24), rgba(21, 13, 9, 0.94));\n}\n\n.bond-affection-wrap {\n  flex: 1;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  gap: 0.44rem;\n  min-width: 0;\n}\n\n.bond-affection-head {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: 0.8rem;\n}\n\n.bond-role-name {\n  color: rgba(255, 243, 214, 0.95);\n  font-size: 1rem;\n  letter-spacing: 0.03em;\n  font-family: 'MagicBookTitle', 'KaiTi', serif;\n}\n\n.bond-affection-value {\n  font-size: 0.9rem;\n  font-weight: 700;\n  font-family: 'Cinzel', 'Microsoft YaHei', sans-serif;\n}\n\n.bond-affection-value--positive {\n  color: rgba(253, 186, 116, 0.95);\n}\n\n.bond-affection-value--negative {\n  color: rgba(125, 211, 252, 0.96);\n}\n\n.bond-affection-track {\n  position: relative;\n  height: 0.72rem;\n  border-radius: 9999px;\n  overflow: hidden;\n  border: 1px solid rgba(255, 255, 255, 0.14);\n  background:\n    linear-gradient(90deg, rgba(26, 42, 58, 0.72), rgba(26, 18, 14, 0.72)),\n    rgba(7, 7, 10, 0.72);\n}\n\n.bond-affection-fill {\n  height: 100%;\n  border-radius: inherit;\n  transition: width 0.25s ease;\n}\n\n.bond-affection-fill--positive {\n  background:\n    linear-gradient(90deg, rgba(245, 158, 11, 0.92), rgba(251, 191, 36, 0.95)),\n    rgba(245, 158, 11, 0.9);\n  box-shadow: 0 0 16px rgba(251, 191, 36, 0.4);\n}\n\n.bond-affection-fill--negative {\n  background:\n    linear-gradient(90deg, rgba(14, 165, 233, 0.9), rgba(56, 189, 248, 0.96)),\n    rgba(14, 165, 233, 0.9);\n  box-shadow: 0 0 16px rgba(56, 189, 248, 0.34);\n}\n\n.bond-preview-panel {\n  width: min(86vw, 1100px);\n  max-height: 90vh;\n  border-radius: 0.95rem;\n  overflow: hidden;\n  border: 1px solid rgba(212, 175, 55, 0.42);\n  background: rgba(10, 8, 7, 0.95);\n  box-shadow:\n    0 20px 56px rgba(0, 0, 0, 0.62),\n    0 0 36px rgba(251, 191, 36, 0.22);\n}\n\n.bond-preview-image {\n  display: block;\n  width: 100%;\n  max-height: calc(90vh - 3.2rem);\n  object-fit: contain;\n  background: radial-gradient(circle at 50% 0%, rgba(251, 191, 36, 0.08), rgba(8, 7, 6, 0.95) 62%);\n}\n\n.bond-preview-footer {\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  gap: 0.8rem;\n  border-top: 1px solid rgba(212, 175, 55, 0.28);\n  padding: 0.52rem 0.72rem;\n  background: rgba(21, 13, 9, 0.94);\n}\n\n.bond-preview-name {\n  color: rgba(255, 243, 214, 0.94);\n  font-size: 0.96rem;\n  font-family: 'MagicBookTitle', 'KaiTi', serif;\n  letter-spacing: 0.03em;\n}\n\n.bond-preview-close-btn {\n  border-radius: 9999px;\n  border: 1px solid rgba(212, 175, 55, 0.5);\n  background: rgba(17, 11, 8, 0.8);\n  color: rgba(251, 191, 36, 0.95);\n  padding: 0.18rem 0.72rem;\n  font-size: 0.78rem;\n  transition: border-color 0.2s ease, transform 0.2s ease, color 0.2s ease;\n}\n\n.bond-preview-close-btn:hover {\n  border-color: rgba(251, 191, 36, 0.82);\n  color: rgba(254, 240, 138, 0.98);\n  transform: translateY(-1px);\n}\n\n.chest-reward-anchor {\n  position: absolute;\n  left: 51%;\n  top: 56.5%;\n  transform: translate(-50%, -50%);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 0.72rem;\n}\n\n.chest-reward-anchor.is-multi {\n  gap: 1.2rem;\n}\n\n.chest-portals-anchor {\n  position: absolute;\n  left: 50%;\n  bottom: 1.75rem;\n  transform: translateX(-50%);\n}\n\n.chest-reward-icon {\n  width: 6.5rem;\n  height: 6.5rem;\n  color: rgba(252, 211, 77, 0.98);\n  transition: transform 0.2s ease, opacity 0.2s ease, filter 0.2s ease;\n  filter:\n    drop-shadow(0 0 14px rgba(251, 191, 36, 0.8))\n    drop-shadow(0 0 28px rgba(245, 158, 11, 0.55))\n    drop-shadow(0 8px 24px rgba(0, 0, 0, 0.65));\n}\n\n.chest-reward-btn {\n  border: 0;\n  border-radius: 9999px;\n  background: transparent;\n  padding: 0.25rem;\n  transition: transform 0.2s ease, opacity 0.2s ease;\n}\n\n.chest-reward-btn:hover .chest-reward-icon {\n  transform: scale(1.05);\n}\n\n.chest-reward-btn.is-collected {\n  opacity: 1;\n}\n\n.chest-reward-btn.is-collected .chest-reward-icon {\n  opacity: 0;\n  transform: scale(0.82);\n  filter:\n    drop-shadow(0 0 8px rgba(251, 191, 36, 0.45))\n    drop-shadow(0 0 16px rgba(245, 158, 11, 0.25))\n    drop-shadow(0 6px 14px rgba(0, 0, 0, 0.5));\n}\n\n.shop-panel {\n  border: 1px solid rgba(217, 119, 6, 0.4);\n  border-radius: 0.9rem;\n  background:\n    linear-gradient(145deg, rgba(23, 14, 8, 0.92), rgba(35, 21, 11, 0.9)),\n    radial-gradient(circle at 70% 10%, rgba(180, 83, 9, 0.2), transparent 52%);\n  box-shadow:\n    0 0 28px rgba(180, 83, 9, 0.25),\n    inset 0 1px 0 rgba(255, 255, 255, 0.08);\n  padding: 1.1rem 1.2rem 1.2rem;\n  display: flex;\n  flex-direction: column;\n  gap: 0.85rem;\n}\n\n.shop-layout {\n  left: 30%;\n}\n\n.shop-panel-head {\n  display: flex;\n  align-items: flex-start;\n  justify-content: space-between;\n  gap: 0.8rem;\n  border-bottom: 1px solid rgba(245, 158, 11, 0.25);\n  padding-bottom: 0.55rem;\n}\n\n.shop-goods-grid {\n  flex: 1;\n  overflow-y: auto;\n  display: grid;\n  grid-template-columns: repeat(4, minmax(0, 1fr));\n  column-gap: 1rem;\n  row-gap: 1.28rem;\n  margin-top: 1.44rem;\n  padding-right: 0.15rem;\n  align-content: start;\n}\n\n.shop-item-card {\n  border: 0;\n  border-radius: 0.55rem;\n  background: transparent;\n  width: 100%;\n  min-height: 132px;\n  padding: 0.28rem 0.2rem;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  gap: 0.28rem;\n  transition: transform 0.2s ease, opacity 0.25s ease, filter 0.2s ease;\n}\n\n.shop-item-card:hover {\n  transform: translateY(-1px) scale(1.02);\n  filter: brightness(1.04);\n}\n\n.shop-item-card.is-sold {\n  opacity: 0.18;\n  pointer-events: none;\n}\n\n.shop-item-icon-wrap {\n  margin-top: 0;\n}\n\n.shop-item-icon {\n  width: 3.4rem;\n  height: 3.4rem;\n  color: rgba(251, 191, 36, 0.98);\n  filter: drop-shadow(0 0 11px rgba(245, 158, 11, 0.65));\n}\n\n.shop-item-price {\n  display: inline-flex;\n  align-items: center;\n  gap: 0.3rem;\n  border: 1px solid rgba(245, 158, 11, 0.55);\n  border-radius: 9999px;\n  padding: 0.14rem 0.5rem;\n  color: rgba(255, 237, 213, 0.96);\n  background: rgba(38, 22, 11, 0.82);\n  font-size: 10px;\n}\n\n.shop-panel-foot {\n  margin-top: 0.35rem;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n\n.shop-rob-btn {\n  border-radius: 9999px;\n  border: 1px solid rgba(251, 191, 36, 0.5);\n  background:\n    radial-gradient(circle at 22% 20%, rgba(255, 237, 213, 0.16), transparent 45%),\n    linear-gradient(120deg, rgba(41, 24, 12, 0.8), rgba(92, 47, 14, 0.75) 50%, rgba(34, 19, 9, 0.82));\n  box-shadow:\n    0 0 10px rgba(245, 158, 11, 0.25),\n    inset 0 1px 0 rgba(255, 237, 213, 0.15);\n  transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;\n}\n\n.shop-rob-btn:hover:not(:disabled) {\n  transform: translateY(-1px);\n  box-shadow:\n    0 0 14px rgba(245, 158, 11, 0.42),\n    inset 0 1px 0 rgba(255, 237, 213, 0.2);\n}\n\n.shop-rob-btn:disabled {\n  cursor: not-allowed;\n}\n\n.shop-exit-btn {\n  border-radius: 9999px;\n  border: 1px solid rgba(251, 191, 36, 0.72);\n  background:\n    radial-gradient(circle at 22% 20%, rgba(255, 237, 213, 0.22), transparent 45%),\n    linear-gradient(120deg, rgba(41, 24, 12, 0.94), rgba(92, 47, 14, 0.92) 50%, rgba(34, 19, 9, 0.95));\n  box-shadow:\n    0 0 14px rgba(245, 158, 11, 0.45),\n    0 0 30px rgba(180, 83, 9, 0.35),\n    inset 0 1px 0 rgba(255, 237, 213, 0.2);\n  transition: transform 0.2s ease, box-shadow 0.2s ease;\n}\n\n.shop-exit-btn:hover:not(:disabled) {\n  transform: translateY(-1px);\n  box-shadow:\n    0 0 18px rgba(251, 191, 36, 0.62),\n    0 0 36px rgba(217, 119, 6, 0.42),\n    inset 0 1px 0 rgba(255, 237, 213, 0.24);\n}\n\n.shop-exit-btn:disabled {\n  opacity: 0.48;\n  cursor: not-allowed;\n}\n\n.spring-cleanse-float {\n  position: absolute;\n  left: 50%;\n  bottom: 1.25rem;\n  max-width: min(90%, 860px);\n  transform: translateX(-50%);\n  color: rgba(255, 255, 255, 0.96);\n  font-family: 'MagicBookTitle', 'KaiTi', serif;\n  font-size: clamp(1rem, 1.9vw, 1.35rem);\n  line-height: 1.45;\n  text-align: center;\n  pointer-events: none;\n  z-index: 28;\n  text-shadow:\n    0 1px 2px rgba(0, 0, 0, 0.75),\n    0 0 14px rgba(255, 255, 255, 0.22);\n  animation: spring-cleanse-float-up 2.6s ease-out forwards;\n}\n\n@keyframes spring-cleanse-float-up {\n  0% {\n    opacity: 0;\n    transform: translate(-50%, 10px);\n  }\n  14% {\n    opacity: 1;\n    transform: translate(-50%, 0);\n  }\n  100% {\n    opacity: 0;\n    transform: translate(-50%, -50px);\n  }\n}\n\n.idol-layout {\n  pointer-events: none;\n}\n\n.idol-slots-row {\n  position: absolute;\n  left: 50%;\n  bottom: 28vh;\n  transform: translateX(-50%);\n  width: min(920px, calc(100vw - 48px));\n  display: grid;\n  grid-template-columns: repeat(3, minmax(0, 1fr));\n  gap: clamp(0.9rem, 2.8vw, 2.2rem);\n  align-items: center;\n  justify-items: center;\n  pointer-events: none;\n}\n\n.idol-slot {\n  width: clamp(4.8rem, 7.2vw, 6.9rem);\n  height: clamp(4.2rem, 6.6vw, 6.1rem);\n  clip-path: polygon(50% 0%, 94% 25%, 94% 75%, 50% 100%, 6% 75%, 6% 25%);\n  border: 2px solid rgba(255, 255, 255, 0.95);\n  background: rgba(255, 255, 255, 0.9);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  text-align: center;\n  box-shadow:\n    0 0 12px rgba(255, 255, 255, 0.35),\n    0 0 26px rgba(255, 255, 255, 0.2);\n  transition: all 0.2s ease;\n  position: relative;\n}\n\n.idol-slot-wrap {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  gap: 0.52rem;\n  pointer-events: none;\n}\n\n.idol-slot.is-preview {\n  border-color: rgba(253, 224, 71, 1);\n  background: rgba(255, 255, 255, 0.98);\n  box-shadow:\n    0 0 20px rgba(253, 224, 71, 0.5),\n    0 0 36px rgba(253, 224, 71, 0.35);\n}\n\n.idol-slot.is-selected {\n  border-color: rgba(255, 255, 255, 1);\n  background: rgba(255, 255, 255, 1);\n  box-shadow:\n    0 0 24px rgba(255, 255, 255, 0.55),\n    0 0 40px rgba(253, 224, 71, 0.35);\n}\n\n.idol-slot-hint {\n  position: relative;\n  color: rgba(240, 249, 255, 0.95);\n  font-size: clamp(0.95rem, 1.6vw, 1.28rem);\n  font-weight: 700;\n  white-space: nowrap;\n  text-shadow:\n    0 1px 2px rgba(0, 0, 0, 0.7),\n    0 0 8px rgba(148, 163, 184, 0.35);\n  animation: idolHintFloat 3.4s ease-in-out infinite;\n  z-index: 3;\n}\n\n.idol-dice-stage {\n  position: absolute;\n  inset: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  pointer-events: none;\n}\n\n.idol-dice-draggable {\n  position: absolute;\n  left: 0;\n  top: 0;\n  cursor: grab;\n  touch-action: none;\n  user-select: none;\n  transition: transform 0.08s linear;\n  pointer-events: auto;\n}\n\n.idol-dice-draggable:active {\n  cursor: grabbing;\n}\n\n.idol-dice-draggable.is-locked {\n  cursor: default;\n  opacity: 0.88;\n}\n\n@keyframes idolHintFloat {\n  0%,\n  100% {\n    transform: translateY(0px);\n    opacity: 0.9;\n  }\n  50% {\n    transform: translateY(-6px);\n    opacity: 1;\n  }\n}\n\n.idol-exit-btn {\n  border-radius: 9999px;\n  border: 1px solid rgba(196, 136, 255, 0.72);\n  background:\n    radial-gradient(circle at 20% 10%, rgba(255, 255, 255, 0.18), transparent 48%),\n    linear-gradient(120deg, rgba(44, 20, 74, 0.94), rgba(86, 38, 138, 0.9) 50%, rgba(27, 12, 48, 0.95));\n  box-shadow:\n    0 0 14px rgba(168, 85, 247, 0.45),\n    0 0 28px rgba(109, 40, 217, 0.34),\n    inset 0 1px 0 rgba(255, 255, 255, 0.2);\n  transition: transform 0.2s ease, box-shadow 0.2s ease, opacity 0.2s ease;\n}\n\n.idol-exit-btn:hover:not(:disabled) {\n  transform: translateY(-1px);\n  box-shadow:\n    0 0 18px rgba(196, 136, 255, 0.58),\n    0 0 34px rgba(147, 51, 234, 0.4),\n    inset 0 1px 0 rgba(255, 255, 255, 0.24);\n}\n\n.idol-exit-btn:disabled {\n  opacity: 0.48;\n  cursor: not-allowed;\n}\n\n@media (max-width: 768px) {\n  .shop-layout {\n    left: 2%;\n    right: 2%;\n  }\n\n  .shop-panel {\n    height: 82vh;\n    max-height: none;\n    padding: 0.9rem;\n  }\n\n  .shop-goods-grid {\n    grid-template-columns: repeat(3, minmax(0, 1fr));\n    column-gap: 0.7rem;\n    row-gap: 0.95rem;\n    margin-top: 1.2rem;\n  }\n\n  .chest-reward-anchor {\n    left: 46%;\n    top: 57.5%;\n  }\n\n  .chest-portals-anchor {\n    bottom: 1.1rem;\n  }\n\n  .idol-slots-row {\n    width: calc(100vw - 24px);\n    bottom: 31vh;\n    gap: 0.4rem;\n  }\n\n  .idol-slot {\n    width: 4.4rem;\n    height: 3.9rem;\n  }\n\n  .idol-slot-hint {\n    font-size: 0.72rem;\n  }\n\n  .idol-exit-btn {\n    right: 0.9rem;\n    bottom: 0.8rem;\n    padding: 0.55rem 1rem;\n  }\n}\n</style>\n","<template>\n  <DungeonModal\n    title=\"魔女的收藏\"\n    :is-open=\"isOpen\"\n    panel-class=\"codex-single-modal !max-w-[min(96vw,1500px)] !max-h-[94%]\"\n    @close=\"$emit('close')\"\n  >\n    <div class=\"codex-root\">\n      <!-- Decorative top glow line -->\n      <div class=\"codex-top-glow\"></div>\n\n      <header class=\"top-nav\">\n        <button\n          v-for=\"tab in tabs\"\n          :key=\"tab.id\"\n          type=\"button\"\n          class=\"top-nav-btn\"\n          :class=\"{ active: activeTab === tab.id }\"\n          @click=\"setMainTab(tab.id)\"\n        >\n          <span class=\"top-nav-btn-text\">{{ tab.label }}</span>\n        </button>\n      </header>\n\n      <div class=\"book-layout\">\n        <aside class=\"side-nav\">\n          <div class=\"side-title\">{{ sideTitle }}</div>\n          <div class=\"side-divider\"></div>\n          <button\n            v-for=\"item in sideItems\"\n            :key=\"`${activeTab}-${item.key}`\"\n            type=\"button\"\n            class=\"side-btn\"\n            :class=\"{ active: currentFilter === item.key }\"\n            @click=\"setFilter(item.key)\"\n          >\n            {{ item.label }}\n          </button>\n\n        </aside>\n\n        <section class=\"book-shell\">\n          <Transition :name=\"flipName\" mode=\"out-in\">\n            <article :key=\"pageKey\" class=\"book-page\">\n              <div v-if=\"activeTab === 'cards'\" class=\"card-grid\">\n                <DungeonCard\n                  v-for=\"card in pagedCards\"\n                  :key=\"`card-${card.id}`\"\n                  :card=\"card\"\n                  :disabled=\"true\"\n                  :mask-level=\"encounteredCardIds.has(card.id) ? 'none' : 'full'\"\n                />\n              </div>\n\n              <div v-else-if=\"activeTab === 'relics'\" class=\"entry-grid\">\n                <article v-for=\"relic in pagedRelics\" :key=\"`relic-${relic.id}`\" class=\"entry-card\">\n                  <div class=\"entry-title\">{{ encounteredRelicIds.has(relic.id) ? relic.name : '???' }}</div>\n                  <div class=\"entry-meta\">{{ encounteredRelicIds.has(relic.id) ? `${relic.category} · ${relic.rarity}` : '??? · ???' }}</div>\n                  <p class=\"entry-desc\">{{ encounteredRelicIds.has(relic.id) ? relic.effect : '???' }}</p>\n                </article>\n              </div>\n\n              <div v-else-if=\"activeTab === 'status'\" class=\"entry-grid\">\n                <article v-for=\"effect in pagedEffects\" :key=\"`effect-${effect.type}`\" class=\"entry-card\">\n                  <div class=\"effect-row\">\n                    <span class=\"effect-icon\">\n                      <i\n                        v-if=\"encounteredEffectTypes.has(effect.type) && effect.faClass\"\n                        :class=\"[effect.faClass, 'text-[14px] leading-none']\"\n                        :style=\"effect.faStyle\"\n                        aria-hidden=\"true\"\n                      ></i>\n                      <span v-else>?</span>\n                    </span>\n                    <div class=\"entry-title\">{{ encounteredEffectTypes.has(effect.type) ? effect.name : '???' }}</div>\n                  </div>\n                  <div class=\"entry-meta\">{{ encounteredEffectTypes.has(effect.type) ? effect.kind : '???' }}</div>\n                  <p class=\"entry-desc\">{{ encounteredEffectTypes.has(effect.type) ? (effect.description || '暂无说明') : '???' }}</p>\n                </article>\n              </div>\n\n              <div v-else class=\"enemy-grid\">\n                <article v-for=\"enemy in pagedEnemies\" :key=\"enemy.name\" class=\"entry-card enemy-card\">\n                  <div class=\"enemy-head\">\n                    <div class=\"portrait\">\n                      <img\n                        v-if=\"encounteredEnemyNames.has(enemy.name) && !portraitErrorMap[enemy.name]\"\n                        :src=\"portraitMap[enemy.name] || enemy.fallbackPortraitUrl\"\n                        :alt=\"`${enemy.name}立绘`\"\n                        class=\"portrait-img\"\n                        loading=\"lazy\"\n                        @error=\"markPortraitError(enemy.name)\"\n                      />\n                      <div v-else class=\"portrait-fallback\">?</div>\n                    </div>\n                    <div class=\"enemy-head-text\">\n                      <div class=\"entry-title\">{{ encounteredEnemyNames.has(enemy.name) ? enemy.name : '???' }}</div>\n                      <div class=\"entry-meta\">\n                        {{\n                          encounteredEnemyNames.has(enemy.name)\n                            ? `第${enemy.floorLabel}层 · ${enemy.areaLabel}`\n                            : `第${enemy.floorLabel}层 · ???`\n                        }}\n                      </div>\n                    </div>\n                  </div>\n                  <div class=\"entry-meta\">\n                    {{\n                      encounteredEnemyNames.has(enemy.name)\n                        ? `HP ${enemy.stats.hp}/${enemy.stats.maxHp} · MP ${enemy.stats.mp} · 骰子 ${enemy.stats.minDice}~${enemy.stats.maxDice}`\n                        : 'HP ??? · MP ??? · 骰子 ???'\n                    }}\n                  </div>\n                  <p class=\"entry-desc\">\n                    {{\n                      encounteredEnemyNames.has(enemy.name)\n                        ? `卡牌：${enemy.deckCardNames.join('、') || '无'}`\n                        : '卡牌：???'\n                    }}\n                  </p>\n                </article>\n              </div>\n\n              <div class=\"page-foot\">\n                <button type=\"button\" class=\"bookmark bookmark-prev\" :disabled=\"currentPage <= 1\" @click=\"prevPage\">\n                  ◀\n                </button>\n                <span class=\"page-indicator\">第 {{ currentPage }} / {{ totalPages }} 页</span>\n                <button type=\"button\" class=\"bookmark bookmark-next\" :disabled=\"currentPage >= totalPages\" @click=\"nextPage\">\n                  下一页\n                </button>\n              </div>\n            </article>\n          </Transition>\n        </section>\n      </div>\n    </div>\n  </DungeonModal>\n</template>\n\n<script setup lang=\"ts\">\nimport { getAllCards } from '../battle/cardRegistry';\nimport { EFFECT_REGISTRY } from '../battle/effects';\nimport { getAllEnemyNames, getEnemyByName } from '../battle/enemyRegistry';\nimport { getAllRelics } from '../battle/relicRegistry';\nimport { loadCodexState } from '../codexStore';\nimport { CardType, EffectType as ET, type EffectType } from '../types';\nimport DungeonCard from './DungeonCard.vue';\nimport DungeonModal from './DungeonModal.vue';\n\ntype TabId = 'cards' | 'relics' | 'enemies' | 'status';\ntype StatusKind = '正面' | '负面' | '被动';\ntype NavItem = { key: string; label: string };\n\nconst props = defineProps<{ isOpen: boolean }>();\ndefineEmits<{ close: [] }>();\n\nconst tabs: Array<{ id: TabId; label: string }> = [\n  { id: 'cards', label: '卡牌' },\n  { id: 'relics', label: '圣遗物' },\n  { id: 'enemies', label: '敌人' },\n  { id: 'status', label: '状态' },\n];\n\nconst CARD_TYPE_ORDER: Record<string, number> = {\n  [CardType.PHYSICAL]: 0,\n  [CardType.MAGIC]: 1,\n  [CardType.FUNCTION]: 2,\n  [CardType.DODGE]: 3,\n  [CardType.CURSE]: 4,\n};\nconst RELIC_RARITY_ORDER: Record<string, number> = { 普通: 0, 稀有: 1, 传奇: 2 };\nconst PAGE_SIZE: Record<TabId, number> = { cards: 9, relics: 20, enemies: 8, status: 20 };\n\nconst activeTab = ref<TabId>('cards');\nconst currentPage = ref(1);\nconst flipName = ref<'flip-next' | 'flip-prev'>('flip-next');\nconst codex = ref(loadCodexState());\n\nconst cardFilter = ref('全部');\nconst relicFilter = ref('全部');\nconst enemyFloorFilter = ref('全部');\nconst statusFilter = ref<'全部' | StatusKind>('全部');\n\nconst refreshCodex = () => {\n  codex.value = loadCodexState();\n};\n\nconst encounteredCardIds = computed(() => new Set(codex.value.cards));\nconst encounteredRelicIds = computed(() => new Set(codex.value.relics));\nconst encounteredEffectTypes = computed(() => new Set(codex.value.effects));\nconst encounteredEnemyNames = computed(() => new Set(codex.value.enemies.map((enemy) => enemy.name)));\n\nconst allCards = computed(() => (\n  getAllCards().slice().sort((a, b) => {\n    const categoryComp = a.category.localeCompare(b.category, 'zh-Hans-CN');\n    if (categoryComp !== 0) return categoryComp;\n    const typeComp = (CARD_TYPE_ORDER[a.type] ?? 99) - (CARD_TYPE_ORDER[b.type] ?? 99);\n    if (typeComp !== 0) return typeComp;\n    return a.name.localeCompare(b.name, 'zh-Hans-CN');\n  })\n));\nconst cardCategories = computed(() => Array.from(new Set(allCards.value.map((card) => card.category))).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN')));\nconst filteredCards = computed(() => (cardFilter.value === '全部' ? allCards.value : allCards.value.filter((card) => card.category === cardFilter.value)));\n\nconst allRelics = computed(() => (\n  getAllRelics().slice().sort((a, b) => {\n    const rarityComp = (RELIC_RARITY_ORDER[a.rarity] ?? 99) - (RELIC_RARITY_ORDER[b.rarity] ?? 99);\n    if (rarityComp !== 0) return rarityComp;\n    const categoryComp = a.category.localeCompare(b.category, 'zh-Hans-CN');\n    if (categoryComp !== 0) return categoryComp;\n    return a.name.localeCompare(b.name, 'zh-Hans-CN');\n  })\n));\nconst relicCategories = computed(() => Array.from(new Set(allRelics.value.map((relic) => relic.category))).sort((a, b) => a.localeCompare(b, 'zh-Hans-CN')));\nconst filteredRelics = computed(() => (relicFilter.value === '全部' ? allRelics.value : allRelics.value.filter((relic) => relic.category === relicFilter.value)));\n\nconst effectKind = (polarity?: string): StatusKind => {\n  if (polarity === 'buff') return '正面';\n  if (polarity === 'debuff') return '负面';\n  return '被动';\n};\nconst EFFECT_FA_ICON_CLASS: Partial<Record<EffectType, string>> = {\n  [ET.BARRIER]: 'fa-brands fa-fediverse',\n  [ET.ARMOR]: 'fa-solid fa-shield-halved',\n  [ET.BIND]: 'fa-solid fa-link',\n  [ET.DEVOUR]: 'fa-brands fa-optin-monster',\n  [ET.POISON]: 'fa-solid fa-virus',\n  [ET.POISON_AMOUNT]: 'fa-solid fa-bacterium',\n  [ET.CORROSION]: 'fa-brands fa-cloudscale',\n  [ET.BURN]: 'fa-solid fa-fire',\n  [ET.BLEED]: 'fa-solid fa-droplet',\n  [ET.VULNERABLE]: 'fa-brands fa-linode',\n  [ET.DAMAGE_BOOST]: 'fa-brands fa-superpowers',\n  [ET.REGEN]: 'fa-brands fa-medrt',\n  [ET.WHITE_TURBID]: 'fa-solid fa-droplet',\n  [ET.IGNITE_AURA]: 'fa-solid fa-fire-flame-simple',\n  [ET.STUN]: 'fa-solid fa-ban',\n  [ET.CHARGE]: 'fa-solid fa-exclamation',\n  [ET.FATIGUE]: 'fa-solid fa-bed',\n  [ET.COLD]: 'fa-regular fa-snowflake',\n  [ET.TEMPERATURE_DIFF]: 'fa-brands fa-empire',\n  [ET.NON_LIVING]: 'fa-solid fa-skull',\n  [ET.NON_ENTITY]: 'fa-solid fa-ghost',\n  [ET.ILLUSORY_BODY]: 'fa-solid fa-ghost',\n  [ET.TEMP_MAX_HP]: 'fa-solid fa-heart',\n  [ET.MAX_HP_REDUCTION]: 'fa-solid fa-heart-pulse',\n  [ET.POINT_GROWTH_BIG]: 'fa-solid fa-dice fa-lg',\n  [ET.POINT_GROWTH_SMALL]: 'fa-solid fa-dice fa-sm',\n  [ET.MANA_DRAIN]: 'fa-solid fa-battery-empty',\n  [ET.MANA_SPRING]: 'fa-brands fa-drupal',\n  [ET.SWARM]: 'fa-solid fa-bugs',\n  [ET.BLOOD_COCOON]: 'fa-brands fa-battle-net',\n  [ET.INDOMITABLE]: 'fa-solid fa-shield',\n  [ET.PEEP_FORBIDDEN]: 'fa-solid fa-eye',\n  [ET.BLIND_ASH]: 'fa-regular fa-eye-slash',\n  [ET.COGNITIVE_INTERFERENCE]: 'fa-solid fa-hamsa',\n  [ET.MEMORY_FOG]: 'fa-brands fa-phabricator',\n  [ET.SILENCE]: 'fa-solid fa-circle-xmark',\n  [ET.STURDY]: 'fa-solid fa-user-shield',\n  [ET.SHOCK]: 'fa-solid fa-bolt',\n  [ET.FLAME_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.POISON_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.TOXIN_SPREAD]: 'fa-brands fa-hornbill',\n  [ET.AMBUSH]: 'fa-solid fa-user-secret',\n  [ET.FROST_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.BLOODBLADE_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.LIGHTNING_ATTACH]: 'fa-solid fa-flask-vial',\n  [ET.THORNS]: 'fa-solid fa-leaf',\n};\nconst EFFECT_FA_ICON_STYLE: Partial<Record<EffectType, Record<string, string>>> = {\n  [ET.FLAME_ATTACH]: { color: 'rgb(255, 64, 64)' },\n  [ET.POISON_ATTACH]: { color: 'rgb(81, 255, 116)' },\n  [ET.FROST_ATTACH]: { color: 'rgb(108, 230, 255)' },\n  [ET.BLOODBLADE_ATTACH]: { color: 'rgb(176, 0, 0)' },\n  [ET.LIGHTNING_ATTACH]: { color: 'rgb(201, 69, 255)' },\n  [ET.TEMP_MAX_HP]: { color: 'rgb(255, 120, 150)' },\n  [ET.ILLUSORY_BODY]: {\n    '--fa-primary-color': 'rgb(255, 255, 255)',\n    '--fa-secondary-color': 'rgb(255, 255, 255)',\n  },\n};\nconst getEffectFontAwesomeClass = (type: EffectType): string | null => EFFECT_FA_ICON_CLASS[type] ?? null;\nconst getEffectFontAwesomeStyle = (type: EffectType): Record<string, string> | undefined => EFFECT_FA_ICON_STYLE[type];\nconst allEffects = computed(() => (\n  Object.entries(EFFECT_REGISTRY)\n    .map(([type, def]) => ({\n      type,\n      name: def.name,\n      description: def.description ?? '',\n      kind: effectKind(def.polarity),\n      faClass: getEffectFontAwesomeClass(type as EffectType),\n      faStyle: getEffectFontAwesomeStyle(type as EffectType),\n    }))\n    .sort((a, b) => {\n      const order: Record<StatusKind, number> = { 正面: 0, 负面: 1, 被动: 2 };\n      const kindComp = (order[a.kind] ?? 99) - (order[b.kind] ?? 99);\n      if (kindComp !== 0) return kindComp;\n      return a.name.localeCompare(b.name, 'zh-Hans-CN');\n    })\n));\nconst filteredEffects = computed(() => (statusFilter.value === '全部' ? allEffects.value : allEffects.value.filter((effect) => effect.kind === statusFilter.value)));\n\nconst ENEMY_FLOOR_HINT: Record<string, number> = {\n  沐芯兰: 1,\n  宝箱怪: 1,\n  游荡粘液球: 1,\n  荧光蛾: 1,\n  根须潜行者: 1,\n  沼泽潜伏者: 1,\n  拟态气泡怪: 1,\n  迷雾精怪: 1,\n  藤蔓行者: 1,\n  泉水精魄: 1,\n  潜伏触手怪: 1,\n  穴居触手: 1,\n  极乐蜜蜂: 1,\n  花粉喷射者: 1,\n  普莉姆: 1,\n  宁芙: 1,\n  温蒂尼: 1,\n  玛塔: 1,\n  罗丝: 1,\n};\n\nconst allEnemies = computed(() => (\n  getAllEnemyNames().map((name) => {\n    const encounters = codex.value.enemies.filter((entry) => entry.name === name);\n    const floor = ENEMY_FLOOR_HINT[name] ?? (encounters[0]?.floor ?? 0);\n    const areaLabel = encounters[0]?.area ?? '未知区域';\n    const def = getEnemyByName(name, Math.max(1, floor)) ?? getEnemyByName(name, 1);\n    const stats = def?.stats ?? { hp: 0, maxHp: 0, mp: 0, minDice: 0, maxDice: 0 };\n    return {\n      name,\n      floor,\n      floorLabel: floor > 0 ? String(floor) : '未知',\n      areaLabel,\n      fallbackPortraitUrl: `https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/%E5%9C%B0%E7%89%A2/%E9%AD%94%E7%89%A9/${encodeURIComponent(name)}.png`,\n      stats: {\n        hp: stats.hp,\n        maxHp: stats.maxHp,\n        mp: stats.mp,\n        minDice: stats.minDice,\n        maxDice: stats.maxDice,\n      },\n      deckCardNames: def?.deck?.map((card) => card.name) ?? [],\n    };\n  }).sort((a, b) => {\n    if (a.floor !== b.floor) return a.floor - b.floor;\n    return a.name.localeCompare(b.name, 'zh-Hans-CN');\n  })\n));\nconst enemyFloorItems = computed<NavItem[]>(() => {\n  const floors = Array.from(new Set(allEnemies.value.map((enemy) => enemy.floorLabel))).sort((a, b) => (a === '未知' ? 1 : b === '未知' ? -1 : Number(a) - Number(b)));\n  return [{ key: '全部', label: '全部' }, ...floors.map((floor) => ({ key: floor, label: floor === '未知' ? '未知' : `第${floor}层` }))];\n});\nconst filteredEnemies = computed(() => {\n  if (enemyFloorFilter.value === '全部') return allEnemies.value;\n  return allEnemies.value.filter((enemy) => enemy.floorLabel === enemyFloorFilter.value);\n});\n\nconst sideTitle = computed(() => {\n  if (activeTab.value === 'cards') return '体系';\n  if (activeTab.value === 'relics') return '体系';\n  if (activeTab.value === 'enemies') return '楼层';\n  return '状态';\n});\nconst sideItems = computed<NavItem[]>(() => {\n  if (activeTab.value === 'cards') return [{ key: '全部', label: '全部' }, ...cardCategories.value.map((category) => ({ key: category, label: category }))];\n  if (activeTab.value === 'relics') return [{ key: '全部', label: '全部' }, ...relicCategories.value.map((category) => ({ key: category, label: category }))];\n  if (activeTab.value === 'enemies') return enemyFloorItems.value;\n  return [{ key: '全部', label: '全部' }, { key: '正面', label: '正面' }, { key: '负面', label: '负面' }, { key: '被动', label: '被动' }];\n});\nconst currentFilter = computed(() => {\n  if (activeTab.value === 'cards') return cardFilter.value;\n  if (activeTab.value === 'relics') return relicFilter.value;\n  if (activeTab.value === 'enemies') return enemyFloorFilter.value;\n  return statusFilter.value;\n});\n\nconst totalItems = computed(() => {\n  if (activeTab.value === 'cards') return filteredCards.value.length;\n  if (activeTab.value === 'relics') return filteredRelics.value.length;\n  if (activeTab.value === 'enemies') return filteredEnemies.value.length;\n  return filteredEffects.value.length;\n});\nconst totalPages = computed(() => Math.max(1, Math.ceil(totalItems.value / PAGE_SIZE[activeTab.value])));\nconst pageKey = computed(() => `${activeTab.value}-${currentFilter.value}-${currentPage.value}`);\nconst pageStart = computed(() => (currentPage.value - 1) * PAGE_SIZE[activeTab.value]);\nconst pageEnd = computed(() => pageStart.value + PAGE_SIZE[activeTab.value]);\n\nconst pagedCards = computed(() => filteredCards.value.slice(pageStart.value, pageEnd.value));\nconst pagedRelics = computed(() => filteredRelics.value.slice(pageStart.value, pageEnd.value));\nconst pagedEffects = computed(() => filteredEffects.value.slice(pageStart.value, pageEnd.value));\nconst pagedEnemies = computed(() => filteredEnemies.value.slice(pageStart.value, pageEnd.value));\n\nconst setMainTab = (tab: TabId) => {\n  if (activeTab.value === tab) return;\n  activeTab.value = tab;\n  flipName.value = 'flip-next';\n  currentPage.value = 1;\n};\nconst setFilter = (key: string) => {\n  if (activeTab.value === 'cards') cardFilter.value = key;\n  if (activeTab.value === 'relics') relicFilter.value = key;\n  if (activeTab.value === 'enemies') enemyFloorFilter.value = key;\n  if (activeTab.value === 'status') statusFilter.value = key as '全部' | StatusKind;\n  flipName.value = 'flip-next';\n  currentPage.value = 1;\n};\nconst prevPage = () => {\n  if (currentPage.value <= 1) return;\n  flipName.value = 'flip-prev';\n  currentPage.value -= 1;\n};\nconst nextPage = () => {\n  if (currentPage.value >= totalPages.value) return;\n  flipName.value = 'flip-next';\n  currentPage.value += 1;\n};\n\nwatch(totalPages, (pages) => {\n  currentPage.value = Math.min(Math.max(1, currentPage.value), pages);\n});\n\nconst portraitMap = ref<Record<string, string>>({});\nconst portraitErrorMap = ref<Record<string, boolean>>({});\nconst folderCache = new Map<string, string[]>();\nconst folderPromise = new Map<string, Promise<string[]>>();\n\nconst parseNextLink = (linkHeader: string | null): string | null => {\n  if (!linkHeader) return null;\n  const match = linkHeader.match(/<([^>]+)>\\s*;\\s*rel=\"next\"/i);\n  return match?.[1] ?? null;\n};\nconst fetchFolderImages = async (folderPath: string): Promise<string[]> => {\n  if (folderCache.has(folderPath)) return folderCache.get(folderPath)!;\n  if (folderPromise.has(folderPath)) return folderPromise.get(folderPath)!;\n  const task = (async () => {\n    const images: string[] = [];\n    let nextUrl: string | null = `https://huggingface.co/api/datasets/Vin05/AI-Gallery/tree/main/${encodeURIComponent(folderPath).replace(/%2F/g, '/')}?recursive=true&limit=1000`;\n    while (nextUrl) {\n      let response: Response;\n      try {\n        response = await fetch(nextUrl);\n      } catch {\n        break;\n      }\n      if (!response.ok) break;\n      let entries: Array<{ type?: string; path?: string }> = [];\n      try {\n        entries = await response.json() as Array<{ type?: string; path?: string }>;\n      } catch {\n        break;\n      }\n      for (const entry of entries) {\n        if (entry.type !== 'file' || !entry.path) continue;\n        if (!/\\.(png|jpe?g|webp|gif|avif|bmp|svg)$/i.test(entry.path)) continue;\n        images.push(entry.path);\n      }\n      nextUrl = parseNextLink(response.headers.get('link'));\n    }\n    folderCache.set(folderPath, images);\n    return images;\n  })();\n  folderPromise.set(folderPath, task);\n  try {\n    return await task;\n  } finally {\n    folderPromise.delete(folderPath);\n  }\n};\nconst ensurePortraits = async () => {\n  if (activeTab.value !== 'enemies') return;\n  const targets = pagedEnemies.value.filter((enemy) => encounteredEnemyNames.value.has(enemy.name));\n  await Promise.all(targets.map(async (enemy) => {\n    if (portraitMap.value[enemy.name]) return;\n    const images = await fetchFolderImages(`地牢/魔物/${enemy.name}`);\n    const chosen = images.length > 0 ? images[Math.floor(Math.random() * images.length)] : null;\n    portraitMap.value[enemy.name] = chosen ? `https://huggingface.co/datasets/Vin05/AI-Gallery/resolve/main/${encodeURIComponent(chosen).replace(/%2F/g, '/')}` : enemy.fallbackPortraitUrl;\n  }));\n};\nconst markPortraitError = (name: string) => {\n  portraitErrorMap.value[name] = true;\n};\n\nwatch(\n  () => props.isOpen,\n  (open) => {\n    if (!open) return;\n    refreshCodex();\n    currentPage.value = 1;\n    void ensurePortraits();\n  },\n  { immediate: true },\n);\n\nwatch([activeTab, currentPage, enemyFloorFilter], () => {\n  if (!props.isOpen) return;\n  void ensurePortraits();\n});\n</script>\n\n<style scoped>\n/* ── Root ── */\n.codex-root {\n  display: flex;\n  flex-direction: column;\n  gap: 0.85rem;\n  position: relative;\n}\n\n/* ── Decorative Top Glow ── */\n.codex-top-glow {\n  height: 1px;\n  background: linear-gradient(90deg, transparent 5%, rgba(212, 175, 55, 0.5) 30%, rgba(160, 50, 50, 0.4) 50%, rgba(212, 175, 55, 0.5) 70%, transparent 95%);\n  margin-bottom: 0.2rem;\n  border-radius: 1px;\n  box-shadow: 0 0 12px rgba(160, 50, 50, 0.2), 0 0 6px rgba(212, 175, 55, 0.25);\n}\n\n/* ── Top Navigation ── */\n.top-nav {\n  display: flex;\n  flex-wrap: wrap;\n  gap: 0.6rem;\n  justify-content: center;\n}\n\n.top-nav-btn {\n  position: relative;\n  border: 1px solid rgba(180, 83, 9, 0.4);\n  background: linear-gradient(135deg, rgba(22, 12, 10, 0.85), rgba(14, 8, 6, 0.9));\n  color: rgba(240, 220, 190, 0.85);\n  border-radius: 0.6rem;\n  font-size: 0.82rem;\n  padding: 0.4rem 1.1rem;\n  letter-spacing: 0.15em;\n  transition: all 0.3s ease;\n  cursor: pointer;\n  overflow: hidden;\n}\n\n.top-nav-btn::before {\n  content: '';\n  position: absolute;\n  inset: 0;\n  background: linear-gradient(135deg, transparent 40%, rgba(212, 175, 55, 0.06));\n  opacity: 0;\n  transition: opacity 0.3s;\n}\n\n.top-nav-btn:hover::before {\n  opacity: 1;\n}\n\n.top-nav-btn:hover {\n  border-color: rgba(212, 175, 55, 0.55);\n  color: rgba(255, 248, 220, 0.95);\n  box-shadow: 0 0 14px rgba(212, 175, 55, 0.15);\n}\n\n.top-nav-btn.active {\n  border-color: rgba(212, 175, 55, 0.75);\n  background: linear-gradient(135deg, rgba(60, 20, 18, 0.85), rgba(40, 14, 12, 0.9));\n  color: rgba(255, 248, 220, 0.98);\n  box-shadow: 0 0 18px rgba(212, 175, 55, 0.3), 0 0 6px rgba(160, 50, 50, 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.06);\n}\n\n.top-nav-btn-text {\n  position: relative;\n  z-index: 1;\n}\n\n/* ── Shared button styles ── */\n.side-btn,\n.bookmark {\n  border: 1px solid rgba(180, 83, 9, 0.3);\n  background: rgba(14, 8, 6, 0.5);\n  color: rgba(240, 220, 190, 0.8);\n  border-radius: 0.5rem;\n  transition: all 0.25s ease;\n  cursor: pointer;\n}\n\n.side-btn:hover,\n.bookmark:hover:not(:disabled) {\n  border-color: rgba(212, 175, 55, 0.5);\n  color: rgba(255, 248, 220, 0.95);\n  background: rgba(60, 20, 18, 0.4);\n}\n\n.side-btn.active {\n  border-color: rgba(212, 175, 55, 0.75);\n  background: linear-gradient(135deg, rgba(100, 30, 25, 0.35), rgba(60, 20, 18, 0.5));\n  color: rgba(255, 248, 220, 0.98);\n  box-shadow: 0 0 10px rgba(212, 175, 55, 0.2), inset 0 0 8px rgba(160, 50, 50, 0.08);\n}\n\n/* ── Book Layout ── */\n.book-layout {\n  display: grid;\n  grid-template-columns: 200px 1fr;\n  gap: 0.85rem;\n  min-height: 68vh;\n}\n\n/* ── Side Navigation ── */\n.side-nav {\n  border: 1px solid rgba(180, 83, 9, 0.28);\n  border-radius: 1rem;\n  background: linear-gradient(170deg, rgba(30, 16, 14, 0.88), rgba(16, 8, 7, 0.92));\n  padding: 0.75rem;\n  display: flex;\n  flex-direction: column;\n  gap: 0.35rem;\n  position: relative;\n  overflow-y: auto;\n  max-height: 72vh;\n}\n\n.side-nav::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 60%;\n  background: radial-gradient(ellipse at 50% -20%, rgba(212, 175, 55, 0.06), transparent 70%);\n  pointer-events: none;\n  border-radius: 1rem 1rem 0 0;\n}\n\n.side-title {\n  color: rgba(212, 175, 55, 0.95);\n  font-size: 0.72rem;\n  letter-spacing: 0.18em;\n  text-transform: uppercase;\n  font-weight: 600;\n  padding: 0.15rem 0.3rem;\n  position: relative;\n  z-index: 1;\n}\n\n.side-divider {\n  height: 1px;\n  background: linear-gradient(90deg, transparent, rgba(180, 83, 9, 0.35), rgba(212, 175, 55, 0.2), transparent);\n  margin: 0.15rem 0;\n}\n\n.side-btn {\n  font-size: 0.82rem;\n  text-align: left;\n  padding: 0.42rem 0.65rem;\n  position: relative;\n  z-index: 1;\n}\n\n.side-btn-area {\n  font-size: 0.72rem;\n  padding-left: 0.8rem;\n}\n\n/* ── Book Shell & Page ── */\n.book-shell {\n  border: 1px solid rgba(180, 83, 9, 0.28);\n  border-radius: 1rem;\n  background: linear-gradient(170deg, rgba(26, 14, 12, 0.7), rgba(14, 8, 6, 0.85));\n  padding: 0.75rem;\n  position: relative;\n}\n\n.book-shell::before {\n  content: '';\n  position: absolute;\n  top: 0;\n  left: 0;\n  right: 0;\n  height: 45%;\n  background: radial-gradient(ellipse at 30% -10%, rgba(212, 175, 55, 0.05), transparent 60%);\n  pointer-events: none;\n  border-radius: 1rem 1rem 0 0;\n}\n\n.book-page {\n  border: 1px solid rgba(180, 83, 9, 0.2);\n  border-radius: 0.85rem;\n  background:\n    radial-gradient(circle at 15% 5%, rgba(160, 50, 50, 0.08), transparent 35%),\n    radial-gradient(circle at 85% 95%, rgba(212, 175, 55, 0.05), transparent 35%),\n    rgba(12, 7, 6, 0.75);\n  padding: 0.85rem 0.85rem 3.6rem;\n  min-height: 62vh;\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\n\n/* ── Content Grids ── */\n.card-grid {\n  display: grid;\n  grid-template-columns: repeat(3, minmax(0, 1fr));\n  gap: 1rem;\n  justify-items: center;\n  flex: 1;\n  align-content: start;\n}\n\n.entry-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(265px, 1fr));\n  gap: 0.65rem;\n  flex: 1;\n  align-content: start;\n}\n\n.enemy-grid {\n  display: grid;\n  grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));\n  gap: 0.7rem;\n  flex: 1;\n  align-content: start;\n}\n\n/* ── Entry Cards ── */\n.entry-card {\n  border: 1px solid rgba(180, 83, 9, 0.28);\n  border-left: 2px solid rgba(212, 175, 55, 0.4);\n  border-radius: 0.6rem;\n  background: linear-gradient(135deg, rgba(24, 12, 10, 0.65), rgba(14, 8, 6, 0.75));\n  padding: 0.6rem 0.65rem;\n  backdrop-filter: blur(4px);\n  transition: all 0.3s ease;\n}\n\n.entry-card:hover {\n  border-color: rgba(212, 175, 55, 0.4);\n  border-left-color: rgba(212, 175, 55, 0.65);\n  box-shadow: 0 0 16px rgba(160, 50, 50, 0.08), 0 2px 8px rgba(0, 0, 0, 0.3);\n  transform: translateY(-1px);\n}\n\n.entry-title {\n  color: rgba(255, 248, 220, 0.95);\n  font-size: 0.88rem;\n  line-height: 1.15rem;\n  font-weight: 500;\n}\n\n.entry-meta {\n  margin-top: 0.18rem;\n  color: rgba(212, 175, 55, 0.8);\n  font-size: 0.72rem;\n  line-height: 1rem;\n  letter-spacing: 0.04em;\n}\n\n.entry-desc {\n  margin-top: 0.25rem;\n  color: rgba(240, 220, 190, 0.68);\n  font-size: 0.75rem;\n  line-height: 1.05rem;\n}\n\n/* ── Effect Row ── */\n.effect-row {\n  display: flex;\n  align-items: center;\n  gap: 0.42rem;\n}\n\n.effect-icon {\n  width: 1.3rem;\n  display: inline-flex;\n  justify-content: center;\n  font-size: 1rem;\n}\n\n/* ── Enemy Card ── */\n.enemy-head {\n  display: flex;\n  align-items: center;\n  gap: 0.55rem;\n  margin-bottom: 0.2rem;\n}\n\n.portrait {\n  width: 3.2rem;\n  height: 3.2rem;\n  border-radius: 0.55rem;\n  border: 1px solid rgba(212, 175, 55, 0.4);\n  overflow: hidden;\n  background: rgba(12, 7, 6, 0.6);\n  flex-shrink: 0;\n  box-shadow: 0 0 8px rgba(160, 50, 50, 0.12);\n  transition: all 0.3s ease;\n}\n\n.enemy-card:hover .portrait {\n  border-color: rgba(212, 175, 55, 0.7);\n  box-shadow: 0 0 14px rgba(212, 175, 55, 0.25);\n}\n\n.portrait-img {\n  width: 100%;\n  height: 100%;\n  object-fit: cover;\n  object-position: top;\n}\n\n.portrait-fallback {\n  width: 100%;\n  height: 100%;\n  display: inline-flex;\n  align-items: center;\n  justify-content: center;\n  color: rgba(212, 175, 55, 0.7);\n  font-size: 1.1rem;\n  font-weight: bold;\n}\n\n.enemy-head-text {\n  min-width: 0;\n}\n\n/* ── Page Footer ── */\n.page-foot {\n  position: absolute;\n  left: 0.85rem;\n  right: 0.85rem;\n  bottom: 0.7rem;\n  display: flex;\n  align-items: flex-end;\n  justify-content: space-between;\n}\n\n.bookmark {\n  padding: 0.4rem 0.8rem;\n  border-radius: 0.5rem 0.5rem 0.2rem 0.2rem;\n  font-size: 0.76rem;\n  letter-spacing: 0.05em;\n}\n\n.bookmark:disabled {\n  opacity: 0.3;\n  cursor: not-allowed;\n}\n\n.bookmark-next {\n  background: linear-gradient(180deg, rgba(120, 40, 35, 0.4), rgba(80, 25, 20, 0.6));\n  border-color: rgba(180, 83, 9, 0.4);\n}\n\n.bookmark-next:hover:not(:disabled) {\n  background: linear-gradient(180deg, rgba(140, 50, 40, 0.5), rgba(100, 35, 28, 0.7));\n  box-shadow: 0 0 12px rgba(212, 175, 55, 0.2);\n}\n\n.page-indicator {\n  color: rgba(212, 175, 55, 0.88);\n  font-size: 0.78rem;\n  letter-spacing: 0.08em;\n}\n\n/* ── Page Flip Animation ── */\n.flip-next-enter-active,\n.flip-next-leave-active,\n.flip-prev-enter-active,\n.flip-prev-leave-active {\n  transition: transform 0.35s ease, opacity 0.35s ease;\n}\n\n.flip-next-enter-from {\n  opacity: 0;\n  transform: perspective(1200px) rotateY(-10deg) translateX(14px);\n}\n\n.flip-next-leave-to {\n  opacity: 0;\n  transform: perspective(1200px) rotateY(8deg) translateX(-12px);\n}\n\n.flip-prev-enter-from {\n  opacity: 0;\n  transform: perspective(1200px) rotateY(10deg) translateX(-14px);\n}\n\n.flip-prev-leave-to {\n  opacity: 0;\n  transform: perspective(1200px) rotateY(-8deg) translateX(12px);\n}\n\n/* ── Responsive ── */\n@media (max-width: 980px) {\n  .book-layout {\n    grid-template-columns: 1fr;\n  }\n\n  .side-nav {\n    flex-direction: row;\n    flex-wrap: wrap;\n    align-items: center;\n    max-height: none;\n  }\n\n  .side-title {\n    width: 100%;\n  }\n\n  .side-divider {\n    width: 100%;\n    margin: 0.1rem 0;\n  }\n\n  .card-grid {\n    grid-template-columns: repeat(2, minmax(0, 1fr));\n  }\n}\n</style>\n","<template>\n  <div class=\"w-full relative\">\n    <!-- Splash Screen -->\n    <Transition name=\"scene-fade\" mode=\"out-in\">\n      <SplashScreen\n        v-if=\"appState === 'SPLASH'\"\n        key=\"splash\"\n        @start=\"startGame\"\n        @toggle-fullscreen=\"toggleFullScreen\"\n        @open-collection=\"isCollectionOpen = true\"\n      />\n\n      <!-- Game -->\n      <GameView\n        v-else\n        key=\"game\"\n        @back-to-splash=\"appState = 'SPLASH'\"\n      />\n    </Transition>\n    <WitchCollectionModal\n      :is-open=\"isCollectionOpen\"\n      @close=\"isCollectionOpen = false\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport GameView from './components/GameView.vue';\nimport SplashScreen from './components/SplashScreen.vue';\nimport WitchCollectionModal from './components/WitchCollectionModal.vue';\nimport { disposeBgm, initializeBgm } from './bgm';\nimport { toggleFullScreen } from './fullscreen';\nimport { useGameStore } from './gameStore';\n\nconst appState = ref<'SPLASH' | 'GAME'>('SPLASH');\nconst isCollectionOpen = ref(false);\nconst gameStore = useGameStore();\n\nonMounted(() => {\n  void initializeBgm();\n});\n\nonUnmounted(() => {\n  disposeBgm();\n});\n\n/**\n * 开始游戏：初始化 gameStore（加载最新楼层状态、MVU）\n */\nasync function startGame() {\n  appState.value = 'GAME';\n  await nextTick();\n  await gameStore.initialize();\n}\n</script>\n\n<style scoped>\n/* Scene transition: fade + subtle scale */\n.scene-fade-enter-active {\n  transition: opacity 0.8s ease, transform 0.8s ease;\n}\n.scene-fade-leave-active {\n  transition: opacity 0.5s ease, transform 0.5s ease;\n}\n.scene-fade-enter-from {\n  opacity: 0;\n  transform: scale(1.02);\n}\n.scene-fade-leave-to {\n  opacity: 0;\n  transform: scale(0.98);\n}\n</style>\n",null,"@layer theme, base, components, utilities;\n\n@layer theme {\n  @theme default {\n    --font-sans:\n      ui-sans-serif, system-ui, sans-serif, \"Apple Color Emoji\",\n      \"Segoe UI Emoji\", \"Segoe UI Symbol\", \"Noto Color Emoji\";\n    --font-serif: ui-serif, Georgia, Cambria, \"Times New Roman\", Times, serif;\n    --font-mono:\n      ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \"Liberation Mono\",\n      \"Courier New\", monospace;\n\n    --color-red-50: oklch(97.1% 0.013 17.38);\n    --color-red-100: oklch(93.6% 0.032 17.717);\n    --color-red-200: oklch(88.5% 0.062 18.334);\n    --color-red-300: oklch(80.8% 0.114 19.571);\n    --color-red-400: oklch(70.4% 0.191 22.216);\n    --color-red-500: oklch(63.7% 0.237 25.331);\n    --color-red-600: oklch(57.7% 0.245 27.325);\n    --color-red-700: oklch(50.5% 0.213 27.518);\n    --color-red-800: oklch(44.4% 0.177 26.899);\n    --color-red-900: oklch(39.6% 0.141 25.723);\n    --color-red-950: oklch(25.8% 0.092 26.042);\n\n    --color-orange-50: oklch(98% 0.016 73.684);\n    --color-orange-100: oklch(95.4% 0.038 75.164);\n    --color-orange-200: oklch(90.1% 0.076 70.697);\n    --color-orange-300: oklch(83.7% 0.128 66.29);\n    --color-orange-400: oklch(75% 0.183 55.934);\n    --color-orange-500: oklch(70.5% 0.213 47.604);\n    --color-orange-600: oklch(64.6% 0.222 41.116);\n    --color-orange-700: oklch(55.3% 0.195 38.402);\n    --color-orange-800: oklch(47% 0.157 37.304);\n    --color-orange-900: oklch(40.8% 0.123 38.172);\n    --color-orange-950: oklch(26.6% 0.079 36.259);\n\n    --color-amber-50: oklch(98.7% 0.022 95.277);\n    --color-amber-100: oklch(96.2% 0.059 95.617);\n    --color-amber-200: oklch(92.4% 0.12 95.746);\n    --color-amber-300: oklch(87.9% 0.169 91.605);\n    --color-amber-400: oklch(82.8% 0.189 84.429);\n    --color-amber-500: oklch(76.9% 0.188 70.08);\n    --color-amber-600: oklch(66.6% 0.179 58.318);\n    --color-amber-700: oklch(55.5% 0.163 48.998);\n    --color-amber-800: oklch(47.3% 0.137 46.201);\n    --color-amber-900: oklch(41.4% 0.112 45.904);\n    --color-amber-950: oklch(27.9% 0.077 45.635);\n\n    --color-yellow-50: oklch(98.7% 0.026 102.212);\n    --color-yellow-100: oklch(97.3% 0.071 103.193);\n    --color-yellow-200: oklch(94.5% 0.129 101.54);\n    --color-yellow-300: oklch(90.5% 0.182 98.111);\n    --color-yellow-400: oklch(85.2% 0.199 91.936);\n    --color-yellow-500: oklch(79.5% 0.184 86.047);\n    --color-yellow-600: oklch(68.1% 0.162 75.834);\n    --color-yellow-700: oklch(55.4% 0.135 66.442);\n    --color-yellow-800: oklch(47.6% 0.114 61.907);\n    --color-yellow-900: oklch(42.1% 0.095 57.708);\n    --color-yellow-950: oklch(28.6% 0.066 53.813);\n\n    --color-lime-50: oklch(98.6% 0.031 120.757);\n    --color-lime-100: oklch(96.7% 0.067 122.328);\n    --color-lime-200: oklch(93.8% 0.127 124.321);\n    --color-lime-300: oklch(89.7% 0.196 126.665);\n    --color-lime-400: oklch(84.1% 0.238 128.85);\n    --color-lime-500: oklch(76.8% 0.233 130.85);\n    --color-lime-600: oklch(64.8% 0.2 131.684);\n    --color-lime-700: oklch(53.2% 0.157 131.589);\n    --color-lime-800: oklch(45.3% 0.124 130.933);\n    --color-lime-900: oklch(40.5% 0.101 131.063);\n    --color-lime-950: oklch(27.4% 0.072 132.109);\n\n    --color-green-50: oklch(98.2% 0.018 155.826);\n    --color-green-100: oklch(96.2% 0.044 156.743);\n    --color-green-200: oklch(92.5% 0.084 155.995);\n    --color-green-300: oklch(87.1% 0.15 154.449);\n    --color-green-400: oklch(79.2% 0.209 151.711);\n    --color-green-500: oklch(72.3% 0.219 149.579);\n    --color-green-600: oklch(62.7% 0.194 149.214);\n    --color-green-700: oklch(52.7% 0.154 150.069);\n    --color-green-800: oklch(44.8% 0.119 151.328);\n    --color-green-900: oklch(39.3% 0.095 152.535);\n    --color-green-950: oklch(26.6% 0.065 152.934);\n\n    --color-emerald-50: oklch(97.9% 0.021 166.113);\n    --color-emerald-100: oklch(95% 0.052 163.051);\n    --color-emerald-200: oklch(90.5% 0.093 164.15);\n    --color-emerald-300: oklch(84.5% 0.143 164.978);\n    --color-emerald-400: oklch(76.5% 0.177 163.223);\n    --color-emerald-500: oklch(69.6% 0.17 162.48);\n    --color-emerald-600: oklch(59.6% 0.145 163.225);\n    --color-emerald-700: oklch(50.8% 0.118 165.612);\n    --color-emerald-800: oklch(43.2% 0.095 166.913);\n    --color-emerald-900: oklch(37.8% 0.077 168.94);\n    --color-emerald-950: oklch(26.2% 0.051 172.552);\n\n    --color-teal-50: oklch(98.4% 0.014 180.72);\n    --color-teal-100: oklch(95.3% 0.051 180.801);\n    --color-teal-200: oklch(91% 0.096 180.426);\n    --color-teal-300: oklch(85.5% 0.138 181.071);\n    --color-teal-400: oklch(77.7% 0.152 181.912);\n    --color-teal-500: oklch(70.4% 0.14 182.503);\n    --color-teal-600: oklch(60% 0.118 184.704);\n    --color-teal-700: oklch(51.1% 0.096 186.391);\n    --color-teal-800: oklch(43.7% 0.078 188.216);\n    --color-teal-900: oklch(38.6% 0.063 188.416);\n    --color-teal-950: oklch(27.7% 0.046 192.524);\n\n    --color-cyan-50: oklch(98.4% 0.019 200.873);\n    --color-cyan-100: oklch(95.6% 0.045 203.388);\n    --color-cyan-200: oklch(91.7% 0.08 205.041);\n    --color-cyan-300: oklch(86.5% 0.127 207.078);\n    --color-cyan-400: oklch(78.9% 0.154 211.53);\n    --color-cyan-500: oklch(71.5% 0.143 215.221);\n    --color-cyan-600: oklch(60.9% 0.126 221.723);\n    --color-cyan-700: oklch(52% 0.105 223.128);\n    --color-cyan-800: oklch(45% 0.085 224.283);\n    --color-cyan-900: oklch(39.8% 0.07 227.392);\n    --color-cyan-950: oklch(30.2% 0.056 229.695);\n\n    --color-sky-50: oklch(97.7% 0.013 236.62);\n    --color-sky-100: oklch(95.1% 0.026 236.824);\n    --color-sky-200: oklch(90.1% 0.058 230.902);\n    --color-sky-300: oklch(82.8% 0.111 230.318);\n    --color-sky-400: oklch(74.6% 0.16 232.661);\n    --color-sky-500: oklch(68.5% 0.169 237.323);\n    --color-sky-600: oklch(58.8% 0.158 241.966);\n    --color-sky-700: oklch(50% 0.134 242.749);\n    --color-sky-800: oklch(44.3% 0.11 240.79);\n    --color-sky-900: oklch(39.1% 0.09 240.876);\n    --color-sky-950: oklch(29.3% 0.066 243.157);\n\n    --color-blue-50: oklch(97% 0.014 254.604);\n    --color-blue-100: oklch(93.2% 0.032 255.585);\n    --color-blue-200: oklch(88.2% 0.059 254.128);\n    --color-blue-300: oklch(80.9% 0.105 251.813);\n    --color-blue-400: oklch(70.7% 0.165 254.624);\n    --color-blue-500: oklch(62.3% 0.214 259.815);\n    --color-blue-600: oklch(54.6% 0.245 262.881);\n    --color-blue-700: oklch(48.8% 0.243 264.376);\n    --color-blue-800: oklch(42.4% 0.199 265.638);\n    --color-blue-900: oklch(37.9% 0.146 265.522);\n    --color-blue-950: oklch(28.2% 0.091 267.935);\n\n    --color-indigo-50: oklch(96.2% 0.018 272.314);\n    --color-indigo-100: oklch(93% 0.034 272.788);\n    --color-indigo-200: oklch(87% 0.065 274.039);\n    --color-indigo-300: oklch(78.5% 0.115 274.713);\n    --color-indigo-400: oklch(67.3% 0.182 276.935);\n    --color-indigo-500: oklch(58.5% 0.233 277.117);\n    --color-indigo-600: oklch(51.1% 0.262 276.966);\n    --color-indigo-700: oklch(45.7% 0.24 277.023);\n    --color-indigo-800: oklch(39.8% 0.195 277.366);\n    --color-indigo-900: oklch(35.9% 0.144 278.697);\n    --color-indigo-950: oklch(25.7% 0.09 281.288);\n\n    --color-violet-50: oklch(96.9% 0.016 293.756);\n    --color-violet-100: oklch(94.3% 0.029 294.588);\n    --color-violet-200: oklch(89.4% 0.057 293.283);\n    --color-violet-300: oklch(81.1% 0.111 293.571);\n    --color-violet-400: oklch(70.2% 0.183 293.541);\n    --color-violet-500: oklch(60.6% 0.25 292.717);\n    --color-violet-600: oklch(54.1% 0.281 293.009);\n    --color-violet-700: oklch(49.1% 0.27 292.581);\n    --color-violet-800: oklch(43.2% 0.232 292.759);\n    --color-violet-900: oklch(38% 0.189 293.745);\n    --color-violet-950: oklch(28.3% 0.141 291.089);\n\n    --color-purple-50: oklch(97.7% 0.014 308.299);\n    --color-purple-100: oklch(94.6% 0.033 307.174);\n    --color-purple-200: oklch(90.2% 0.063 306.703);\n    --color-purple-300: oklch(82.7% 0.119 306.383);\n    --color-purple-400: oklch(71.4% 0.203 305.504);\n    --color-purple-500: oklch(62.7% 0.265 303.9);\n    --color-purple-600: oklch(55.8% 0.288 302.321);\n    --color-purple-700: oklch(49.6% 0.265 301.924);\n    --color-purple-800: oklch(43.8% 0.218 303.724);\n    --color-purple-900: oklch(38.1% 0.176 304.987);\n    --color-purple-950: oklch(29.1% 0.149 302.717);\n\n    --color-fuchsia-50: oklch(97.7% 0.017 320.058);\n    --color-fuchsia-100: oklch(95.2% 0.037 318.852);\n    --color-fuchsia-200: oklch(90.3% 0.076 319.62);\n    --color-fuchsia-300: oklch(83.3% 0.145 321.434);\n    --color-fuchsia-400: oklch(74% 0.238 322.16);\n    --color-fuchsia-500: oklch(66.7% 0.295 322.15);\n    --color-fuchsia-600: oklch(59.1% 0.293 322.896);\n    --color-fuchsia-700: oklch(51.8% 0.253 323.949);\n    --color-fuchsia-800: oklch(45.2% 0.211 324.591);\n    --color-fuchsia-900: oklch(40.1% 0.17 325.612);\n    --color-fuchsia-950: oklch(29.3% 0.136 325.661);\n\n    --color-pink-50: oklch(97.1% 0.014 343.198);\n    --color-pink-100: oklch(94.8% 0.028 342.258);\n    --color-pink-200: oklch(89.9% 0.061 343.231);\n    --color-pink-300: oklch(82.3% 0.12 346.018);\n    --color-pink-400: oklch(71.8% 0.202 349.761);\n    --color-pink-500: oklch(65.6% 0.241 354.308);\n    --color-pink-600: oklch(59.2% 0.249 0.584);\n    --color-pink-700: oklch(52.5% 0.223 3.958);\n    --color-pink-800: oklch(45.9% 0.187 3.815);\n    --color-pink-900: oklch(40.8% 0.153 2.432);\n    --color-pink-950: oklch(28.4% 0.109 3.907);\n\n    --color-rose-50: oklch(96.9% 0.015 12.422);\n    --color-rose-100: oklch(94.1% 0.03 12.58);\n    --color-rose-200: oklch(89.2% 0.058 10.001);\n    --color-rose-300: oklch(81% 0.117 11.638);\n    --color-rose-400: oklch(71.2% 0.194 13.428);\n    --color-rose-500: oklch(64.5% 0.246 16.439);\n    --color-rose-600: oklch(58.6% 0.253 17.585);\n    --color-rose-700: oklch(51.4% 0.222 16.935);\n    --color-rose-800: oklch(45.5% 0.188 13.697);\n    --color-rose-900: oklch(41% 0.159 10.272);\n    --color-rose-950: oklch(27.1% 0.105 12.094);\n\n    --color-slate-50: oklch(98.4% 0.003 247.858);\n    --color-slate-100: oklch(96.8% 0.007 247.896);\n    --color-slate-200: oklch(92.9% 0.013 255.508);\n    --color-slate-300: oklch(86.9% 0.022 252.894);\n    --color-slate-400: oklch(70.4% 0.04 256.788);\n    --color-slate-500: oklch(55.4% 0.046 257.417);\n    --color-slate-600: oklch(44.6% 0.043 257.281);\n    --color-slate-700: oklch(37.2% 0.044 257.287);\n    --color-slate-800: oklch(27.9% 0.041 260.031);\n    --color-slate-900: oklch(20.8% 0.042 265.755);\n    --color-slate-950: oklch(12.9% 0.042 264.695);\n\n    --color-gray-50: oklch(98.5% 0.002 247.839);\n    --color-gray-100: oklch(96.7% 0.003 264.542);\n    --color-gray-200: oklch(92.8% 0.006 264.531);\n    --color-gray-300: oklch(87.2% 0.01 258.338);\n    --color-gray-400: oklch(70.7% 0.022 261.325);\n    --color-gray-500: oklch(55.1% 0.027 264.364);\n    --color-gray-600: oklch(44.6% 0.03 256.802);\n    --color-gray-700: oklch(37.3% 0.034 259.733);\n    --color-gray-800: oklch(27.8% 0.033 256.848);\n    --color-gray-900: oklch(21% 0.034 264.665);\n    --color-gray-950: oklch(13% 0.028 261.692);\n\n    --color-zinc-50: oklch(98.5% 0 0);\n    --color-zinc-100: oklch(96.7% 0.001 286.375);\n    --color-zinc-200: oklch(92% 0.004 286.32);\n    --color-zinc-300: oklch(87.1% 0.006 286.286);\n    --color-zinc-400: oklch(70.5% 0.015 286.067);\n    --color-zinc-500: oklch(55.2% 0.016 285.938);\n    --color-zinc-600: oklch(44.2% 0.017 285.786);\n    --color-zinc-700: oklch(37% 0.013 285.805);\n    --color-zinc-800: oklch(27.4% 0.006 286.033);\n    --color-zinc-900: oklch(21% 0.006 285.885);\n    --color-zinc-950: oklch(14.1% 0.005 285.823);\n\n    --color-neutral-50: oklch(98.5% 0 0);\n    --color-neutral-100: oklch(97% 0 0);\n    --color-neutral-200: oklch(92.2% 0 0);\n    --color-neutral-300: oklch(87% 0 0);\n    --color-neutral-400: oklch(70.8% 0 0);\n    --color-neutral-500: oklch(55.6% 0 0);\n    --color-neutral-600: oklch(43.9% 0 0);\n    --color-neutral-700: oklch(37.1% 0 0);\n    --color-neutral-800: oklch(26.9% 0 0);\n    --color-neutral-900: oklch(20.5% 0 0);\n    --color-neutral-950: oklch(14.5% 0 0);\n\n    --color-stone-50: oklch(98.5% 0.001 106.423);\n    --color-stone-100: oklch(97% 0.001 106.424);\n    --color-stone-200: oklch(92.3% 0.003 48.717);\n    --color-stone-300: oklch(86.9% 0.005 56.366);\n    --color-stone-400: oklch(70.9% 0.01 56.259);\n    --color-stone-500: oklch(55.3% 0.013 58.071);\n    --color-stone-600: oklch(44.4% 0.011 73.639);\n    --color-stone-700: oklch(37.4% 0.01 67.558);\n    --color-stone-800: oklch(26.8% 0.007 34.298);\n    --color-stone-900: oklch(21.6% 0.006 56.043);\n    --color-stone-950: oklch(14.7% 0.004 49.25);\n\n    --color-mauve-50: oklch(98.5% 0 0);\n    --color-mauve-100: oklch(96% 0.003 325.6);\n    --color-mauve-200: oklch(92.2% 0.005 325.62);\n    --color-mauve-300: oklch(86.5% 0.012 325.68);\n    --color-mauve-400: oklch(71.1% 0.019 323.02);\n    --color-mauve-500: oklch(54.2% 0.034 322.5);\n    --color-mauve-600: oklch(43.5% 0.029 321.78);\n    --color-mauve-700: oklch(36.4% 0.029 323.89);\n    --color-mauve-800: oklch(26.3% 0.024 320.12);\n    --color-mauve-900: oklch(21.2% 0.019 322.12);\n    --color-mauve-950: oklch(14.5% 0.008 326);\n\n    --color-olive-50: oklch(98.8% 0.003 106.5);\n    --color-olive-100: oklch(96.6% 0.005 106.5);\n    --color-olive-200: oklch(93% 0.007 106.5);\n    --color-olive-300: oklch(88% 0.011 106.6);\n    --color-olive-400: oklch(73.7% 0.021 106.9);\n    --color-olive-500: oklch(58% 0.031 107.3);\n    --color-olive-600: oklch(46.6% 0.025 107.3);\n    --color-olive-700: oklch(39.4% 0.023 107.4);\n    --color-olive-800: oklch(28.6% 0.016 107.4);\n    --color-olive-900: oklch(22.8% 0.013 107.4);\n    --color-olive-950: oklch(15.3% 0.006 107.1);\n\n    --color-mist-50: oklch(98.7% 0.002 197.1);\n    --color-mist-100: oklch(96.3% 0.002 197.1);\n    --color-mist-200: oklch(92.5% 0.005 214.3);\n    --color-mist-300: oklch(87.2% 0.007 219.6);\n    --color-mist-400: oklch(72.3% 0.014 214.4);\n    --color-mist-500: oklch(56% 0.021 213.5);\n    --color-mist-600: oklch(45% 0.017 213.2);\n    --color-mist-700: oklch(37.8% 0.015 216);\n    --color-mist-800: oklch(27.5% 0.011 216.9);\n    --color-mist-900: oklch(21.8% 0.008 223.9);\n    --color-mist-950: oklch(14.8% 0.004 228.8);\n\n    --color-taupe-50: oklch(98.6% 0.002 67.8);\n    --color-taupe-100: oklch(96% 0.002 17.2);\n    --color-taupe-200: oklch(92.2% 0.005 34.3);\n    --color-taupe-300: oklch(86.8% 0.007 39.5);\n    --color-taupe-400: oklch(71.4% 0.014 41.2);\n    --color-taupe-500: oklch(54.7% 0.021 43.1);\n    --color-taupe-600: oklch(43.8% 0.017 39.3);\n    --color-taupe-700: oklch(36.7% 0.016 35.7);\n    --color-taupe-800: oklch(26.8% 0.011 36.5);\n    --color-taupe-900: oklch(21.4% 0.009 43.1);\n    --color-taupe-950: oklch(14.7% 0.004 49.3);\n\n    --color-black: #000;\n    --color-white: #fff;\n\n    --spacing: 0.25rem;\n\n    --breakpoint-sm: 40rem;\n    --breakpoint-md: 48rem;\n    --breakpoint-lg: 64rem;\n    --breakpoint-xl: 80rem;\n    --breakpoint-2xl: 96rem;\n\n    --container-3xs: 16rem;\n    --container-2xs: 18rem;\n    --container-xs: 20rem;\n    --container-sm: 24rem;\n    --container-md: 28rem;\n    --container-lg: 32rem;\n    --container-xl: 36rem;\n    --container-2xl: 42rem;\n    --container-3xl: 48rem;\n    --container-4xl: 56rem;\n    --container-5xl: 64rem;\n    --container-6xl: 72rem;\n    --container-7xl: 80rem;\n\n    --text-xs: 0.75rem;\n    --text-xs--line-height: calc(1 / 0.75);\n    --text-sm: 0.875rem;\n    --text-sm--line-height: calc(1.25 / 0.875);\n    --text-base: 1rem;\n    --text-base--line-height: calc(1.5 / 1);\n    --text-lg: 1.125rem;\n    --text-lg--line-height: calc(1.75 / 1.125);\n    --text-xl: 1.25rem;\n    --text-xl--line-height: calc(1.75 / 1.25);\n    --text-2xl: 1.5rem;\n    --text-2xl--line-height: calc(2 / 1.5);\n    --text-3xl: 1.875rem;\n    --text-3xl--line-height: calc(2.25 / 1.875);\n    --text-4xl: 2.25rem;\n    --text-4xl--line-height: calc(2.5 / 2.25);\n    --text-5xl: 3rem;\n    --text-5xl--line-height: 1;\n    --text-6xl: 3.75rem;\n    --text-6xl--line-height: 1;\n    --text-7xl: 4.5rem;\n    --text-7xl--line-height: 1;\n    --text-8xl: 6rem;\n    --text-8xl--line-height: 1;\n    --text-9xl: 8rem;\n    --text-9xl--line-height: 1;\n\n    --font-weight-thin: 100;\n    --font-weight-extralight: 200;\n    --font-weight-light: 300;\n    --font-weight-normal: 400;\n    --font-weight-medium: 500;\n    --font-weight-semibold: 600;\n    --font-weight-bold: 700;\n    --font-weight-extrabold: 800;\n    --font-weight-black: 900;\n\n    --tracking-tighter: -0.05em;\n    --tracking-tight: -0.025em;\n    --tracking-normal: 0em;\n    --tracking-wide: 0.025em;\n    --tracking-wider: 0.05em;\n    --tracking-widest: 0.1em;\n\n    --leading-tight: 1.25;\n    --leading-snug: 1.375;\n    --leading-normal: 1.5;\n    --leading-relaxed: 1.625;\n    --leading-loose: 2;\n\n    --radius-xs: 0.125rem;\n    --radius-sm: 0.25rem;\n    --radius-md: 0.375rem;\n    --radius-lg: 0.5rem;\n    --radius-xl: 0.75rem;\n    --radius-2xl: 1rem;\n    --radius-3xl: 1.5rem;\n    --radius-4xl: 2rem;\n\n    --shadow-2xs: 0 1px rgb(0 0 0 / 0.05);\n    --shadow-xs: 0 1px 2px 0 rgb(0 0 0 / 0.05);\n    --shadow-sm: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n    --shadow-md:\n      0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);\n    --shadow-lg:\n      0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);\n    --shadow-xl:\n      0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1);\n    --shadow-2xl: 0 25px 50px -12px rgb(0 0 0 / 0.25);\n\n    --inset-shadow-2xs: inset 0 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-xs: inset 0 1px 1px rgb(0 0 0 / 0.05);\n    --inset-shadow-sm: inset 0 2px 4px rgb(0 0 0 / 0.05);\n\n    --drop-shadow-xs: 0 1px 1px rgb(0 0 0 / 0.05);\n    --drop-shadow-sm: 0 1px 2px rgb(0 0 0 / 0.15);\n    --drop-shadow-md: 0 3px 3px rgb(0 0 0 / 0.12);\n    --drop-shadow-lg: 0 4px 4px rgb(0 0 0 / 0.15);\n    --drop-shadow-xl: 0 9px 7px rgb(0 0 0 / 0.1);\n    --drop-shadow-2xl: 0 25px 25px rgb(0 0 0 / 0.15);\n\n    --text-shadow-2xs: 0px 1px 0px rgb(0 0 0 / 0.15);\n    --text-shadow-xs: 0px 1px 1px rgb(0 0 0 / 0.2);\n    --text-shadow-sm:\n      0px 1px 0px rgb(0 0 0 / 0.075), 0px 1px 1px rgb(0 0 0 / 0.075),\n      0px 2px 2px rgb(0 0 0 / 0.075);\n    --text-shadow-md:\n      0px 1px 1px rgb(0 0 0 / 0.1), 0px 1px 2px rgb(0 0 0 / 0.1),\n      0px 2px 4px rgb(0 0 0 / 0.1);\n    --text-shadow-lg:\n      0px 1px 2px rgb(0 0 0 / 0.1), 0px 3px 2px rgb(0 0 0 / 0.1),\n      0px 4px 8px rgb(0 0 0 / 0.1);\n\n    --ease-in: cubic-bezier(0.4, 0, 1, 1);\n    --ease-out: cubic-bezier(0, 0, 0.2, 1);\n    --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);\n\n    --animate-spin: spin 1s linear infinite;\n    --animate-ping: ping 1s cubic-bezier(0, 0, 0.2, 1) infinite;\n    --animate-pulse: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n    --animate-bounce: bounce 1s infinite;\n\n    @keyframes spin {\n      to {\n        transform: rotate(360deg);\n      }\n    }\n\n    @keyframes ping {\n      75%,\n      100% {\n        transform: scale(2);\n        opacity: 0;\n      }\n    }\n\n    @keyframes pulse {\n      50% {\n        opacity: 0.5;\n      }\n    }\n\n    @keyframes bounce {\n      0%,\n      100% {\n        transform: translateY(-25%);\n        animation-timing-function: cubic-bezier(0.8, 0, 1, 1);\n      }\n\n      50% {\n        transform: none;\n        animation-timing-function: cubic-bezier(0, 0, 0.2, 1);\n      }\n    }\n\n    --blur-xs: 4px;\n    --blur-sm: 8px;\n    --blur-md: 12px;\n    --blur-lg: 16px;\n    --blur-xl: 24px;\n    --blur-2xl: 40px;\n    --blur-3xl: 64px;\n\n    --perspective-dramatic: 100px;\n    --perspective-near: 300px;\n    --perspective-normal: 500px;\n    --perspective-midrange: 800px;\n    --perspective-distant: 1200px;\n\n    --aspect-video: 16 / 9;\n\n    --default-transition-duration: 150ms;\n    --default-transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n    --default-font-family: --theme(--font-sans, initial);\n    --default-font-feature-settings: --theme(\n      --font-sans--font-feature-settings,\n      initial\n    );\n    --default-font-variation-settings: --theme(\n      --font-sans--font-variation-settings,\n      initial\n    );\n    --default-mono-font-family: --theme(--font-mono, initial);\n    --default-mono-font-feature-settings: --theme(\n      --font-mono--font-feature-settings,\n      initial\n    );\n    --default-mono-font-variation-settings: --theme(\n      --font-mono--font-variation-settings,\n      initial\n    );\n  }\n\n  /* Deprecated */\n  @theme default inline reference {\n    --blur: 8px;\n    --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n    --shadow-inner: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);\n    --drop-shadow: 0 1px 2px rgb(0 0 0 / 0.1), 0 1px 1px rgb(0 0 0 / 0.06);\n    --radius: 0.25rem;\n    --max-width-prose: 65ch;\n  }\n}\n\n@layer base {\n  /*\n  1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n  2. Remove default margins and padding\n  3. Reset all borders.\n*/\n\n  *,\n  ::after,\n  ::before,\n  ::backdrop,\n  ::file-selector-button {\n    box-sizing: border-box; /* 1 */\n    margin: 0; /* 2 */\n    padding: 0; /* 2 */\n    border: 0 solid; /* 3 */\n  }\n\n  /*\n  1. Use a consistent sensible line-height in all browsers.\n  2. Prevent adjustments of font size after orientation changes in iOS.\n  3. Use a more readable tab size.\n  4. Use the user's configured `sans` font-family by default.\n  5. Use the user's configured `sans` font-feature-settings by default.\n  6. Use the user's configured `sans` font-variation-settings by default.\n  7. Disable tap highlights on iOS.\n*/\n\n  html,\n  :host {\n    line-height: 1.5; /* 1 */\n    -webkit-text-size-adjust: 100%; /* 2 */\n    tab-size: 4; /* 3 */\n    font-family: --theme(\n      --default-font-family,\n      ui-sans-serif,\n      system-ui,\n      sans-serif,\n      \"Apple Color Emoji\",\n      \"Segoe UI Emoji\",\n      \"Segoe UI Symbol\",\n      \"Noto Color Emoji\"\n    ); /* 4 */\n    font-feature-settings: --theme(\n      --default-font-feature-settings,\n      normal\n    ); /* 5 */\n    font-variation-settings: --theme(\n      --default-font-variation-settings,\n      normal\n    ); /* 6 */\n    -webkit-tap-highlight-color: transparent; /* 7 */\n  }\n\n  /*\n  1. Add the correct height in Firefox.\n  2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n  3. Reset the default border style to a 1px solid border.\n*/\n\n  hr {\n    height: 0; /* 1 */\n    color: inherit; /* 2 */\n    border-top-width: 1px; /* 3 */\n  }\n\n  /*\n  Add the correct text decoration in Chrome, Edge, and Safari.\n*/\n\n  abbr:where([title]) {\n    -webkit-text-decoration: underline dotted;\n    text-decoration: underline dotted;\n  }\n\n  /*\n  Remove the default font size and weight for headings.\n*/\n\n  h1,\n  h2,\n  h3,\n  h4,\n  h5,\n  h6 {\n    font-size: inherit;\n    font-weight: inherit;\n  }\n\n  /*\n  Reset links to optimize for opt-in styling instead of opt-out.\n*/\n\n  a {\n    color: inherit;\n    -webkit-text-decoration: inherit;\n    text-decoration: inherit;\n  }\n\n  /*\n  Add the correct font weight in Edge and Safari.\n*/\n\n  b,\n  strong {\n    font-weight: bolder;\n  }\n\n  /*\n  1. Use the user's configured `mono` font-family by default.\n  2. Use the user's configured `mono` font-feature-settings by default.\n  3. Use the user's configured `mono` font-variation-settings by default.\n  4. Correct the odd `em` font sizing in all browsers.\n*/\n\n  code,\n  kbd,\n  samp,\n  pre {\n    font-family: --theme(\n      --default-mono-font-family,\n      ui-monospace,\n      SFMono-Regular,\n      Menlo,\n      Monaco,\n      Consolas,\n      \"Liberation Mono\",\n      \"Courier New\",\n      monospace\n    ); /* 1 */\n    font-feature-settings: --theme(\n      --default-mono-font-feature-settings,\n      normal\n    ); /* 2 */\n    font-variation-settings: --theme(\n      --default-mono-font-variation-settings,\n      normal\n    ); /* 3 */\n    font-size: 1em; /* 4 */\n  }\n\n  /*\n  Add the correct font size in all browsers.\n*/\n\n  small {\n    font-size: 80%;\n  }\n\n  /*\n  Prevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\n  sub,\n  sup {\n    font-size: 75%;\n    line-height: 0;\n    position: relative;\n    vertical-align: baseline;\n  }\n\n  sub {\n    bottom: -0.25em;\n  }\n\n  sup {\n    top: -0.5em;\n  }\n\n  /*\n  1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n  2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n  3. Remove gaps between table borders by default.\n*/\n\n  table {\n    text-indent: 0; /* 1 */\n    border-color: inherit; /* 2 */\n    border-collapse: collapse; /* 3 */\n  }\n\n  /*\n  Use the modern Firefox focus style for all focusable elements.\n*/\n\n  :-moz-focusring {\n    outline: auto;\n  }\n\n  /*\n  Add the correct vertical alignment in Chrome and Firefox.\n*/\n\n  progress {\n    vertical-align: baseline;\n  }\n\n  /*\n  Add the correct display in Chrome and Safari.\n*/\n\n  summary {\n    display: list-item;\n  }\n\n  /*\n  Make lists unstyled by default.\n*/\n\n  ol,\n  ul,\n  menu {\n    list-style: none;\n  }\n\n  /*\n  1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n  2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n      This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\n  img,\n  svg,\n  video,\n  canvas,\n  audio,\n  iframe,\n  embed,\n  object {\n    display: block; /* 1 */\n    vertical-align: middle; /* 2 */\n  }\n\n  /*\n  Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\n  img,\n  video {\n    max-width: 100%;\n    height: auto;\n  }\n\n  /*\n  1. Inherit font styles in all browsers.\n  2. Remove border radius in all browsers.\n  3. Remove background color in all browsers.\n  4. Ensure consistent opacity for disabled states in all browsers.\n*/\n\n  button,\n  input,\n  select,\n  optgroup,\n  textarea,\n  ::file-selector-button {\n    font: inherit; /* 1 */\n    font-feature-settings: inherit; /* 1 */\n    font-variation-settings: inherit; /* 1 */\n    letter-spacing: inherit; /* 1 */\n    color: inherit; /* 1 */\n    border-radius: 0; /* 2 */\n    background-color: transparent; /* 3 */\n    opacity: 1; /* 4 */\n  }\n\n  /*\n  Restore default font weight.\n*/\n\n  :where(select:is([multiple], [size])) optgroup {\n    font-weight: bolder;\n  }\n\n  /*\n  Restore indentation.\n*/\n\n  :where(select:is([multiple], [size])) optgroup option {\n    padding-inline-start: 20px;\n  }\n\n  /*\n  Restore space after button.\n*/\n\n  ::file-selector-button {\n    margin-inline-end: 4px;\n  }\n\n  /*\n  Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n*/\n\n  ::placeholder {\n    opacity: 1;\n  }\n\n  /*\n  Set the default placeholder color to a semi-transparent version of the current text color in browsers that do not\n  crash when using `color-mix(…)` with `currentcolor`. (https://github.com/tailwindlabs/tailwindcss/issues/17194)\n*/\n\n  @supports (not (-webkit-appearance: -apple-pay-button)) /* Not Safari */ or\n    (contain-intrinsic-size: 1px) /* Safari 17+ */ {\n    ::placeholder {\n      color: color-mix(in oklab, currentcolor 50%, transparent);\n    }\n  }\n\n  /*\n  Prevent resizing textareas horizontally by default.\n*/\n\n  textarea {\n    resize: vertical;\n  }\n\n  /*\n  Remove the inner padding in Chrome and Safari on macOS.\n*/\n\n  ::-webkit-search-decoration {\n    -webkit-appearance: none;\n  }\n\n  /*\n  1. Ensure date/time inputs have the same height when empty in iOS Safari.\n  2. Ensure text alignment can be changed on date/time inputs in iOS Safari.\n*/\n\n  ::-webkit-date-and-time-value {\n    min-height: 1lh; /* 1 */\n    text-align: inherit; /* 2 */\n  }\n\n  /*\n  Prevent height from changing on date/time inputs in macOS Safari when the input is set to `display: block`.\n*/\n\n  ::-webkit-datetime-edit {\n    display: inline-flex;\n  }\n\n  /*\n  Remove excess padding from pseudo-elements in date/time inputs to ensure consistent height across browsers.\n*/\n\n  ::-webkit-datetime-edit-fields-wrapper {\n    padding: 0;\n  }\n\n  ::-webkit-datetime-edit,\n  ::-webkit-datetime-edit-year-field,\n  ::-webkit-datetime-edit-month-field,\n  ::-webkit-datetime-edit-day-field,\n  ::-webkit-datetime-edit-hour-field,\n  ::-webkit-datetime-edit-minute-field,\n  ::-webkit-datetime-edit-second-field,\n  ::-webkit-datetime-edit-millisecond-field,\n  ::-webkit-datetime-edit-meridiem-field {\n    padding-block: 0;\n  }\n\n  /*\n  Center dropdown marker shown on inputs with paired `<datalist>`s in Chrome. (https://github.com/tailwindlabs/tailwindcss/issues/18499)\n*/\n\n  ::-webkit-calendar-picker-indicator {\n    line-height: 1;\n  }\n\n  /*\n  Remove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n  :-moz-ui-invalid {\n    box-shadow: none;\n  }\n\n  /*\n  Correct the inability to style the border radius in iOS Safari.\n*/\n\n  button,\n  input:where([type=\"button\"], [type=\"reset\"], [type=\"submit\"]),\n  ::file-selector-button {\n    appearance: button;\n  }\n\n  /*\n  Correct the cursor style of increment and decrement buttons in Safari.\n*/\n\n  ::-webkit-inner-spin-button,\n  ::-webkit-outer-spin-button {\n    height: auto;\n  }\n\n  /*\n  Make elements with the HTML hidden attribute stay hidden by default.\n*/\n\n  [hidden]:where(:not([hidden=\"until-found\"])) {\n    display: none !important;\n  }\n}\n\n@layer utilities {\n  @tailwind utilities;\n}\n","@import 'tailwindcss';\n@import url('https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Inter:wght@300;400;600&family=MedievalSharp&display=swap');\n\n@theme {\n  --color-dungeon-dark: #0a0a0c;\n  --color-dungeon-brown: #2c1a0e;\n  --color-dungeon-gold: #d4af37;\n  --color-dungeon-gold-dim: #8a7122;\n  --color-dungeon-paper: #eaddcf;\n  --color-dungeon-blood: #660a0a;\n  --color-dungeon-magic: #4b0082;\n  --color-dungeon-action: #2e8b57;\n\n  --font-heading: 'MedievalSharp', cursive;\n  --font-body: 'Cinzel', serif;\n  --font-ui: 'Inter', sans-serif;\n\n  --animate-float: float 6s ease-in-out infinite;\n  --animate-pulse-slow: pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;\n  --animate-shimmer: shimmer 2s linear infinite;\n  --animate-deal: deal 0.5s ease-out forwards;\n  --animate-clash-left: clashLeft 0.6s ease-in forwards;\n  --animate-clash-right: clashRight 0.6s ease-in forwards;\n  --animate-shatter: shatter 0.6s ease-out forwards;\n  --animate-shake: shake 0.5s cubic-bezier(0.36, 0.07, 0.19, 0.97) both;\n}\n\n@keyframes float {\n  0%,\n  100% {\n    transform: translateY(0);\n  }\n  50% {\n    transform: translateY(-10px);\n  }\n}\n\n@keyframes shimmer {\n  0% {\n    background-position: -1000px 0;\n  }\n  100% {\n    background-position: 1000px 0;\n  }\n}\n\n@keyframes deal {\n  0% {\n    transform: translateY(100px) scale(0.5);\n    opacity: 0;\n  }\n  100% {\n    transform: translateY(0) scale(1);\n    opacity: 1;\n  }\n}\n\n@keyframes clashLeft {\n  0% {\n    transform: translateX(-200px) scale(0.8);\n    opacity: 0;\n  }\n  40% {\n    transform: translateX(-250px) scale(0.9);\n    opacity: 1;\n  }\n  100% {\n    transform: translateX(0) scale(1);\n    opacity: 1;\n  }\n}\n\n@keyframes clashRight {\n  0% {\n    transform: translateX(200px) scale(0.8);\n    opacity: 0;\n  }\n  40% {\n    transform: translateX(250px) scale(0.9);\n    opacity: 1;\n  }\n  100% {\n    transform: translateX(0) scale(1);\n    opacity: 1;\n  }\n}\n\n@keyframes shatter {\n  0% {\n    transform: scale(1);\n    filter: brightness(2);\n  }\n  30% {\n    transform: scale(1.2) rotate(15deg);\n    filter: brightness(3) sepia(1) hue-rotate(-50deg);\n    opacity: 0.8;\n  }\n  100% {\n    transform: scale(1.5) rotate(45deg);\n    opacity: 0;\n    filter: brightness(0);\n  }\n}\n\n@keyframes shake {\n  10%,\n  90% {\n    transform: translate3d(-2px, 0, 0);\n  }\n  20%,\n  80% {\n    transform: translate3d(4px, 0, 0);\n  }\n  30%,\n  50%,\n  70% {\n    transform: translate3d(-6px, 0, 0);\n  }\n  40%,\n  60% {\n    transform: translate3d(6px, 0, 0);\n  }\n}\n\n/* Scrollbar Styling */\n::-webkit-scrollbar {\n  width: 6px;\n}\n\n::-webkit-scrollbar-track {\n  background: #14111a;\n}\n\n::-webkit-scrollbar-thumb {\n  background: #2a2535;\n  border-radius: 4px;\n  border: 1px solid #3a3545;\n}\n\n::-webkit-scrollbar-thumb:hover {\n  background: #3a3545;\n}\n\n.custom-scrollbar::-webkit-scrollbar {\n  width: 6px;\n}\n\n.custom-scrollbar::-webkit-scrollbar-track {\n  background: #0a0a0c;\n}\n\n/* Glass Panel */\n.glass-panel {\n  background: rgba(18, 14, 24, 0.8);\n  backdrop-filter: blur(14px);\n  -webkit-backdrop-filter: blur(14px);\n  border: 1px solid rgba(255, 255, 255, 0.08);\n  box-shadow: 0 4px 30px rgba(0, 0, 0, 0.6);\n}\n\n/* CRT Scanline Overlay */\n.scanlines {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n  background: linear-gradient(\n    to bottom,\n    rgba(255, 255, 255, 0),\n    rgba(255, 255, 255, 0) 50%,\n    rgba(0, 0, 0, 0.1) 50%,\n    rgba(0, 0, 0, 0.1)\n  );\n  background-size: 100% 4px;\n  pointer-events: none;\n  z-index: 9999;\n  opacity: 0.15;\n}\n\nbody {\n  background-color: #0a0a10;\n  color: #eaddcf;\n  margin: 0;\n  padding: 0;\n  overflow: hidden;\n}\n"],"names":[],"sourceRoot":""}